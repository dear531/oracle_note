=====================
order by 后可以填表达或者别名为排序条件，排序条件可以为任意表达式，可以与查询投影一致，也可以不一致，相互独立
SQL> select * from t2 where score > 60 and score < 80 order by score+10;

G2_ID   G2_NAME         MEMBER       SCORE
------- --------------- ------- ----------
001002  lianji          010201          65
001001  qianduan        010103          66
002001  qudao           020103          69
003001  shuju           030102          70
001001  qianduan        010102          72
003001  shuju           030101          75
001003  rizhong         010302          78
002001  qudao           020101          79

8 rows selected.
=====================
order by 后接别名，只要别名命名与当前命名是一致的即可，无论别名命名是否合理
SQL> select g2_id, score+20 as "score+5" from t2 order by "score+5";

G2_ID      score+5
------- ----------
001003          64
002002          74
001003          75
002001          76
001002          76
001002          76
001002          85
001001          86
002001          89
003001          90
001001          92

G2_ID      score+5
------- ----------
003001          95
001003          98
002001          99
001001         106
002001         108
002002         109

1
00_11_

20 rows selected.
====================
转义字符的定义与应用
SQL> select *from t2 where g2_id like '00\_11\_' escape '\';

G2_ID   G2_NAME         MEMBER       SCORE
------- --------------- ------- ----------
00_11_  escape

SQL> select * from t2 where g2_id like '00~_11~_' escape '~';

G2_ID   G2_NAME         MEMBER       SCORE
------- --------------- ------- ----------
00_11_  escape
===================
表达是及别名的运用
SQL> select g2_id, (score + 50)/1.2 "fix" from t2;

G2_ID          fix
------- ----------

001001  101.666667
001001  96.6666667
001002  95.8333333
001001  113.333333
001002  88.3333333
001002  88.3333333
001003  78.3333333
001003  106.666667
001003        87.5
002001       107.5

G2_ID          fix
------- ----------
002001  88.3333333
002001  99.1666667
002001         115
002002  86.6666667
002002  115.833333
003001  104.166667
003001         100
1
00_11_

20 rows selected.
=======================
按列号排序
SQL> select g2_id, score from t2 order by 2;

G2_ID        SCORE
------- ----------
001003          44
002002          54
001003          55
002001          56
001002          56
001002          56
001002          65
001001          66
002001          69
003001          70
001001          72
======================
多列多样式（分别升序或降序）排序
SQL> select score, g2_name from t2 order by g2_name, score desc;

     SCORE G2_NAME
---------- ---------------
           escape
        89 file
        54 file
        65 lianji
        56 lianji
        56 lianji
        86 qianduan
        72 qianduan
        66 qianduan
        88 qudao
        79 qudao
==========================
设置显示宽度
SQL> set linesize 80;
或
SQL> set line 80;
==============================
l（list）和行号 替换内容编辑历史命令
/(run)命令继续执行
SQL> select *  
  2  from t2
  3  where g1_id = '002001';
where g1_id = '002001'
      *
ERROR at line 3:
ORA-00904: "G1_ID": invalid identifier


SQL> 3 where g2_id = '002001';
SQL> l  
  1  select *
  2  from t2
  3* where g2_id = '002001'
SQL> /

G2_ID   G2_NAME         MEMBER       SCORE
------- --------------- ------- ----------
002001  qudao           020101          79
002001  qudao           020102          56
002001  qudao           020103          69
002001  qudao           020104          88
===============
a[ppend]追加命令
SQL> select g2_id
  2  from t2;

G2_ID
-------

001001
001001
001002
001001
001002
001002
001003
001003
001003
002001

G2_ID
-------
002001
002001
002001
002002
002002
003001
003001
1
00_11_

20 rows selected.

SQL> l
  1  select g2_id
  2* from t2
SQL> 1
  1* select g2_id
SQL> a , g2_name
  1* select g2_id, g2_name
SQL> /

G2_ID   G2_NAME
------- ---------------
        ???
001001  qianduan
001001  qianduan
001002  lianji
001001  qianduan
001002  lianji
001002  lianji
001003  rizhong
001003  rizhong
001003  rizhong
002001  qudao

G2_ID   G2_NAME
------- ---------------
002001  qudao
002001  qudao
002001  qudao
002002  file
002002  file
003001  shuju
003001  shuju
1       ???
00_11_  escape

20 rows selected.

===============
运行命令 / 或 r[un]
r回显执行命令的内容
/不回显执行命令内容
SQL> r   
  1  select *
  2* from t1

     G1_ID G1_NAME
---------- ----------
         0 a
         1 b

SQL> /

     G1_ID G1_NAME
---------- ----------
         0 a
         1 b
===============
在最前加一行及删除指定行
SQL> 0 add
SQL> l
  1  add
  2  select g2_id, g2_name
  3* from t2
SQL> del 1
SQL> l
  1  select g2_id, g2_name
  2* from t2
==================
删除一段内容
SQL> l
  1  select *
  2  from t1
  3  where g1_id = '0'
  4* and g1_name = 'a'
SQL> del 3 4
SQL> l
  1  select *
  2* from t1
SQL> 
===================
c[hange]命令，替换行当中的内容
SQL> l  
  1  select g1_id
  2* from t1
SQL> 1 
  1* select g1_id
SQL> c /g1_id/g1_name
  1* select g1_name
SQL> l  
  1  select g1_name
  2* from t1
SQL> /  

G1_NAME
----------
a
b
====================
c命令删除一段内容方法
SQL> l
  1  select g1_id, g1_name
  2* from t1
SQL> /  

     G1_ID G1_NAME
---------- ----------
         0 a
         1 b

SQL> 1
  1* select g1_id, g1_name
SQL> c /g1_id,/
  1* select  g1_name
SQL> /  

G1_NAME
----------
a
b

SQL> l
  1  select  g1_name
  2* from t1
======================
将缓存区中的内容保存成脚本：
SQL> l   
  1  select g1_id
  2* from t1
SQL> save save  
Created file save.sql
查看脚本内容：
$ cat save.sql 
select g1_id
from t1
/
====================
将脚本文件读入缓存区
SQL> get save.sql
  1  select g1_id
  2* from t1
SQL> l  
  1  select g1_id
  2* from t1
SQL> /

     G1_ID
----------
         0
         1
====================
直接运行脚本
SQL> @ save.sql

     G1_ID
----------
         0
         1

SQL> @save

     G1_ID
----------
         0
         1
=========================
将屏幕执行结果记录在文件中：
SQL> spool output
SQL> /  

     G1_ID
----------
         0
         1

SQL> spool off /* 执行后关闭导出 */
查看执行结果文件：
$ cat output.lst 
SQL> /

     G1_ID                                                                      
----------                                                                      
         0                                                                      
         1                                                                      

SQL> spool off
========================
单行函数：
转成小写lower
SQL> r
  1* select Lower('ThIs is lower') from dual

LOWER('THISIS
-------------
this is lower
==========================
转成大写：
SQL> select upper('Sql Is Used Exclusively In Rdbmses')   
  2  from dual;

UPPER('SQLISUSEDEXCLUSIVELYINRDBMS
----------------------------------
SQL IS USED EXCLUSIVELY IN RDBMSES
=====================
将所有单词格式化成首字母大写，其他字母小写
SQL> select initcap('SQL is an english like language')
  2  from dual;

INITCAP('SQLISANENGLISHLIKELANG
-------------------------------
Sql Is An English Like Language
===============================
连接字符串函数：
下面是嵌套两个函数的效果
SQL> r
  1  select concat('Top', concat('Mid', 'Tail'))
  2* from dual

CONCAT('TO
----------
TopMidTail
==================================
substr(str, m[,n])
返回一个字符串的子串
本函数为变参函数，最后一个参数填入，则返回填入的长度，如果不填入，则返回从n开始所有str所有的剩余部分
SQL> r     
  1  select substr('12345 67890', 2)
  2* from dual

SUBSTR('12
----------
2345 67890

SQL> 1  
  1* select substr('12345 67890', 2)
SQL> c /, 2)/, 2, 3)
  1* select substr('12345 67890', 2, 3)
SQL> r
  1  select substr('12345 67890', 2, 3)
  2* from dual

SUB
---
234
==============================
返回字符串的长度
SQL> select length('123456')
  2  from dual;

LENGTH('123456')
----------------
               6
=============================
返回字串的位置：
instr(列名|表达式, str, [m], [n])
instr（'源字符串' , '目标字符串' ,'开始位置','第几次出现'）
区分大小写
其中sourceString代表源字符串；
destString代表要从源字符串中查找的子串；
start代表查找的开始位置，这个参数可选的，默认为1；
appearPosition代表想从源字符中查找出第几次出现的destString，这个参数也是可选的，
默认为1
如果start的值为负数，则代表从右往左进行查找，但是位置数据仍然从左向右计算。
返回值为：查找到的字符串的位置。
-------------------------------------------------------------

对于instr函数，我们经常这样使用：从一个字符串中查找指定子串的位置。例如：

SQL> select instr('abcdefgh','de') position from dual;


POSITION
----------
   4
从1开始算 d排第四所以返回4

SQL>select instr('abcdefghbc','bc',3) position from dual;

POSITION
----------
  9
从第3个字符开始算起 第3个字符是c，所以从3开始以后的字符串找查找bc,返回9

---------------------------
从第1个字符开始，查找第2次出现子串的位置
SQL> select instr('qinyinglianqin','qin', 1, 2) position from dual;
POSITION
----------
  12 
===================
从字符串两端去掉一个指定字符
SQL> r  
  1  select trim ('h' from  'headh') "Trim"
  2* from dual

Tri
---
ead

SQL> select trim(leading 'h' from 'headh') "Trim"
  2  from dual;

Trim
----
eadh

SQL> select trim(trailing 'h' from 'headh') "Trim"
  2  from dual;

Trim
----
head
两端多个连续的字符，都递归的去掉
SQL> select trim('h' from 'hheadhh')   
  2  from dual;

TRI
---
ead
===========================
替换函数
SQL> r
  1  select replace('123456','34', 'ab')
  2* from dual

REPLAC
------
12ab56
========================================
round四舍五入函数
trunc截断函数
SQL> r
  1  select round(168.888, 1), trunc(168.888, 1), round(168.999, 1)
  2* from dual

ROUND(168.888,1) TRUNC(168.888,1) ROUND(168.999,1)
---------------- ---------------- ----------------
           168.9            168.8              169
第三列当百分位向十分位进位之后，0.9变成了1.0，直接只显示整数，小数点后因为是零直接不显示了

精确到个位的处理如以下两种方式表达：
SQL> r
  1  select round(168.888, 0),trunc(168.888, 0)
  2* from dual

ROUND(168.888,0) TRUNC(168.888,0)
---------------- ----------------
             169              168

SQL> select round(168.888), trunc(168.888, 0)
  2  from dual;

ROUND(168.888) TRUNC(168.888,0)
-------------- ----------------
           169              168
可以写0位，或是直接忽略不写

四舍五入到10位：
SQL> select round(168.888, -1), trunc(168.888, -1)
  2  from dual;

ROUND(168.888,-1) TRUNC(168.888,-1)
----------------- -----------------
              170               160
=============================
求余：mod
SQL> select mod(1900, 400)   
  2  from dual;

MOD(1900,400)
-------------
          300
=================================
显示系统时间：
SQL> select sysdate from dual;

SYSDATE
---------
12-DEC-16
日期数据计算：
将当前系统日期减掉一天
SQL> select sysdate - 1    
  2  from dual;

SYSDATE-1
---------
11-DEC-16
日期字符串和日期进行计算：
SQL> select to_date('15-jul-12') - sysdate
  2  from dual;

TO_DATE('15-JUL-12')-SYSDATE
----------------------------
                  -1611.6491
系统日期与小时进行计算：
SQL> select sysdate - 22/24
  2  from dual;

SYSDATE-2
---------
11-DEC-16
SQL> r
  1  select sysdate+ 22/24
  2* from dual

SYSDATE+2
---------
13-DEC-16
==========================
返回两个日期之间的月份：
SQL> select months_between('01-jul-99', '01-jul-98')
  2  from dual;

MONTHS_BETWEEN('01-JUL-99','01-JUL-98')
---------------------------------------
                                     12
=============================
将一个日期加上或减去某一个整月：
SQL> select add_months('01-jul-99', 1)
  2  from dual;

ADD_MONTH
---------
01-AUG-99

SQL> 1  
  1* select add_months('01-jul-99', 1)
SQL> c /, 1/, -1 
  1* select add_months('01-jul-99', -1)
SQL> r
  1  select add_months('01-jul-99', -1)
  2* from dual

ADD_MONTH
---------
01-JUN-99
========================
返回一个日期之后的第一个星期几的日期：
SQL> select next_day('10-may-02', 'monday')
  2  from dual;

NEXT_DAY(
---------
13-MAY-02
===========================
返回当前日期所在月份的最后一天：
SQL> r
  1  select last_day('08-feb-02')
  2* from dual

LAST_DAY(
---------
28-FEB-02
按月份四舍五入之后该日期为以下日期：
SQL> select round(to_date('28-oct-01'), 'month')
  2  from dual;

ROUND(TO_
---------
01-NOV-01

==============================
日期按月份截断：
SQL> select trunc(to_date('28-oct-01'), 'month')
  2  from dual;

TRUNC(TO_
---------
01-OCT-01
=============================
日期按年截断：
SQL> select trunc(to_date('28-oct-01'), 'year')
  2  from dual;

TRUNC(TO_
---------
01-JAN-01
