=====================
order by 后可以填表达或者别名为排序条件，排序条件可以为任意表达式，可以与查询投影一致，也可以不一致，相互独立
SQL> select * from t2 where score > 60 and score < 80 order by score+10;

G2_ID   G2_NAME         MEMBER       SCORE
------- --------------- ------- ----------
001002  lianji          010201          65
001001  qianduan        010103          66
002001  qudao           020103          69
003001  shuju           030102          70
001001  qianduan        010102          72
003001  shuju           030101          75
001003  rizhong         010302          78
002001  qudao           020101          79

8 rows selected.
=====================
order by 后接别名，只要别名命名与当前命名是一致的即可，无论别名命名是否合理
SQL> select g2_id, score+20 as "score+5" from t2 order by "score+5";

G2_ID      score+5
------- ----------
001003          64
002002          74
001003          75
002001          76
001002          76
001002          76
001002          85
001001          86
002001          89
003001          90
001001          92

G2_ID      score+5
------- ----------
003001          95
001003          98
002001          99
001001         106
002001         108
002002         109

1
00_11_

20 rows selected.
====================
转义字符的定义与应用
SQL> select *from t2 where g2_id like '00\_11\_' escape '\';

G2_ID   G2_NAME         MEMBER       SCORE
------- --------------- ------- ----------
00_11_  escape

SQL> select * from t2 where g2_id like '00~_11~_' escape '~';

G2_ID   G2_NAME         MEMBER       SCORE
------- --------------- ------- ----------
00_11_  escape
===================
表达是及别名的运用
SQL> select g2_id, (score + 50)/1.2 "fix" from t2;

G2_ID          fix
------- ----------

001001  101.666667
001001  96.6666667
001002  95.8333333
001001  113.333333
001002  88.3333333
001002  88.3333333
001003  78.3333333
001003  106.666667
001003        87.5
002001       107.5

G2_ID          fix
------- ----------
002001  88.3333333
002001  99.1666667
002001         115
002002  86.6666667
002002  115.833333
003001  104.166667
003001         100
1
00_11_

20 rows selected.
=======================
按列号排序
SQL> select g2_id, score from t2 order by 2;

G2_ID        SCORE
------- ----------
001003          44
002002          54
001003          55
002001          56
001002          56
001002          56
001002          65
001001          66
002001          69
003001          70
001001          72
======================
多列多样式（分别升序或降序）排序
SQL> select score, g2_name from t2 order by g2_name, score desc;

     SCORE G2_NAME
---------- ---------------
           escape
        89 file
        54 file
        65 lianji
        56 lianji
        56 lianji
        86 qianduan
        72 qianduan
        66 qianduan
        88 qudao
        79 qudao
==========================
设置显示宽度
SQL> set linesize 80;
或
SQL> set line 80;
==============================
l（list）和行号 替换内容编辑历史命令
/(run)命令继续执行
SQL> select *  
  2  from t2
  3  where g1_id = '002001';
where g1_id = '002001'
      *
ERROR at line 3:
ORA-00904: "G1_ID": invalid identifier


SQL> 3 where g2_id = '002001';
SQL> l  
  1  select *
  2  from t2
  3* where g2_id = '002001'
SQL> /

G2_ID   G2_NAME         MEMBER       SCORE
------- --------------- ------- ----------
002001  qudao           020101          79
002001  qudao           020102          56
002001  qudao           020103          69
002001  qudao           020104          88
===============
a[ppend]追加命令
SQL> select g2_id
  2  from t2;

G2_ID
-------

001001
001001
001002
001001
001002
001002
001003
001003
001003
002001

G2_ID
-------
002001
002001
002001
002002
002002
003001
003001
1
00_11_

20 rows selected.

SQL> l
  1  select g2_id
  2* from t2
SQL> 1
  1* select g2_id
SQL> a , g2_name
  1* select g2_id, g2_name
SQL> /

G2_ID   G2_NAME
------- ---------------
        ???
001001  qianduan
001001  qianduan
001002  lianji
001001  qianduan
001002  lianji
001002  lianji
001003  rizhong
001003  rizhong
001003  rizhong
002001  qudao

G2_ID   G2_NAME
------- ---------------
002001  qudao
002001  qudao
002001  qudao
002002  file
002002  file
003001  shuju
003001  shuju
1       ???
00_11_  escape

20 rows selected.

===============
运行命令 / 或 r[un]
r回显执行命令的内容
/不回显执行命令内容
SQL> r   
  1  select *
  2* from t1

     G1_ID G1_NAME
---------- ----------
         0 a
         1 b

SQL> /

     G1_ID G1_NAME
---------- ----------
         0 a
         1 b
===============
在最前加一行及删除指定行
SQL> 0 add
SQL> l
  1  add
  2  select g2_id, g2_name
  3* from t2
SQL> del 1
SQL> l
  1  select g2_id, g2_name
  2* from t2
==================
删除一段内容
SQL> l
  1  select *
  2  from t1
  3  where g1_id = '0'
  4* and g1_name = 'a'
SQL> del 3 4
SQL> l
  1  select *
  2* from t1
SQL> 
===================
c[hange]命令，替换行当中的内容
SQL> l  
  1  select g1_id
  2* from t1
SQL> 1 
  1* select g1_id
SQL> c /g1_id/g1_name
  1* select g1_name
SQL> l  
  1  select g1_name
  2* from t1
SQL> /  

G1_NAME
----------
a
b
====================
c命令删除一段内容方法
SQL> l
  1  select g1_id, g1_name
  2* from t1
SQL> /  

     G1_ID G1_NAME
---------- ----------
         0 a
         1 b

SQL> 1
  1* select g1_id, g1_name
SQL> c /g1_id,/
  1* select  g1_name
SQL> /  

G1_NAME
----------
a
b

SQL> l
  1  select  g1_name
  2* from t1
======================
将缓存区中的内容保存成脚本：
SQL> l   
  1  select g1_id
  2* from t1
SQL> save save  
Created file save.sql
查看脚本内容：
$ cat save.sql 
select g1_id
from t1
/
====================
将脚本文件读入缓存区
SQL> get save.sql
  1  select g1_id
  2* from t1
SQL> l  
  1  select g1_id
  2* from t1
SQL> /

     G1_ID
----------
         0
         1
====================
直接运行脚本
SQL> @ save.sql

     G1_ID
----------
         0
         1

SQL> @save

     G1_ID
----------
         0
         1
=========================
将屏幕执行结果记录在文件中：
SQL> spool output
SQL> /  

     G1_ID
----------
         0
         1

SQL> spool off /* 执行后关闭导出 */
查看执行结果文件：
$ cat output.lst 
SQL> /

     G1_ID                                                                      
----------                                                                      
         0                                                                      
         1                                                                      

SQL> spool off
========================
单行函数：
转成小写lower
SQL> r
  1* select Lower('ThIs is lower') from dual

LOWER('THISIS
-------------
this is lower
==========================
转成大写：
SQL> select upper('Sql Is Used Exclusively In Rdbmses')   
  2  from dual;

UPPER('SQLISUSEDEXCLUSIVELYINRDBMS
----------------------------------
SQL IS USED EXCLUSIVELY IN RDBMSES
=====================
将所有单词格式化成首字母大写，其他字母小写
SQL> select initcap('SQL is an english like language')
  2  from dual;

INITCAP('SQLISANENGLISHLIKELANG
-------------------------------
Sql Is An English Like Language
===============================
连接字符串函数：
下面是嵌套两个函数的效果
SQL> r
  1  select concat('Top', concat('Mid', 'Tail'))
  2* from dual

CONCAT('TO
----------
TopMidTail
==================================
substr(str, m[,n])
返回一个字符串的子串
本函数为变参函数，最后一个参数填入，则返回填入的长度，如果不填入，则返回从n开始所有str所有的剩余部分
SQL> r     
  1  select substr('12345 67890', 2)
  2* from dual

SUBSTR('12
----------
2345 67890

SQL> 1  
  1* select substr('12345 67890', 2)
SQL> c /, 2)/, 2, 3)
  1* select substr('12345 67890', 2, 3)
SQL> r
  1  select substr('12345 67890', 2, 3)
  2* from dual

SUB
---
234
==============================
返回字符串的长度
SQL> select length('123456')
  2  from dual;

LENGTH('123456')
----------------
               6
=============================
返回字串的位置：
instr(列名|表达式, str, [m], [n])
instr（'源字符串' , '目标字符串' ,'开始位置','第几次出现'）
区分大小写
其中sourceString代表源字符串；
destString代表要从源字符串中查找的子串；
start代表查找的开始位置，这个参数可选的，默认为1；
appearPosition代表想从源字符中查找出第几次出现的destString，这个参数也是可选的，
默认为1
如果start的值为负数，则代表从右往左进行查找，但是位置数据仍然从左向右计算。
返回值为：查找到的字符串的位置。
-------------------------------------------------------------

对于instr函数，我们经常这样使用：从一个字符串中查找指定子串的位置。例如：

SQL> select instr('abcdefgh','de') position from dual;


POSITION
----------
   4
从1开始算 d排第四所以返回4

SQL>select instr('abcdefghbc','bc',3) position from dual;

POSITION
----------
  9
从第3个字符开始算起 第3个字符是c，所以从3开始以后的字符串找查找bc,返回9

---------------------------
从第1个字符开始，查找第2次出现子串的位置
SQL> select instr('qinyinglianqin','qin', 1, 2) position from dual;
POSITION
----------
  12 
===================
从字符串两端去掉一个指定字符
SQL> r  
  1  select trim ('h' from  'headh') "Trim"
  2* from dual

Tri
---
ead

SQL> select trim(leading 'h' from 'headh') "Trim"
  2  from dual;

Trim
----
eadh

SQL> select trim(trailing 'h' from 'headh') "Trim"
  2  from dual;

Trim
----
head
两端多个连续的字符，都递归的去掉
SQL> select trim('h' from 'hheadhh')   
  2  from dual;

TRI
---
ead
===========================
替换函数
SQL> r
  1  select replace('123456','34', 'ab')
  2* from dual

REPLAC
------
12ab56
========================================
round四舍五入函数
trunc截断函数
SQL> r
  1  select round(168.888, 1), trunc(168.888, 1), round(168.999, 1)
  2* from dual

ROUND(168.888,1) TRUNC(168.888,1) ROUND(168.999,1)
---------------- ---------------- ----------------
           168.9            168.8              169
第三列当百分位向十分位进位之后，0.9变成了1.0，直接只显示整数，小数点后因为是零直接不显示了

精确到个位的处理如以下两种方式表达：
SQL> r
  1  select round(168.888, 0),trunc(168.888, 0)
  2* from dual

ROUND(168.888,0) TRUNC(168.888,0)
---------------- ----------------
             169              168

SQL> select round(168.888), trunc(168.888, 0)
  2  from dual;

ROUND(168.888) TRUNC(168.888,0)
-------------- ----------------
           169              168
可以写0位，或是直接忽略不写

四舍五入到10位：
SQL> select round(168.888, -1), trunc(168.888, -1)
  2  from dual;

ROUND(168.888,-1) TRUNC(168.888,-1)
----------------- -----------------
              170               160
=============================
求余：mod
SQL> select mod(1900, 400)   
  2  from dual;

MOD(1900,400)
-------------
          300
=================================
显示系统时间：
SQL> select sysdate from dual;

SYSDATE
---------
12-DEC-16
日期数据计算：
将当前系统日期减掉一天
SQL> select sysdate - 1    
  2  from dual;

SYSDATE-1
---------
11-DEC-16
日期字符串和日期进行计算：
SQL> select to_date('15-jul-12') - sysdate
  2  from dual;

TO_DATE('15-JUL-12')-SYSDATE
----------------------------
                  -1611.6491
系统日期与小时进行计算：
SQL> select sysdate - 22/24
  2  from dual;

SYSDATE-2
---------
11-DEC-16
SQL> r
  1  select sysdate+ 22/24
  2* from dual

SYSDATE+2
---------
13-DEC-16
==========================
返回两个日期之间的月份：
SQL> select months_between('01-jul-99', '01-jul-98')
  2  from dual;

MONTHS_BETWEEN('01-JUL-99','01-JUL-98')
---------------------------------------
                                     12
=============================
将一个日期加上或减去某一个整月：
SQL> select add_months('01-jul-99', 1)
  2  from dual;

ADD_MONTH
---------
01-AUG-99

SQL> 1  
  1* select add_months('01-jul-99', 1)
SQL> c /, 1/, -1 
  1* select add_months('01-jul-99', -1)
SQL> r
  1  select add_months('01-jul-99', -1)
  2* from dual

ADD_MONTH
---------
01-JUN-99
========================
返回一个日期之后的第一个星期几的日期：
SQL> select next_day('10-may-02', 'monday')
  2  from dual;

NEXT_DAY(
---------
13-MAY-02
===========================
返回当前日期所在月份的最后一天：
SQL> r
  1  select last_day('08-feb-02')
  2* from dual

LAST_DAY(
---------
28-FEB-02
按月份四舍五入之后该日期为以下日期：
SQL> select round(to_date('28-oct-01'), 'month')
  2  from dual;

ROUND(TO_
---------
01-NOV-01

==============================
日期按月份截断：
SQL> select trunc(to_date('28-oct-01'), 'month')
  2  from dual;

TRUNC(TO_
---------
01-OCT-01
=============================
日期按年截断：
SQL> select trunc(to_date('28-oct-01'), 'year')
  2  from dual;

TRUNC(TO_
---------
01-JAN-01
================================
建立月份值：
SQL> r  
  1  insert into e1
  2  (id, name, date1)
  3* values (1, 'b', '01-jul-01')

1 row created.
==================================
将月份转成固定格式字符串：
SQL> r
  1  select to_char(date1, 'DD/MM/YY'),to_char(date1, 'DAY/month/year')
  2* from e1

TO_CHAR( TO_CHAR(DATE1,'DAY/MONTH/YEAR')
--------
--------------------------------------------------------------------------------------------------
01/07/01 SUNDAY   /july     /two thousand one
=================================
SQL> r
  1  select to_char(date1, 'dd/mm/yy'), to_char(date1, 'day month year')
  2* from e1

TO_CHAR( TO_CHAR(DATE1,'DAYMONTHYEAR')
--------
--------------------------------------------------------------------------------------------------
01/07/01 sunday    july      two thousand one


===============================
SQL> r
  1  select to_char(date1, 'fmddspth "of" month year fmHH:MI:ss am')
  2* from e1

TO_CHAR(DATE1,'FMDDSPTH"OF"MONTHYEARFMHH:MI:SSAM')
----------------------------------------------------------------------------------------------------
first of july two thousand one 12:00:00 am

===================================
以金额的固定格式显示数字
SQL> select to_char(score*12,  '$99,999.00') money   
  2  from t2;

MONEY
-----------

    $864.00
    $792.00
    $780.00
  $1,032.00
    $672.00
==================================
分支判断执行函数：
以下语句表示，当member为020102，020103和020104时，分别decode函数的返回值分别是
将score乘以2，3，4，当member不是上述三个值时，则直接返回score
SQL> select member, decode(member, '020102', score*2
  2  ,'020103', score*3
  3  ,'020104', score*4
  4  , score)   
  5  "new_score"
  6  from t2;

MEMBER   new_score
------- ----------

010102          72
010103          66
010201          65
010101          86
010202          56
010202          56
010301          44
010302          78
010303          55
020101          79

MEMBER   new_score
------- ----------
020102         112
020103         207
020104         352
020201          54
020202          89
030101          75
030102          70


40101

21 rows selected.
=============================
函数嵌套并使用别名排序：
SQL> r
  1  select member, nvl(to_char(score), '0') "new_score"
  2  from t2
  3  where member is not null
  4* order by "new_score"

MEMBER  new_score
------- ----------------------------------------
40101   0
010301  44
020201  54
010303  55
020102  56
010202  56
010202  56
010201  65
010103  66
020103  69
030102  70

MEMBER  new_score
------- ----------------------------------------
010102  72
030101  75
010302  78
020101  79
010101  86
020104  88
020202  89

18 rows selected.

===========================
NVL2用法：
SQL> r   
  1  select nvl2(member, to_char(score + 100), '00') "score_new"
  2* from t2
表达式1不为空，则返回表达式2，否则返回表达式3，函数的返回值是表达2的类型
score_new
----------------------------------------
00
172
166
165
186
156
156
144
178
155
179

score_new
----------------------------------------
156
169
188
154
189
175
170
00
00


21 rows selected.
============================
检查两个值是否相等：不相等返回表达式1的值，相等则返回null
SQL> select * from t2;

G2_ID   G2_NAME         MEMBER       SCORE     SCORE2
------- --------------- ------- ---------- ----------
        ???                                        56
001001  qianduan        010102          72         56
001001  qianduan        010103          66         56
001002  lianji          010201          65         56
001001  qianduan        010101          86         56
001002  lianji          010202          56         56
001002  lianji          010202          56         56
001003  rizhong         010301          44         56
001003  rizhong         010302          78         56
001003  rizhong         010303          55         56
002001  qudao           020101          79         56

G2_ID   G2_NAME         MEMBER       SCORE     SCORE2
------- --------------- ------- ---------- ----------
002001  qudao           020102          56         56
002001  qudao           020103          69         56
002001  qudao           020104          88         56
002002  file            020201          54         56
002002  file            020202          89         56
003001  shuju           030101          75         56
003001  shuju           030102          70         56
1       ???                                        56
00_11_  escape                                     56
004001  Linshi          40101                      56

21 rows selected.

SQL> select nullif(score, score2)
  2  from t2;

NULLIF(SCORE,SCORE2)
--------------------

                  72
                  66
                  65
                  86


                  44
                  78
                  55
                  79

NULLIF(SCORE,SCORE2)
--------------------

                  69
                  88
                  54
                  89
                  75
                  70




21 rows selected.
============================
利用nvl2函数和nullif函数判断两列是否相等的结果：
SQL> r       
  1  select nvl2(nullif(score, score2), 'is not null', 'is null')
  2* from t2

NVL2(NULLIF
-----------
is null
is not null
is not null
is not null
is not null
is null
is null
is not null
is not null
is not null
is not null

NVL2(NULLIF
-----------
is null
is not null
is not null
is not null
is not null
is not null
is not null
is null
is null
is null

21 rows selected.
========================
返回直到不为空表达式函数：
SQL> select * from e3;

STR1  STR2  STR3  STR4
----- ----- ----- -----
11
21    22
31    32    33
41    42    43    44

SQL> select coalesce(str4, str3, str2, str1) 
  2  from e3;

COALE
-----
11
22
33
44
=================================
综合数据和分组函数：
SQL> select * from e3;

STR1  STR2  STR3  STR4
----- ----- ----- -----
11
21    22
31    32    33
41    42    43    44

SQL> select count(str1), count(str2), count(str3), count(str4)
  2  from e3;

COUNT(STR1) COUNT(STR2) COUNT(STR3) COUNT(STR4)
----------- ----------- ----------- -----------
          4           3           2           1
===================================
求和函数和求平均值函数：
SQL> select * from t2;

G2_ID   G2_NAME         MEMBER       SCORE     SCORE2
------- --------------- ------- ---------- ----------
        ???                                        56
001001  qianduan        010102          72         56
001001  qianduan        010103          66         56
001002  lianji          010201          65         56
001001  qianduan        010101          86         56
001002  lianji          010202          56         56
001002  lianji          010202          56         56
001003  rizhong         010301          44         56
001003  rizhong         010302          78         56
001003  rizhong         010303          55         56
002001  qudao           020101          79         56

G2_ID   G2_NAME         MEMBER       SCORE     SCORE2
------- --------------- ------- ---------- ----------
002001  qudao           020102          56         56
002001  qudao           020103          69         56
002001  qudao           020104          88         56
002002  file            020201          54         56
002002  file            020202          89         56
003001  shuju           030101          75         56
003001  shuju           030102          70         56
1       ???                                        56
00_11_  escape                                     56
004001  Linshi          40101                      56

SQL> r  
  1  select avg(score) avg, sum(score) sum, count(score) count,
  2  avg(score2) avg2, sum(score2) sum2, count(score2) count2
  3* from t2

       AVG        SUM      COUNT       AVG2       SUM2     COUNT2
---------- ---------- ---------- ---------- ---------- ----------
68.1176471       1158         17         56       1176         21
=========================
最大和最小值得函数：
SQL> r  
  1  select min(score) min_score,
  2  min(score2) min_score2,
  3  max(score) max_score, max(score2) max_score2
  4* from t2

 MIN_SCORE MIN_SCORE2  MAX_SCORE MAX_SCORE2
---------- ---------- ---------- ----------
        44         56         89         56
=========================
求字符串的最大最小值：
SQL> select max(g2_name) max, 
  2  min(g2_name) min
  3  from t2;

MAX             MIN
--------------- ---------------
???             Linshi
============================
按g2_id分组计算成员数量：
SQL> select g2_id, count(member) from t2 group by g2_id;

G2_ID   COUNT(MEMBER)
------- -------------
                    0
002002              2
1                   0
004001              1
001001              3
001003              3
002001              4
003001              2
001002              3
00_11_              0

10 rows selected.
==========================
分组统计数量之后再排序：
SQL> r
  1  select g2_id,
  2  count(member) "count_member"
  3  from t2
  4  group by g2_id
  5* order by "count_member"

G2_ID   count_member
------- ------------
1                  0
00_11_             0
                   0
004001             1
003001             2
002002             2
001003             3
001001             3
001002             3
002001             4

10 rows selected.
===================
使用函数组名进行group by排序：
SQL> r
  1  select g2_id,
  2  count(member) "count_member"
  3  from t2
  4  group by g2_id
  5* order by count(member)

G2_ID   count_member
------- ------------
1                  0
00_11_             0
                   0
004001             1
003001             2
002002             2
001003             3
001001             3
001002             3
002001             4

10 rows selected.
======================
group by + having用法：
SQL> r
  1  select g2_id, avg(score) avg_score
  2  from t2
  3  group by g2_id
  4* having avg(score) > 60

G2_ID    AVG_SCORE
------- ----------
002002        71.5
001001  74.6666667
002001          73
003001        72.5
=====================
正常不加having的结果，60以下和空均显示出来了
SQL> r
  1  select g2_id, avg(score) avg_score
  2  from t2
  3* group by g2_id

G2_ID    AVG_SCORE
------- ----------

002002        71.5
1
004001
001001  74.6666667
001003          59
002001          73
003001        72.5
001002          59
00_11_

10 rows selected.
===================
通过分组函数计算平均值，筛选需要的分组函数结果，再排序：
SQL> r
  1  select g2_id, avg(score) avg_score
  2  from t2
  3  group by g2_id
  4  having avg(score) > 60
  5* order by avg(score)

G2_ID    AVG_SCORE
------- ----------
002002        71.5
003001        72.5
002001          73
001001  74.6666667
=========================
对数据去掉不想要的原始筛选(where)，再根据分组求均值(agv函数＋group by)，再去掉分组均值中不想要的(having)
SQL> r
  1  select g2_id, avg(score) avg_score
  2  from t2
  3  where g2_id not like '003%'
  4  group by g2_id
  5  having avg(score) > 60
  6* order by avg(score)

G2_ID    AVG_SCORE
------- ----------
002002        71.5
002001          73
001001  74.6666667
===============================
分组函数最多只能嵌套两层，并且不能显示其他映射字段，因为有可能根据排序得到的最小值不唯一：
SQL> r
  1  select min(avg(score)),
  2  max(avg(score))
  3  from t2
  4* group by g2_id

MIN(AVG(SCORE)) MAX(AVG(SCORE))
--------------- ---------------
             59      74.6666667
===============================
count函数统计的结果不包括空值：
SQL> r
  1  select avg(score), avg(score2),
  2  sum(score), count(score), sum(score)/count(score), count(score2),
count(nvl(score, 0)),sum(score)/count(nvl(score, 0)), sum(nvl(score,
0))/count(nvl(score, 0))
  3* from t2

AVG(SCORE) AVG(SCORE2) SUM(SCORE) COUNT(SCORE) SUM(SCORE)/COUNT(SCORE)
COUNT(SCORE2) COUNT(NVL(SCORE,0))
---------- ----------- ---------- ------------ -----------------------
------------- -------------------
SUM(SCORE)/COUNT(NVL(SCORE,0)) SUM(NVL(SCORE,0))/COUNT(NVL(SCORE,0))
------------------------------ -------------------------------------
68.1176471          56       1158           17              68.1176471 21                  21
                    55.1428571                            55.1428571


============================================
联合查询，有重名字段必须显示用指定表明对象的方法表示要显示的列名：
SQL> r 
  1  select g1_id, g1_name, t1.g2_id, t1.g2_name, member, score, score2
  2  from t1, t2
  3  where t1.g2_id = t2.g2_id
  4* order by t1.g2_id

G1_ID   G1_NAME         G2_ID   G2_NAME         MEMBER       SCORE     SCORE2
------- --------------- ------- --------------- ------- ---------- ----------
001     yf01            001001  qianduan        010103          66         56
001     yf01            001001  qianduan        010102          72         56
001     yf01            001001  qianduan        010101          86         56
001     yf01            001002  lianji          010201          65         56
001     yf01            001002  lianji          010202          56         56
001     yf01            001002  lianji          010202          56         56
001     yf01            001003  rizhong         010302          78         56
001     yf01            001003  rizhong         010301          44         56
001     yf01            001003  rizhong         010303          55         56
002     yf02            002001  qudao           020101          79         56
002     yf02            002001  qudao           020102          56         56

G1_ID   G1_NAME         G2_ID   G2_NAME         MEMBER       SCORE     SCORE2
------- --------------- ------- --------------- ------- ---------- ----------
002     yf02            002001  qudao           020103          69         56
002     yf02            002001  qudao           020104          88         56
002     yf02            002002  file            020201          54         56
002     yf02            002002  file            020202          89         56
003     yf03            003001  shuju           030101          75         56
003     yf03            003001  shuju           030102          70         56

17 rows selected.
===============================
带条件的连接
SQL> r
  1  select g1_id, g1_name, t1.g2_id, t1.g2_name, member, score, score2
  2  from t1, t2
  3  where t1.g2_id = t2.g2_id
  4* and t2.score >= 60

G1_ID   G1_NAME         G2_ID   G2_NAME         MEMBER       SCORE     SCORE2
------- --------------- ------- --------------- ------- ---------- ----------
001     yf01            001001  qianduan        010102          72         56
001     yf01            001001  qianduan        010103          66         56
001     yf01            001002  lianji          010201          65         56
001     yf01            001001  qianduan        010101          86         56
001     yf01            001003  rizhong         010302          78         56
002     yf02            002001  qudao           020101          79         56
002     yf02            002001  qudao           020103          69         56
002     yf02            002001  qudao           020104          88         56
002     yf02            002002  file            020202          89         56
003     yf03            003001  shuju           030101          75         56
003     yf03            003001  shuju           030102          70         56

11 rows selected.
===========================
代别名的联合连接查询：
SQL> select a.g1_id, a.g1_name, a.g2_id, a.g2_name, b.member, b.score,
b.score2
  2  from t1 a, t2 b
  3  where a.g2_id = b.g2_id
  4  and b.score >= 60;

G1_ID   G1_NAME         G2_ID   G2_NAME         MEMBER       SCORE     SCORE2
------- --------------- ------- --------------- ------- ---------- ----------
001     yf01            001001  qianduan        010102          72         56
001     yf01            001001  qianduan        010103          66         56
001     yf01            001002  lianji          010201          65         56
001     yf01            001001  qianduan        010101          86         56
001     yf01            001003  rizhong         010302          78         56
002     yf02            002001  qudao           020101          79         56
002     yf02            002001  qudao           020103          69         56
002     yf02            002001  qudao           020104          88         56
002     yf02            002002  file            020202          89         56
003     yf03            003001  shuju           030101          75         56
003     yf03            003001  shuju           030102          70         56

11 rows selected.
=====================================
自连接：
SQL> desc work;
 Name                                      Null?    Type
 ----------------------------------------- --------
----------------------------
 ID                                                 VARCHAR2(10)
 NAME                                               VARCHAR2(10)
 JOB                                                VARCHAR2(10)
 MONEY                                              NUMBER(10)
 MANAGE                                             VARCHAR2(10)

SQL> select * from work;

ID         NAME       JOB             MONEY MANAGE
---------- ---------- ---------- ---------- ----------
01         boss       boss            10000 boss
02         manage01   manage           5000 boss
03         normal01   normal           2000 manage
04         normal02   normal           1900 manage

SQL> r 
  1  select a.id, a.name, a.job, a.money, a.manage
  2  from work a, work b
  3  where a.job=b.manage
  4* and b.manage='manage'

ID         NAME       JOB             MONEY MANAGE
---------- ---------- ---------- ---------- ----------
02         manage01   manage           5000 boss
02         manage01   manage           5000 boss

==========================
用between为条件的不等连接:
SQL> select * from money_t;

        ID        LOW      HIGHT
---------- ---------- ----------
         0       1000       2000

SQL> r
  1  select w.id, w.name, w.money, w.job
  2  from work w, money_t m
  3* where w.money between m.low and m.hight

ID         NAME            MONEY JOB
---------- ---------- ---------- ----------
03         normal01         2000 normal
04         normal02         1900 normal

=======================
外连接：
联合两张表当中相等的部分之外
a.name(+)=b.name表示，将a表中没有的，而b表中有的字段也显示出来
投影字段中表a没有的字段则显示为空
将＋放在数据少的那一边
SQL> select * from t2;

G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
---------- ---------- ---------- ---------- ----------
00         A          0001               60
00         A          0002               59
00         A          0003               61
01         B          0101               80
01         B          0102               90
02         C          0201              100

6 rows selected.

SQL> select * from t1;

G1_ID G1_NAME    G2_ID      G2_NAME
----- ---------- ---------- ----------
0     a          00         A
1     b          01         B

SQL> r
  1  select g1_id, g1_name, t1.g2_id, t1.g2_name
  2  , member, score, score2
  3  from t1, t2
  4* where t1.g2_id(+) = t2.g2_id

G1_ID G1_NAME    G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
----- ---------- ---------- ---------- ---------- ---------- ----------
0     a          00         A          0003               61
0     a          00         A          0002               59
0     a          00         A          0001               60
1     b          01         B          0102               90
1     b          01         B          0101               80
                                       0201              100

6 rows selected.

====================================
两张表的笛卡尔积连接，oracle方法和1999标准sql语法：
SQL> r
  1  select g1_id, g1_name, t1.g2_id, t1.g2_name
  2  , member, score, score2
  3  from t1
  4* cross join t2

G1_ID G1_NAME    G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
----- ---------- ---------- ---------- ---------- ---------- ----------
0     a          00         A          0001               60
0     a          00         A          0002               59
0     a          00         A          0003               61
0     a          00         A          0101               80
0     a          00         A          0102               90
0     a          00         A          0201              100
1     b          01         B          0001               60
1     b          01         B          0002               59
1     b          01         B          0003               61
1     b          01         B          0101               80
1     b          01         B          0102               90

G1_ID G1_NAME    G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
----- ---------- ---------- ---------- ---------- ---------- ----------
1     b          01         B          0201              100

12 rows selected.

SQL> r
  1  select g1_id, g1_name, t1.g2_id, t1.g2_name
  2  , member, score, score2
  3* from t1, t2

G1_ID G1_NAME    G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
----- ---------- ---------- ---------- ---------- ---------- ----------
0     a          00         A          0001               60
0     a          00         A          0002               59
0     a          00         A          0003               61
0     a          00         A          0101               80
0     a          00         A          0102               90
0     a          00         A          0201              100
1     b          01         B          0001               60
1     b          01         B          0002               59
1     b          01         B          0003               61
1     b          01         B          0101               80
1     b          01         B          0102               90

G1_ID G1_NAME    G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
----- ---------- ---------- ---------- ---------- ---------- ----------
1     b          01         B          0201              100

12 rows selected.
=======================
使用using的联合等同于相等连接查询：

表样例：
SQL> select * from t1;

G1_ID G1_NAME    G2_ID      G2_NAME
----- ---------- ---------- ----------
0     a          00         A
1     b          01         B
1+    b+         01         B+

SQL> select * from t2;

G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
---------- ---------- ---------- ---------- ----------
00         A          0001               60
00         A          0002               59
00         A          0003               61
01         B          0101               80
01         B          0102               90
02         C          0201              100

6 rows selected.

相等连接：
SQL> select g1_id, g1_name, t1.g2_id, t1.g2_name
  2  , member, score, score2
  3  from t1, t2
  4  where t1.g2_id = t2.g2_id;

G1_ID G1_NAME    G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
----- ---------- ---------- ---------- ---------- ---------- ----------
0     a          00         A          0001               60
0     a          00         A          0002               59
0     a          00         A          0003               61
1+    b+         01         B+         0101               80
1     b          01         B          0101               80
1+    b+         01         B+         0102               90
1     b          01         B          0102               90

7 rows selected.

使用using
SQL> r
  1  select g1_id, g1_name, g2_id, t1.g2_name
  2  , member, score, score2
  3  from t1
  4  join t2
  5  using(g2_id)
  6*

G1_ID G1_NAME    G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
----- ---------- ---------- ---------- ---------- ---------- ----------
0     a          00         A          0001               60
0     a          00         A          0002               59
0     a          00         A          0003               61
1+    b+         01         B+         0101               80
1     b          01         B          0101               80
1+    b+         01         B+         0102               90
1     b          01         B          0102               90

7 rows selected.


==========================
以上t1和t2不变，on语句用法：
SQL> select t1.g1_id, t1.g1_name, t1.g2_id, t1.g2_name
  2  , t2.member, t2.score, t2.score2
  3  from t1 
  4  join t2
  5  on (t1.g2_id = t2.g2_id);

G1_ID G1_NAME    G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
----- ---------- ---------- ---------- ---------- ---------- ----------
0     a          00         A          0001               60
0     a          00         A          0002               59
0     a          00         A          0003               61
1+    b+         01         B+         0101               80
1     b          01         B          0101               80
1+    b+         01         B+         0102               90
1     b          01         B          0102               90

7 rows selected.
==========================
on语句不带表明：
SQL> r
  1  select g1_id, g1_name, t1.g2_id, t1.g2_name,
  2  member, score, score2
  3  from t1
  4  join t2
  5  on(t1.g2_id = t2.g2_id)
  6*

G1_ID G1_NAME    G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
----- ---------- ---------- ---------- ---------- ---------- ----------
0     a          00         A          0001               60
0     a          00         A          0002               59
0     a          00         A          0003               61
1+    b+         01         B+         0101               80
1     b          01         B          0101               80
1+    b+         01         B+         0102               90
1     b          01         B          0102               90

7 rows selected.
===========================
多表连接和附加条件：
SQL> select * from t1;

G1_ID G1_NAME    G2_ID      G2_NAME
----- ---------- ---------- ----------
0     a          00         A
1     b          01         B
1+    b+         01         B+

SQL> select * from t2;

G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
---------- ---------- ---------- ---------- ----------
00         A          0001               60
00         A          0002               59
00         A          0003               61
01         B          0101               80
01         B          0102               90
02         C          0201              100

6 rows selected.

SQL> select * from t3;

ID   NAME       JOB        MANAGE
---- ---------- ---------- ----------
00   0001       boss       boss
01   0002       manage     boss
02   0003       normal     manage

SQL> r
  1  select g1_id, g1_name, t2.g2_id, t2.g2_name
  2  , member, score, score2, name, job, manage
  3  from t1
  4  join t2
  5  on t1.g2_id = t2.g2_id
  6  join t3
  7* on t2.member = t3.name

G1_ID G1_NAME    G2_ID      G2_NAME    MEMBER          SCORE     SCORE2 NAME JOB        MANAGE
----- ---------- ---------- ---------- ---------- ---------- ---------- ---------- ---------- ----------
0     a          00         A          0001               60            0001 boss       boss
0     a          00         A          0002               59            0002 manage     boss
0     a          00         A          0003               61            0003 normal     manage
=========================
相等连接，左连接和右连接：
相等：
SQL> r
  1  select g1_id, g1_name, t1.g2_id, t1.g2_name
  2  , member, score, score2
  3  from t1
  4  join t2
  5* on t1.g2_id = t2.g2_id

G1_ID G1_NAME    G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
----- ---------- ---------- ---------- ---------- ---------- ----------
0     a          00         A          0001               60
0     a          00         A          0002               59
0     a          00         A          0003               61
1+    b+         01         B+         0101               80
1     b          01         B          0101               80
1+    b+         01         B+         0102               90
1     b          01         B          0102               90
左连接和右连接：
SQL> r
  1  select g1_id, g1_name, t1.g2_id, t1.g2_name
  2  , member, score, score2
  3  from t1
  4  left outer join t2
  5* on t1.g2_id = t2.g2_id

G1_ID G1_NAME    G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
----- ---------- ---------- ---------- ---------- ---------- ----------
0     a          00         A          0001               60
0     a          00         A          0002               59
0     a          00         A          0003               61
1+    b+         01         B+         0101               80
1     b          01         B          0101               80
1+    b+         01         B+         0102               90
1     b          01         B          0102               90
3     d          03         D

8 rows selected.

SQL> 4    
  4* left outer join t2
SQL> c /left/right
  4* right outer join t2
SQL> r
  1  select g1_id, g1_name, t1.g2_id, t1.g2_name
  2  , member, score, score2
  3  from t1
  4  right outer join t2
  5* on t1.g2_id = t2.g2_id

G1_ID G1_NAME    G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
----- ---------- ---------- ---------- ---------- ---------- ----------
0     a          00         A          0003               61
0     a          00         A          0002               59
0     a          00         A          0001               60
1     b          01         B          0102               90
1     b          01         B          0101               80
1+    b+         01         B+         0102               90
1+    b+         01         B+         0101               80
                                       0201              100

8 rows selected.
====================
全连接：
SQL> c /right/full
  4* full outer join t2
SQL> r
  1  select g1_id, g1_name, t1.g2_id, t1.g2_name
  2  , member, score, score2
  3  from t1
  4  full outer join t2
  5* on t1.g2_id = t2.g2_id

G1_ID G1_NAME    G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
----- ---------- ---------- ---------- ---------- ---------- ----------
0     a          00         A          0001               60
0     a          00         A          0002               59
0     a          00         A          0003               61
1+    b+         01         B+         0101               80
1     b          01         B          0101               80
1+    b+         01         B+         0102               90
1     b          01         B          0102               90
                                       0201              100
3     d          03         D

9 rows selected.
=================================
子句查询：

SQL> select * from t2;

G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
---------- ---------- ---------- ---------- ----------
00         A          0001               60
00         A          0002               59
00         A          0003               61
01         B          0101               80
01         B          0102               90
02         C          0201              100

6 rows selected.
上述表查询成员0002同组名而且成绩大于成员0001的记录
SQL> r
  1  select * from t2
  2  where g2_id = (
  3  select g2_id from t2 where member = '0002')
  4  and score > (
  5* select score from t2 where member = '0001')

G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
---------- ---------- ---------- ---------- ----------
00         A          0003               61

显示成绩在平均成绩以下的记录：
SQL> select * from t2
  2  where score < ( 
  3  select avg(score) from t2);

G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
---------- ---------- ---------- ---------- ----------
00         A          0001               60
00         A          0002               59
00         A          0003               61

=============================
having子句中的单行子查询：
显示按g2_id分组平均中大于最小平均值的分组：
SQL> r  
  1  select min(score), max(score), avg(score), g2_id
  2  from t2
  3  group by g2_id
  4  having avg(score) >
  5  (select min(avg(score))
  6     from t2
  7*    group by g2_id)

MIN(SCORE) MAX(SCORE) AVG(SCORE) G2_ID
---------- ---------- ---------- ----------
        80         90         85 01
       100        100        100 02
=================================
from子句中单行子句用法：
先得到按g2_id分组的平均值
再按g2_id和表中score成绩进行比较，得到大于平均值的记录：
SQL> r
  1  select a.g2_id, g2_name, member, score, score2
  2  , avg
  3  from t2 a,
  4  (select g2_id, avg(score) avg from t2 group by g2_id) b
  5  where a.g2_id = b.g2_id
  6* and a.score > b.avg

G2_ID      G2_NAME    MEMBER          SCORE     SCORE2        AVG
---------- ---------- ---------- ---------- ---------- ----------
00         A          0003               61                    60
01         B          0102               90                    85

原始数据和未加限定条件大于平均值时情况如下：
SQL> select * from t2;

G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
---------- ---------- ---------- ---------- ----------
00         A          0001               60
00         A          0002               59
00         A          0003               61
01         B          0101               80
01         B          0102               90
02         C          0201              100

6 rows selected.

SQL> select a.g2_id, g2_name, member, score, score2
  2  , avg   
  3  from t2 a,
  4  (select g2_id, avg(score) avg from t2 group by g2_id)
  5  b                   
  6  where a.g2_id = b.g2_id;

G2_ID      G2_NAME    MEMBER          SCORE     SCORE2        AVG
---------- ---------- ---------- ---------- ---------- ----------
00         A          0001               60                    60
00         A          0002               59                    60
00         A          0003               61                    60
01         B          0101               80                    85
01         B          0102               90                    85
02         C          0201              100                   100

6 rows selected.

============================
找到按g2_id分组之后，每组中的最大值的记录：
SQL> r
  1  select a.g2_id, g2_name, member, score
  2  , b.max_score
  3  from t2 a,
  4  (select g2_id, max(score) max_score from t2 group by g2_id) b
  5  where a.g2_id = b.g2_id
  6* and a.score = b.max_score

G2_ID      G2_NAME    MEMBER          SCORE  MAX_SCORE
---------- ---------- ---------- ---------- ----------
00         A          0003               61         61
01         B          0102               90         90
02         C          0201              100        100

====================
多行子句：
通过in操作符的多行子句查询
先通过分组找到分组中的最大值
再通过主句将子句查询到的结果作为条件
找到每个分组当中的最大值记录：
SQL> r
  1  select * from t2
  2  where score in
  3  (select max(score) from t2
  4* group by g2_id)

G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
---------- ---------- ---------- ---------- ----------
00         A          0003               61
01         B          0102               90
02         C          0201              100

====================
子句用以g2_id作为分组，求出分组的平均值
主句再用all < 找到小于返回数据最小值的记录：
SQL> r
  1  select * from t2
  2  where score < all
  3* (select avg(score) from t2 group by g2_id)

G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
---------- ---------- ---------- ---------- ----------
00         A          0002               59
子句得到以g2_id作为分组，求出分组score平均值
主句用any < any找到score小于最大数据的记录：
any < 可理解为小于任意一个，也就是小于最大值
哪怕其余的值都大于都满足条件，所以即为小于最大值
SQL> r
  1  select * from t2
  2  where score >  any
  3* (select avg(score) from t2 group by g2_id)

G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
---------- ---------- ---------- ---------- ----------
02         C          0201              100
01         B          0102               90
01         B          0101               80
00         A          0003               61

