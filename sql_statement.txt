=====================
order by 后可以填表达或者别名为排序条件，排序条件可以为任意表达式，可以与查询投影一致，也可以不一致，相互独立
SQL> select * from t2 where score > 60 and score < 80 order by score+10;

G2_ID   G2_NAME         MEMBER       SCORE
------- --------------- ------- ----------
001002  lianji          010201          65
001001  qianduan        010103          66
002001  qudao           020103          69
003001  shuju           030102          70
001001  qianduan        010102          72
003001  shuju           030101          75
001003  rizhong         010302          78
002001  qudao           020101          79

8 rows selected.
=====================
order by 后接别名，只要别名命名与当前命名是一致的即可，无论别名命名是否合理
SQL> select g2_id, score+20 as "score+5" from t2 order by "score+5";

G2_ID      score+5
------- ----------
001003          64
002002          74
001003          75
002001          76
001002          76
001002          76
001002          85
001001          86
002001          89
003001          90
001001          92

G2_ID      score+5
------- ----------
003001          95
001003          98
002001          99
001001         106
002001         108
002002         109

1
00_11_

20 rows selected.
====================
转义字符的定义与应用
SQL> select *from t2 where g2_id like '00\_11\_' escape '\';

G2_ID   G2_NAME         MEMBER       SCORE
------- --------------- ------- ----------
00_11_  escape

SQL> select * from t2 where g2_id like '00~_11~_' escape '~';

G2_ID   G2_NAME         MEMBER       SCORE
------- --------------- ------- ----------
00_11_  escape
===================
表达是及别名的运用
SQL> select g2_id, (score + 50)/1.2 "fix" from t2;

G2_ID          fix
------- ----------

001001  101.666667
001001  96.6666667
001002  95.8333333
001001  113.333333
001002  88.3333333
001002  88.3333333
001003  78.3333333
001003  106.666667
001003        87.5
002001       107.5

G2_ID          fix
------- ----------
002001  88.3333333
002001  99.1666667
002001         115
002002  86.6666667
002002  115.833333
003001  104.166667
003001         100
1
00_11_

20 rows selected.
=======================
按列号排序
SQL> select g2_id, score from t2 order by 2;

G2_ID        SCORE
------- ----------
001003          44
002002          54
001003          55
002001          56
001002          56
001002          56
001002          65
001001          66
002001          69
003001          70
001001          72
======================
多列多样式（分别升序或降序）排序
SQL> select score, g2_name from t2 order by g2_name, score desc;

     SCORE G2_NAME
---------- ---------------
           escape
        89 file
        54 file
        65 lianji
        56 lianji
        56 lianji
        86 qianduan
        72 qianduan
        66 qianduan
        88 qudao
        79 qudao
==========================
设置显示宽度
SQL> set linesize 80;
或
SQL> set line 80;
==============================
l（list）和行号 替换内容编辑历史命令
/(run)命令继续执行
SQL> select *  
  2  from t2
  3  where g1_id = '002001';
where g1_id = '002001'
      *
ERROR at line 3:
ORA-00904: "G1_ID": invalid identifier


SQL> 3 where g2_id = '002001';
SQL> l  
  1  select *
  2  from t2
  3* where g2_id = '002001'
SQL> /

G2_ID   G2_NAME         MEMBER       SCORE
------- --------------- ------- ----------
002001  qudao           020101          79
002001  qudao           020102          56
002001  qudao           020103          69
002001  qudao           020104          88
===============
a[ppend]追加命令
SQL> select g2_id
  2  from t2;

G2_ID
-------

001001
001001
001002
001001
001002
001002
001003
001003
001003
002001

G2_ID
-------
002001
002001
002001
002002
002002
003001
003001
1
00_11_

20 rows selected.

SQL> l
  1  select g2_id
  2* from t2
SQL> 1
  1* select g2_id
SQL> a , g2_name
  1* select g2_id, g2_name
SQL> /

G2_ID   G2_NAME
------- ---------------
        ???
001001  qianduan
001001  qianduan
001002  lianji
001001  qianduan
001002  lianji
001002  lianji
001003  rizhong
001003  rizhong
001003  rizhong
002001  qudao

G2_ID   G2_NAME
------- ---------------
002001  qudao
002001  qudao
002001  qudao
002002  file
002002  file
003001  shuju
003001  shuju
1       ???
00_11_  escape

20 rows selected.

===============
运行命令 / 或 r[un]
r回显执行命令的内容
/不回显执行命令内容
SQL> r   
  1  select *
  2* from t1

     G1_ID G1_NAME
---------- ----------
         0 a
         1 b

SQL> /

     G1_ID G1_NAME
---------- ----------
         0 a
         1 b
===============
在最前加一行及删除指定行
SQL> 0 add
SQL> l
  1  add
  2  select g2_id, g2_name
  3* from t2
SQL> del 1
SQL> l
  1  select g2_id, g2_name
  2* from t2
==================
删除一段内容
SQL> l
  1  select *
  2  from t1
  3  where g1_id = '0'
  4* and g1_name = 'a'
SQL> del 3 4
SQL> l
  1  select *
  2* from t1
SQL> 
===================
c[hange]命令，替换行当中的内容
SQL> l  
  1  select g1_id
  2* from t1
SQL> 1 
  1* select g1_id
SQL> c /g1_id/g1_name
  1* select g1_name
SQL> l  
  1  select g1_name
  2* from t1
SQL> /  

G1_NAME
----------
a
b
====================
c命令删除一段内容方法
SQL> l
  1  select g1_id, g1_name
  2* from t1
SQL> /  

     G1_ID G1_NAME
---------- ----------
         0 a
         1 b

SQL> 1
  1* select g1_id, g1_name
SQL> c /g1_id,/
  1* select  g1_name
SQL> /  

G1_NAME
----------
a
b

SQL> l
  1  select  g1_name
  2* from t1
======================
将缓存区中的内容保存成脚本：
SQL> l   
  1  select g1_id
  2* from t1
SQL> save save  
Created file save.sql
查看脚本内容：
$ cat save.sql 
select g1_id
from t1
/
====================
将脚本文件读入缓存区
SQL> get save.sql
  1  select g1_id
  2* from t1
SQL> l  
  1  select g1_id
  2* from t1
SQL> /

     G1_ID
----------
         0
         1
====================
直接运行脚本
SQL> @ save.sql

     G1_ID
----------
         0
         1

SQL> @save

     G1_ID
----------
         0
         1
=========================
将屏幕执行结果记录在文件中：
SQL> spool output
SQL> /  

     G1_ID
----------
         0
         1

SQL> spool off /* 执行后关闭导出 */
查看执行结果文件：
$ cat output.lst 
SQL> /

     G1_ID                                                                      
----------                                                                      
         0                                                                      
         1                                                                      

SQL> spool off
========================
单行函数：
转成小写lower
SQL> r
  1* select Lower('ThIs is lower') from dual

LOWER('THISIS
-------------
this is lower
==========================
转成大写：
SQL> select upper('Sql Is Used Exclusively In Rdbmses')   
  2  from dual;

UPPER('SQLISUSEDEXCLUSIVELYINRDBMS
----------------------------------
SQL IS USED EXCLUSIVELY IN RDBMSES
=====================
将所有单词格式化成首字母大写，其他字母小写
SQL> select initcap('SQL is an english like language')
  2  from dual;

INITCAP('SQLISANENGLISHLIKELANG
-------------------------------
Sql Is An English Like Language
===============================
连接字符串函数：
下面是嵌套两个函数的效果
SQL> r
  1  select concat('Top', concat('Mid', 'Tail'))
  2* from dual

CONCAT('TO
----------
TopMidTail
==================================
substr(str, m[,n])
返回一个字符串的子串
本函数为变参函数，最后一个参数填入，则返回填入的长度，如果不填入，则返回从n开始所有str所有的剩余部分
SQL> r     
  1  select substr('12345 67890', 2)
  2* from dual

SUBSTR('12
----------
2345 67890

SQL> 1  
  1* select substr('12345 67890', 2)
SQL> c /, 2)/, 2, 3)
  1* select substr('12345 67890', 2, 3)
SQL> r
  1  select substr('12345 67890', 2, 3)
  2* from dual

SUB
---
234
==============================
返回字符串的长度
SQL> select length('123456')
  2  from dual;

LENGTH('123456')
----------------
               6
=============================
返回字串的位置：
instr(列名|表达式, str, [m], [n])
instr（'源字符串' , '目标字符串' ,'开始位置','第几次出现'）
区分大小写
其中sourceString代表源字符串；
destString代表要从源字符串中查找的子串；
start代表查找的开始位置，这个参数可选的，默认为1；
appearPosition代表想从源字符中查找出第几次出现的destString，这个参数也是可选的，
默认为1
如果start的值为负数，则代表从右往左进行查找，但是位置数据仍然从左向右计算。
返回值为：查找到的字符串的位置。
-------------------------------------------------------------

对于instr函数，我们经常这样使用：从一个字符串中查找指定子串的位置。例如：

SQL> select instr('abcdefgh','de') position from dual;


POSITION
----------
   4
从1开始算 d排第四所以返回4

SQL>select instr('abcdefghbc','bc',3) position from dual;

POSITION
----------
  9
从第3个字符开始算起 第3个字符是c，所以从3开始以后的字符串找查找bc,返回9

---------------------------
从第1个字符开始，查找第2次出现子串的位置
SQL> select instr('qinyinglianqin','qin', 1, 2) position from dual;
POSITION
----------
  12 
===================
从字符串两端去掉一个指定字符
SQL> r  
  1  select trim ('h' from  'headh') "Trim"
  2* from dual

Tri
---
ead

SQL> select trim(leading 'h' from 'headh') "Trim"
  2  from dual;

Trim
----
eadh

SQL> select trim(trailing 'h' from 'headh') "Trim"
  2  from dual;

Trim
----
head
两端多个连续的字符，都递归的去掉
SQL> select trim('h' from 'hheadhh')   
  2  from dual;

TRI
---
ead
===========================
替换函数
SQL> r
  1  select replace('123456','34', 'ab')
  2* from dual

REPLAC
------
12ab56
========================================
round四舍五入函数
trunc截断函数
SQL> r
  1  select round(168.888, 1), trunc(168.888, 1), round(168.999, 1)
  2* from dual

ROUND(168.888,1) TRUNC(168.888,1) ROUND(168.999,1)
---------------- ---------------- ----------------
           168.9            168.8              169
第三列当百分位向十分位进位之后，0.9变成了1.0，直接只显示整数，小数点后因为是零直接不显示了

精确到个位的处理如以下两种方式表达：
SQL> r
  1  select round(168.888, 0),trunc(168.888, 0)
  2* from dual

ROUND(168.888,0) TRUNC(168.888,0)
---------------- ----------------
             169              168

SQL> select round(168.888), trunc(168.888, 0)
  2  from dual;

ROUND(168.888) TRUNC(168.888,0)
-------------- ----------------
           169              168
可以写0位，或是直接忽略不写

四舍五入到10位：
SQL> select round(168.888, -1), trunc(168.888, -1)
  2  from dual;

ROUND(168.888,-1) TRUNC(168.888,-1)
----------------- -----------------
              170               160
=============================
求余：mod
SQL> select mod(1900, 400)   
  2  from dual;

MOD(1900,400)
-------------
          300
=================================
显示系统时间：
SQL> select sysdate from dual;

SYSDATE
---------
12-DEC-16
日期数据计算：
将当前系统日期减掉一天
SQL> select sysdate - 1    
  2  from dual;

SYSDATE-1
---------
11-DEC-16
日期字符串和日期进行计算：
SQL> select to_date('15-jul-12') - sysdate
  2  from dual;

TO_DATE('15-JUL-12')-SYSDATE
----------------------------
                  -1611.6491
系统日期与小时进行计算：
SQL> select sysdate - 22/24
  2  from dual;

SYSDATE-2
---------
11-DEC-16
SQL> r
  1  select sysdate+ 22/24
  2* from dual

SYSDATE+2
---------
13-DEC-16
==========================
返回两个日期之间的月份：
SQL> select months_between('01-jul-99', '01-jul-98')
  2  from dual;

MONTHS_BETWEEN('01-JUL-99','01-JUL-98')
---------------------------------------
                                     12
=============================
将一个日期加上或减去某一个整月：
SQL> select add_months('01-jul-99', 1)
  2  from dual;

ADD_MONTH
---------
01-AUG-99

SQL> 1  
  1* select add_months('01-jul-99', 1)
SQL> c /, 1/, -1 
  1* select add_months('01-jul-99', -1)
SQL> r
  1  select add_months('01-jul-99', -1)
  2* from dual

ADD_MONTH
---------
01-JUN-99
========================
返回一个日期之后的第一个星期几的日期：
SQL> select next_day('10-may-02', 'monday')
  2  from dual;

NEXT_DAY(
---------
13-MAY-02
===========================
返回当前日期所在月份的最后一天：
SQL> r
  1  select last_day('08-feb-02')
  2* from dual

LAST_DAY(
---------
28-FEB-02
按月份四舍五入之后该日期为以下日期：
SQL> select round(to_date('28-oct-01'), 'month')
  2  from dual;

ROUND(TO_
---------
01-NOV-01

==============================
日期按月份截断：
SQL> select trunc(to_date('28-oct-01'), 'month')
  2  from dual;

TRUNC(TO_
---------
01-OCT-01
=============================
日期按年截断：
SQL> select trunc(to_date('28-oct-01'), 'year')
  2  from dual;

TRUNC(TO_
---------
01-JAN-01
================================
建立月份值：
SQL> r  
  1  insert into e1
  2  (id, name, date1)
  3* values (1, 'b', '01-jul-01')

1 row created.
==================================
将月份转成固定格式字符串：
SQL> r
  1  select to_char(date1, 'DD/MM/YY'),to_char(date1, 'DAY/month/year')
  2* from e1

TO_CHAR( TO_CHAR(DATE1,'DAY/MONTH/YEAR')
--------
--------------------------------------------------------------------------------------------------
01/07/01 SUNDAY   /july     /two thousand one
=================================
SQL> r
  1  select to_char(date1, 'dd/mm/yy'), to_char(date1, 'day month year')
  2* from e1

TO_CHAR( TO_CHAR(DATE1,'DAYMONTHYEAR')
--------
--------------------------------------------------------------------------------------------------
01/07/01 sunday    july      two thousand one


===============================
SQL> r
  1  select to_char(date1, 'fmddspth "of" month year fmHH:MI:ss am')
  2* from e1

TO_CHAR(DATE1,'FMDDSPTH"OF"MONTHYEARFMHH:MI:SSAM')
----------------------------------------------------------------------------------------------------
first of july two thousand one 12:00:00 am

===================================
以金额的固定格式显示数字
SQL> select to_char(score*12,  '$99,999.00') money   
  2  from t2;

MONEY
-----------

    $864.00
    $792.00
    $780.00
  $1,032.00
    $672.00
==================================
分支判断执行函数：
以下语句表示，当member为020102，020103和020104时，分别decode函数的返回值分别是
将score乘以2，3，4，当member不是上述三个值时，则直接返回score
SQL> select member, decode(member, '020102', score*2
  2  ,'020103', score*3
  3  ,'020104', score*4
  4  , score)   
  5  "new_score"
  6  from t2;

MEMBER   new_score
------- ----------

010102          72
010103          66
010201          65
010101          86
010202          56
010202          56
010301          44
010302          78
010303          55
020101          79

MEMBER   new_score
------- ----------
020102         112
020103         207
020104         352
020201          54
020202          89
030101          75
030102          70


40101

21 rows selected.
=============================
函数嵌套并使用别名排序：
SQL> r
  1  select member, nvl(to_char(score), '0') "new_score"
  2  from t2
  3  where member is not null
  4* order by "new_score"

MEMBER  new_score
------- ----------------------------------------
40101   0
010301  44
020201  54
010303  55
020102  56
010202  56
010202  56
010201  65
010103  66
020103  69
030102  70

MEMBER  new_score
------- ----------------------------------------
010102  72
030101  75
010302  78
020101  79
010101  86
020104  88
020202  89

18 rows selected.

===========================
NVL2用法：
SQL> r   
  1  select nvl2(member, to_char(score + 100), '00') "score_new"
  2* from t2
表达式1不为空，则返回表达式2，否则返回表达式3，函数的返回值是表达2的类型
score_new
----------------------------------------
00
172
166
165
186
156
156
144
178
155
179

score_new
----------------------------------------
156
169
188
154
189
175
170
00
00


21 rows selected.
============================
检查两个值是否相等：不相等返回表达式1的值，相等则返回null
SQL> select * from t2;

G2_ID   G2_NAME         MEMBER       SCORE     SCORE2
------- --------------- ------- ---------- ----------
        ???                                        56
001001  qianduan        010102          72         56
001001  qianduan        010103          66         56
001002  lianji          010201          65         56
001001  qianduan        010101          86         56
001002  lianji          010202          56         56
001002  lianji          010202          56         56
001003  rizhong         010301          44         56
001003  rizhong         010302          78         56
001003  rizhong         010303          55         56
002001  qudao           020101          79         56

G2_ID   G2_NAME         MEMBER       SCORE     SCORE2
------- --------------- ------- ---------- ----------
002001  qudao           020102          56         56
002001  qudao           020103          69         56
002001  qudao           020104          88         56
002002  file            020201          54         56
002002  file            020202          89         56
003001  shuju           030101          75         56
003001  shuju           030102          70         56
1       ???                                        56
00_11_  escape                                     56
004001  Linshi          40101                      56

21 rows selected.

SQL> select nullif(score, score2)
  2  from t2;

NULLIF(SCORE,SCORE2)
--------------------

                  72
                  66
                  65
                  86


                  44
                  78
                  55
                  79

NULLIF(SCORE,SCORE2)
--------------------

                  69
                  88
                  54
                  89
                  75
                  70




21 rows selected.
============================
利用nvl2函数和nullif函数判断两列是否相等的结果：
SQL> r       
  1  select nvl2(nullif(score, score2), 'is not null', 'is null')
  2* from t2

NVL2(NULLIF
-----------
is null
is not null
is not null
is not null
is not null
is null
is null
is not null
is not null
is not null
is not null

NVL2(NULLIF
-----------
is null
is not null
is not null
is not null
is not null
is not null
is not null
is null
is null
is null

21 rows selected.
========================
返回直到不为空表达式函数：
SQL> select * from e3;

STR1  STR2  STR3  STR4
----- ----- ----- -----
11
21    22
31    32    33
41    42    43    44

SQL> select coalesce(str4, str3, str2, str1) 
  2  from e3;

COALE
-----
11
22
33
44
=================================
综合数据和分组函数：
SQL> select * from e3;

STR1  STR2  STR3  STR4
----- ----- ----- -----
11
21    22
31    32    33
41    42    43    44

SQL> select count(str1), count(str2), count(str3), count(str4)
  2  from e3;

COUNT(STR1) COUNT(STR2) COUNT(STR3) COUNT(STR4)
----------- ----------- ----------- -----------
          4           3           2           1
===================================
求和函数和求平均值函数：
SQL> select * from t2;

G2_ID   G2_NAME         MEMBER       SCORE     SCORE2
------- --------------- ------- ---------- ----------
        ???                                        56
001001  qianduan        010102          72         56
001001  qianduan        010103          66         56
001002  lianji          010201          65         56
001001  qianduan        010101          86         56
001002  lianji          010202          56         56
001002  lianji          010202          56         56
001003  rizhong         010301          44         56
001003  rizhong         010302          78         56
001003  rizhong         010303          55         56
002001  qudao           020101          79         56

G2_ID   G2_NAME         MEMBER       SCORE     SCORE2
------- --------------- ------- ---------- ----------
002001  qudao           020102          56         56
002001  qudao           020103          69         56
002001  qudao           020104          88         56
002002  file            020201          54         56
002002  file            020202          89         56
003001  shuju           030101          75         56
003001  shuju           030102          70         56
1       ???                                        56
00_11_  escape                                     56
004001  Linshi          40101                      56

SQL> r  
  1  select avg(score) avg, sum(score) sum, count(score) count,
  2  avg(score2) avg2, sum(score2) sum2, count(score2) count2
  3* from t2

       AVG        SUM      COUNT       AVG2       SUM2     COUNT2
---------- ---------- ---------- ---------- ---------- ----------
68.1176471       1158         17         56       1176         21
=========================
最大和最小值得函数：
SQL> r  
  1  select min(score) min_score,
  2  min(score2) min_score2,
  3  max(score) max_score, max(score2) max_score2
  4* from t2

 MIN_SCORE MIN_SCORE2  MAX_SCORE MAX_SCORE2
---------- ---------- ---------- ----------
        44         56         89         56
=========================
求字符串的最大最小值：
SQL> select max(g2_name) max, 
  2  min(g2_name) min
  3  from t2;

MAX             MIN
--------------- ---------------
???             Linshi
============================
按g2_id分组计算成员数量：
SQL> select g2_id, count(member) from t2 group by g2_id;

G2_ID   COUNT(MEMBER)
------- -------------
                    0
002002              2
1                   0
004001              1
001001              3
001003              3
002001              4
003001              2
001002              3
00_11_              0

10 rows selected.
==========================
分组统计数量之后再排序：
SQL> r
  1  select g2_id,
  2  count(member) "count_member"
  3  from t2
  4  group by g2_id
  5* order by "count_member"

G2_ID   count_member
------- ------------
1                  0
00_11_             0
                   0
004001             1
003001             2
002002             2
001003             3
001001             3
001002             3
002001             4

10 rows selected.
===================
使用函数组名进行group by排序：
SQL> r
  1  select g2_id,
  2  count(member) "count_member"
  3  from t2
  4  group by g2_id
  5* order by count(member)

G2_ID   count_member
------- ------------
1                  0
00_11_             0
                   0
004001             1
003001             2
002002             2
001003             3
001001             3
001002             3
002001             4

10 rows selected.
======================
group by + having用法：
SQL> r
  1  select g2_id, avg(score) avg_score
  2  from t2
  3  group by g2_id
  4* having avg(score) > 60

G2_ID    AVG_SCORE
------- ----------
002002        71.5
001001  74.6666667
002001          73
003001        72.5
=====================
正常不加having的结果，60以下和空均显示出来了
SQL> r
  1  select g2_id, avg(score) avg_score
  2  from t2
  3* group by g2_id

G2_ID    AVG_SCORE
------- ----------

002002        71.5
1
004001
001001  74.6666667
001003          59
002001          73
003001        72.5
001002          59
00_11_

10 rows selected.
===================
通过分组函数计算平均值，筛选需要的分组函数结果，再排序：
SQL> r
  1  select g2_id, avg(score) avg_score
  2  from t2
  3  group by g2_id
  4  having avg(score) > 60
  5* order by avg(score)

G2_ID    AVG_SCORE
------- ----------
002002        71.5
003001        72.5
002001          73
001001  74.6666667
=========================
对数据去掉不想要的原始筛选(where)，再根据分组求均值(agv函数＋group by)，再去掉分组均值中不想要的(having)
SQL> r
  1  select g2_id, avg(score) avg_score
  2  from t2
  3  where g2_id not like '003%'
  4  group by g2_id
  5  having avg(score) > 60
  6* order by avg(score)

G2_ID    AVG_SCORE
------- ----------
002002        71.5
002001          73
001001  74.6666667
===============================
分组函数最多只能嵌套两层，并且不能显示其他映射字段，因为有可能根据排序得到的最小值不唯一：
SQL> r
  1  select min(avg(score)),
  2  max(avg(score))
  3  from t2
  4* group by g2_id

MIN(AVG(SCORE)) MAX(AVG(SCORE))
--------------- ---------------
             59      74.6666667
===============================
count函数统计的结果不包括空值：
SQL> r
  1  select avg(score), avg(score2),
  2  sum(score), count(score), sum(score)/count(score), count(score2),
count(nvl(score, 0)),sum(score)/count(nvl(score, 0)), sum(nvl(score,
0))/count(nvl(score, 0))
  3* from t2

AVG(SCORE) AVG(SCORE2) SUM(SCORE) COUNT(SCORE) SUM(SCORE)/COUNT(SCORE)
COUNT(SCORE2) COUNT(NVL(SCORE,0))
---------- ----------- ---------- ------------ -----------------------
------------- -------------------
SUM(SCORE)/COUNT(NVL(SCORE,0)) SUM(NVL(SCORE,0))/COUNT(NVL(SCORE,0))
------------------------------ -------------------------------------
68.1176471          56       1158           17              68.1176471 21                  21
                    55.1428571                            55.1428571


============================================
联合查询，有重名字段必须显示用指定表明对象的方法表示要显示的列名：
SQL> r 
  1  select g1_id, g1_name, t1.g2_id, t1.g2_name, member, score, score2
  2  from t1, t2
  3  where t1.g2_id = t2.g2_id
  4* order by t1.g2_id

G1_ID   G1_NAME         G2_ID   G2_NAME         MEMBER       SCORE     SCORE2
------- --------------- ------- --------------- ------- ---------- ----------
001     yf01            001001  qianduan        010103          66         56
001     yf01            001001  qianduan        010102          72         56
001     yf01            001001  qianduan        010101          86         56
001     yf01            001002  lianji          010201          65         56
001     yf01            001002  lianji          010202          56         56
001     yf01            001002  lianji          010202          56         56
001     yf01            001003  rizhong         010302          78         56
001     yf01            001003  rizhong         010301          44         56
001     yf01            001003  rizhong         010303          55         56
002     yf02            002001  qudao           020101          79         56
002     yf02            002001  qudao           020102          56         56

G1_ID   G1_NAME         G2_ID   G2_NAME         MEMBER       SCORE     SCORE2
------- --------------- ------- --------------- ------- ---------- ----------
002     yf02            002001  qudao           020103          69         56
002     yf02            002001  qudao           020104          88         56
002     yf02            002002  file            020201          54         56
002     yf02            002002  file            020202          89         56
003     yf03            003001  shuju           030101          75         56
003     yf03            003001  shuju           030102          70         56

17 rows selected.
===============================
带条件的连接
SQL> r
  1  select g1_id, g1_name, t1.g2_id, t1.g2_name, member, score, score2
  2  from t1, t2
  3  where t1.g2_id = t2.g2_id
  4* and t2.score >= 60

G1_ID   G1_NAME         G2_ID   G2_NAME         MEMBER       SCORE     SCORE2
------- --------------- ------- --------------- ------- ---------- ----------
001     yf01            001001  qianduan        010102          72         56
001     yf01            001001  qianduan        010103          66         56
001     yf01            001002  lianji          010201          65         56
001     yf01            001001  qianduan        010101          86         56
001     yf01            001003  rizhong         010302          78         56
002     yf02            002001  qudao           020101          79         56
002     yf02            002001  qudao           020103          69         56
002     yf02            002001  qudao           020104          88         56
002     yf02            002002  file            020202          89         56
003     yf03            003001  shuju           030101          75         56
003     yf03            003001  shuju           030102          70         56

11 rows selected.
===========================
代别名的联合连接查询：
SQL> select a.g1_id, a.g1_name, a.g2_id, a.g2_name, b.member, b.score,
b.score2
  2  from t1 a, t2 b
  3  where a.g2_id = b.g2_id
  4  and b.score >= 60;

G1_ID   G1_NAME         G2_ID   G2_NAME         MEMBER       SCORE     SCORE2
------- --------------- ------- --------------- ------- ---------- ----------
001     yf01            001001  qianduan        010102          72         56
001     yf01            001001  qianduan        010103          66         56
001     yf01            001002  lianji          010201          65         56
001     yf01            001001  qianduan        010101          86         56
001     yf01            001003  rizhong         010302          78         56
002     yf02            002001  qudao           020101          79         56
002     yf02            002001  qudao           020103          69         56
002     yf02            002001  qudao           020104          88         56
002     yf02            002002  file            020202          89         56
003     yf03            003001  shuju           030101          75         56
003     yf03            003001  shuju           030102          70         56

11 rows selected.
=====================================
自连接：
SQL> desc work;
 Name                                      Null?    Type
 ----------------------------------------- --------
----------------------------
 ID                                                 VARCHAR2(10)
 NAME                                               VARCHAR2(10)
 JOB                                                VARCHAR2(10)
 MONEY                                              NUMBER(10)
 MANAGE                                             VARCHAR2(10)

SQL> select * from work;

ID         NAME       JOB             MONEY MANAGE
---------- ---------- ---------- ---------- ----------
01         boss       boss            10000 boss
02         manage01   manage           5000 boss
03         normal01   normal           2000 manage
04         normal02   normal           1900 manage

SQL> r 
  1  select a.id, a.name, a.job, a.money, a.manage
  2  from work a, work b
  3  where a.job=b.manage
  4* and b.manage='manage'

ID         NAME       JOB             MONEY MANAGE
---------- ---------- ---------- ---------- ----------
02         manage01   manage           5000 boss
02         manage01   manage           5000 boss

==========================
用between为条件的不等连接:
SQL> select * from money_t;

        ID        LOW      HIGHT
---------- ---------- ----------
         0       1000       2000

SQL> r
  1  select w.id, w.name, w.money, w.job
  2  from work w, money_t m
  3* where w.money between m.low and m.hight

ID         NAME            MONEY JOB
---------- ---------- ---------- ----------
03         normal01         2000 normal
04         normal02         1900 normal

=======================
外连接：
联合两张表当中相等的部分之外
a.name(+)=b.name表示，将a表中没有的，而b表中有的字段也显示出来
投影字段中表a没有的字段则显示为空
将＋放在数据少的那一边
SQL> select * from t2;

G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
---------- ---------- ---------- ---------- ----------
00         A          0001               60
00         A          0002               59
00         A          0003               61
01         B          0101               80
01         B          0102               90
02         C          0201              100

6 rows selected.

SQL> select * from t1;

G1_ID G1_NAME    G2_ID      G2_NAME
----- ---------- ---------- ----------
0     a          00         A
1     b          01         B

SQL> r
  1  select g1_id, g1_name, t1.g2_id, t1.g2_name
  2  , member, score, score2
  3  from t1, t2
  4* where t1.g2_id(+) = t2.g2_id

G1_ID G1_NAME    G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
----- ---------- ---------- ---------- ---------- ---------- ----------
0     a          00         A          0003               61
0     a          00         A          0002               59
0     a          00         A          0001               60
1     b          01         B          0102               90
1     b          01         B          0101               80
                                       0201              100

6 rows selected.

====================================
两张表的笛卡尔积连接，oracle方法和1999标准sql语法：
SQL> r
  1  select g1_id, g1_name, t1.g2_id, t1.g2_name
  2  , member, score, score2
  3  from t1
  4* cross join t2

G1_ID G1_NAME    G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
----- ---------- ---------- ---------- ---------- ---------- ----------
0     a          00         A          0001               60
0     a          00         A          0002               59
0     a          00         A          0003               61
0     a          00         A          0101               80
0     a          00         A          0102               90
0     a          00         A          0201              100
1     b          01         B          0001               60
1     b          01         B          0002               59
1     b          01         B          0003               61
1     b          01         B          0101               80
1     b          01         B          0102               90

G1_ID G1_NAME    G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
----- ---------- ---------- ---------- ---------- ---------- ----------
1     b          01         B          0201              100

12 rows selected.

SQL> r
  1  select g1_id, g1_name, t1.g2_id, t1.g2_name
  2  , member, score, score2
  3* from t1, t2

G1_ID G1_NAME    G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
----- ---------- ---------- ---------- ---------- ---------- ----------
0     a          00         A          0001               60
0     a          00         A          0002               59
0     a          00         A          0003               61
0     a          00         A          0101               80
0     a          00         A          0102               90
0     a          00         A          0201              100
1     b          01         B          0001               60
1     b          01         B          0002               59
1     b          01         B          0003               61
1     b          01         B          0101               80
1     b          01         B          0102               90

G1_ID G1_NAME    G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
----- ---------- ---------- ---------- ---------- ---------- ----------
1     b          01         B          0201              100

12 rows selected.
=======================
使用using的联合等同于相等连接查询：

表样例：
SQL> select * from t1;

G1_ID G1_NAME    G2_ID      G2_NAME
----- ---------- ---------- ----------
0     a          00         A
1     b          01         B
1+    b+         01         B+

SQL> select * from t2;

G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
---------- ---------- ---------- ---------- ----------
00         A          0001               60
00         A          0002               59
00         A          0003               61
01         B          0101               80
01         B          0102               90
02         C          0201              100

6 rows selected.

相等连接：
SQL> select g1_id, g1_name, t1.g2_id, t1.g2_name
  2  , member, score, score2
  3  from t1, t2
  4  where t1.g2_id = t2.g2_id;

G1_ID G1_NAME    G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
----- ---------- ---------- ---------- ---------- ---------- ----------
0     a          00         A          0001               60
0     a          00         A          0002               59
0     a          00         A          0003               61
1+    b+         01         B+         0101               80
1     b          01         B          0101               80
1+    b+         01         B+         0102               90
1     b          01         B          0102               90

7 rows selected.

使用using
SQL> r
  1  select g1_id, g1_name, g2_id, t1.g2_name
  2  , member, score, score2
  3  from t1
  4  join t2
  5  using(g2_id)
  6*

G1_ID G1_NAME    G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
----- ---------- ---------- ---------- ---------- ---------- ----------
0     a          00         A          0001               60
0     a          00         A          0002               59
0     a          00         A          0003               61
1+    b+         01         B+         0101               80
1     b          01         B          0101               80
1+    b+         01         B+         0102               90
1     b          01         B          0102               90

7 rows selected.


==========================
以上t1和t2不变，on语句用法：
SQL> select t1.g1_id, t1.g1_name, t1.g2_id, t1.g2_name
  2  , t2.member, t2.score, t2.score2
  3  from t1 
  4  join t2
  5  on (t1.g2_id = t2.g2_id);

G1_ID G1_NAME    G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
----- ---------- ---------- ---------- ---------- ---------- ----------
0     a          00         A          0001               60
0     a          00         A          0002               59
0     a          00         A          0003               61
1+    b+         01         B+         0101               80
1     b          01         B          0101               80
1+    b+         01         B+         0102               90
1     b          01         B          0102               90

7 rows selected.
==========================
on语句不带表明：
SQL> r
  1  select g1_id, g1_name, t1.g2_id, t1.g2_name,
  2  member, score, score2
  3  from t1
  4  join t2
  5  on(t1.g2_id = t2.g2_id)
  6*

G1_ID G1_NAME    G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
----- ---------- ---------- ---------- ---------- ---------- ----------
0     a          00         A          0001               60
0     a          00         A          0002               59
0     a          00         A          0003               61
1+    b+         01         B+         0101               80
1     b          01         B          0101               80
1+    b+         01         B+         0102               90
1     b          01         B          0102               90

7 rows selected.
===========================
多表连接和附加条件：
SQL> select * from t1;

G1_ID G1_NAME    G2_ID      G2_NAME
----- ---------- ---------- ----------
0     a          00         A
1     b          01         B
1+    b+         01         B+

SQL> select * from t2;

G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
---------- ---------- ---------- ---------- ----------
00         A          0001               60
00         A          0002               59
00         A          0003               61
01         B          0101               80
01         B          0102               90
02         C          0201              100

6 rows selected.

SQL> select * from t3;

ID   NAME       JOB        MANAGE
---- ---------- ---------- ----------
00   0001       boss       boss
01   0002       manage     boss
02   0003       normal     manage

SQL> r
  1  select g1_id, g1_name, t2.g2_id, t2.g2_name
  2  , member, score, score2, name, job, manage
  3  from t1
  4  join t2
  5  on t1.g2_id = t2.g2_id
  6  join t3
  7* on t2.member = t3.name

G1_ID G1_NAME    G2_ID      G2_NAME    MEMBER          SCORE     SCORE2 NAME JOB        MANAGE
----- ---------- ---------- ---------- ---------- ---------- ---------- ---------- ---------- ----------
0     a          00         A          0001               60            0001 boss       boss
0     a          00         A          0002               59            0002 manage     boss
0     a          00         A          0003               61            0003 normal     manage
=========================
相等连接，左连接和右连接：
相等：
SQL> r
  1  select g1_id, g1_name, t1.g2_id, t1.g2_name
  2  , member, score, score2
  3  from t1
  4  join t2
  5* on t1.g2_id = t2.g2_id

G1_ID G1_NAME    G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
----- ---------- ---------- ---------- ---------- ---------- ----------
0     a          00         A          0001               60
0     a          00         A          0002               59
0     a          00         A          0003               61
1+    b+         01         B+         0101               80
1     b          01         B          0101               80
1+    b+         01         B+         0102               90
1     b          01         B          0102               90
左连接和右连接：
SQL> r
  1  select g1_id, g1_name, t1.g2_id, t1.g2_name
  2  , member, score, score2
  3  from t1
  4  left outer join t2
  5* on t1.g2_id = t2.g2_id

G1_ID G1_NAME    G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
----- ---------- ---------- ---------- ---------- ---------- ----------
0     a          00         A          0001               60
0     a          00         A          0002               59
0     a          00         A          0003               61
1+    b+         01         B+         0101               80
1     b          01         B          0101               80
1+    b+         01         B+         0102               90
1     b          01         B          0102               90
3     d          03         D

8 rows selected.

SQL> 4    
  4* left outer join t2
SQL> c /left/right
  4* right outer join t2
SQL> r
  1  select g1_id, g1_name, t1.g2_id, t1.g2_name
  2  , member, score, score2
  3  from t1
  4  right outer join t2
  5* on t1.g2_id = t2.g2_id

G1_ID G1_NAME    G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
----- ---------- ---------- ---------- ---------- ---------- ----------
0     a          00         A          0003               61
0     a          00         A          0002               59
0     a          00         A          0001               60
1     b          01         B          0102               90
1     b          01         B          0101               80
1+    b+         01         B+         0102               90
1+    b+         01         B+         0101               80
                                       0201              100

8 rows selected.
====================
全连接：
SQL> c /right/full
  4* full outer join t2
SQL> r
  1  select g1_id, g1_name, t1.g2_id, t1.g2_name
  2  , member, score, score2
  3  from t1
  4  full outer join t2
  5* on t1.g2_id = t2.g2_id

G1_ID G1_NAME    G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
----- ---------- ---------- ---------- ---------- ---------- ----------
0     a          00         A          0001               60
0     a          00         A          0002               59
0     a          00         A          0003               61
1+    b+         01         B+         0101               80
1     b          01         B          0101               80
1+    b+         01         B+         0102               90
1     b          01         B          0102               90
                                       0201              100
3     d          03         D

9 rows selected.
=================================
子句查询：

SQL> select * from t2;

G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
---------- ---------- ---------- ---------- ----------
00         A          0001               60
00         A          0002               59
00         A          0003               61
01         B          0101               80
01         B          0102               90
02         C          0201              100

6 rows selected.
上述表查询成员0002同组名而且成绩大于成员0001的记录
SQL> r
  1  select * from t2
  2  where g2_id = (
  3  select g2_id from t2 where member = '0002')
  4  and score > (
  5* select score from t2 where member = '0001')

G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
---------- ---------- ---------- ---------- ----------
00         A          0003               61

显示成绩在平均成绩以下的记录：
SQL> select * from t2
  2  where score < ( 
  3  select avg(score) from t2);

G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
---------- ---------- ---------- ---------- ----------
00         A          0001               60
00         A          0002               59
00         A          0003               61

=============================
having子句中的单行子查询：
显示按g2_id分组平均中大于最小平均值的分组：
SQL> r  
  1  select min(score), max(score), avg(score), g2_id
  2  from t2
  3  group by g2_id
  4  having avg(score) >
  5  (select min(avg(score))
  6     from t2
  7*    group by g2_id)

MIN(SCORE) MAX(SCORE) AVG(SCORE) G2_ID
---------- ---------- ---------- ----------
        80         90         85 01
       100        100        100 02
=================================
from子句中单行子句用法：
先得到按g2_id分组的平均值
再按g2_id和表中score成绩进行比较，得到大于平均值的记录：
SQL> r
  1  select a.g2_id, g2_name, member, score, score2
  2  , avg
  3  from t2 a,
  4  (select g2_id, avg(score) avg from t2 group by g2_id) b
  5  where a.g2_id = b.g2_id
  6* and a.score > b.avg

G2_ID      G2_NAME    MEMBER          SCORE     SCORE2        AVG
---------- ---------- ---------- ---------- ---------- ----------
00         A          0003               61                    60
01         B          0102               90                    85

原始数据和未加限定条件大于平均值时情况如下：
SQL> select * from t2;

G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
---------- ---------- ---------- ---------- ----------
00         A          0001               60
00         A          0002               59
00         A          0003               61
01         B          0101               80
01         B          0102               90
02         C          0201              100

6 rows selected.

SQL> select a.g2_id, g2_name, member, score, score2
  2  , avg   
  3  from t2 a,
  4  (select g2_id, avg(score) avg from t2 group by g2_id)
  5  b                   
  6  where a.g2_id = b.g2_id;

G2_ID      G2_NAME    MEMBER          SCORE     SCORE2        AVG
---------- ---------- ---------- ---------- ---------- ----------
00         A          0001               60                    60
00         A          0002               59                    60
00         A          0003               61                    60
01         B          0101               80                    85
01         B          0102               90                    85
02         C          0201              100                   100

6 rows selected.

============================
找到按g2_id分组之后，每组中的最大值的记录：
SQL> r
  1  select a.g2_id, g2_name, member, score
  2  , b.max_score
  3  from t2 a,
  4  (select g2_id, max(score) max_score from t2 group by g2_id) b
  5  where a.g2_id = b.g2_id
  6* and a.score = b.max_score

G2_ID      G2_NAME    MEMBER          SCORE  MAX_SCORE
---------- ---------- ---------- ---------- ----------
00         A          0003               61         61
01         B          0102               90         90
02         C          0201              100        100

====================
多行子句：
通过in操作符的多行子句查询
先通过分组找到分组中的最大值
再通过主句将子句查询到的结果作为条件
找到每个分组当中的最大值记录：
SQL> r
  1  select * from t2
  2  where score in
  3  (select max(score) from t2
  4* group by g2_id)

G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
---------- ---------- ---------- ---------- ----------
00         A          0003               61
01         B          0102               90
02         C          0201              100

====================
子句用以g2_id作为分组，求出分组的平均值
主句再用all < 找到小于返回数据最小值的记录：
SQL> r
  1  select * from t2
  2  where score < all
  3* (select avg(score) from t2 group by g2_id)

G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
---------- ---------- ---------- ---------- ----------
00         A          0002               59
子句得到以g2_id作为分组，求出分组score平均值
主句用any < any找到score小于最大数据的记录：
any < 可理解为小于任意一个，也就是小于最大值
哪怕其余的值都大于都满足条件，所以即为小于最大值
SQL> r
  1  select * from t2
  2  where score >  any
  3* (select avg(score) from t2 group by g2_id)

G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
---------- ---------- ---------- ---------- ----------
02         C          0201              100
01         B          0102               90
01         B          0101               80
00         A          0003               61
==================
多列查询in：
子句按g2_id分组查score最大值和显示g2_id
主句按查到的g2_id和score最大值找所有记录：
子句显示结果如下
成对匹配：
SQL> r
  1* select g2_id, max(score) from t2 group by g2_id

G2_ID      MAX(SCORE)
---------- ----------
00                 61
01                 90
02                100

主句和子句组合之后如下
SQL> select * from t2 where (g2_id, score) in
  2  (select g2_id, max(score) from t2 group by g2_id);

G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
---------- ---------- ---------- ---------- ----------
00         A          0003               61
01         B          0102               90
02         C          0201              100
非成对匹配：
比成对匹配多了一条记录，因为g2_id和最大成绩是分别匹配的
两个集合中任意组合，而成对匹配是两个条件组合已经确定
SQL> select * from t2 where g2_id in (select distinct g2_id from t2)
  2  and score in (select max(score) from t2 group by g2_id);

G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
---------- ---------- ---------- ---------- ----------
01         B          0103               61
00         A          0003               61
01         B          0102               90
02         C          0201              100
=====================
当显示的记录超过一定行数时，则提示行数的数量：
默认6行
SQL> show feedback
FEEDBACK ON for 6 or more rows
改变行数显示设置：
SQL> set feedback 5 
SQL> r  
  1* select  * from t1 where g2_name is not null and g2_name != 'shuju'

G1_ID   G1_NAME         G2_ID   G2_NAME
------- --------------- ------- ---------------
001     yf01            001001  qianduan
001     yf01            001002  lianji
001     yf01            001003  rizhong
002     yf02            002001  qudao
002     yf02            002002  file

5 rows selected.
SQL> show feedback
FEEDBACK ON for 5 or more rows
==============================
SQL> column member clear 
SQL> column member
SP2-0046: COLUMN 'member' not defined
SQL> column heading member member1
SP2-0158: unknown COLUMN option "member"
SQL> column member heading member_1 for a9
SQL> column member
COLUMN   member ON
HEADING  'member_1'
FORMAT   a9
SQL> select * from t2;

G2_ID   G2_NAME         member_1       SCORE     SCORE2
------- --------------- --------- ---------- ----------
        ???                                          56
001001  qianduan        010102            72         56
001001  qianduan        010103            66         56
001002  lianji          010201            65         56
001001  qianduan        010101            86         56
001002  lianji          010202            56         56
001002  lianji          010202            56         56
001003  rizhong         010301            44         56
001003  rizhong         010302            78         56
001003  rizhong         010303            55         56
002001  qudao           020101            79         56

=========================
数字格式：
QL> column score for $999.99
SQL> select * from t2;

G2_ID   G2_NAME         member_1     SCORE     SCORE2
------- --------------- --------- -------- ----------
        ???                                        56
001001  qianduan        010102      $72.00         56
001001  qianduan        010103      $66.00         56

SQL> column score for $000,000.00
SQL> select * from t2;

G2_ID   G2_NAME         member_1         SCORE     SCORE2
------- --------------- --------- ------------ ----------
        ???                                            56
001001  qianduan        010102     $000,072.00         56
001001  qianduan        010103     $000,066.00         56
001002  lianji          010201     $000,065.00         56

本地化货币命令：
SQL> column score for L999,999.99
SQL> select * from t2;

G2_ID   G2_NAME         member_1                  SCORE     SCORE2
------- --------------- --------- --------------------- ----------
        ???                                                     56
001001  qianduan        010102                   $72.00         56
001001  qianduan        010103                   $66.00         56
001002  lianji          010201                   $65.00         56

====================
查询本用户名下所有的表：
SQL> l
  1  select table_name from user_tables
查看当前用户名有哪些可以操作的表：
SQL> l  
  1* select table_name from all_tables where owner not like '%sys'
查看当前用户所有表和属性：
SQL> l
  1  select * from user_catalog
catalog的别名查询办法：
SQL> l
  1  select * from cat
=========================
以下为数据库管理员应当关心内容：
以system数据库管理员登录数据，查看数据库的版本，创建时间和运行模式
SQL> r
  1  select name, created, log_mode
  2* from v$database

NAME      CREATED   LOG_MODE
--------- --------- ------------
ORCL      26-JAN-16 NOARCHIVELOG

实例信息：
SQL> select instance_name, host_name, version, archiver
  2  from v$instance;

INSTANCE_NAME
----------------
HOST_NAME
----------------------------------------------------------------
VERSION           ARCHIVE
----------------- -------
orcl
ctos
11.2.0.1.0        STOPPED

查看系统上有多少用户和创建日期：
SQL> select username, created  
  2  from dba_users;

USERNAME                       CREATED
------------------------------ ---------
MGMT_VIEW                      15-AUG-09
SYS                            15-AUG-09
SYSTEM                         15-AUG-09
DBSNMP                         15-AUG-09
SYSMAN                         15-AUG-09
SCOTT                          15-AUG-09
OUTLN                          15-AUG-09
FLOWS_FILES                    15-AUG-09
MDSYS                          15-AUG-09
ORDSYS                         15-AUG-09
EXFSYS                         15-AUG-09

USERNAME                       CREATED
------------------------------ ---------
WMSYS                          15-AUG-09
APPQOSSYS                      15-AUG-09
APEX_030200                    15-AUG-09
OWBSYS_AUDIT                   15-AUG-09
ORDDATA                        15-AUG-09
CTXSYS                         15-AUG-09
ANONYMOUS                      15-AUG-09
XDB                            15-AUG-09
ORDPLUGINS                     15-AUG-09
OWBSYS                         15-AUG-09
SI_INFORMTN_SCHEMA             15-AUG-09

USERNAME                       CREATED
------------------------------ ---------
OLAPSYS                        15-AUG-09
ORACLE_OCM                     15-AUG-09
XS$NULL                        15-AUG-09
BI                             26-JAN-16
PM                             26-JAN-16
MDDATA                         15-AUG-09
IX                             26-JAN-16
SH                             26-JAN-16
DIP                            15-AUG-09
OE                             26-JAN-16
APEX_PUBLIC_USER               15-AUG-09

USERNAME                       CREATED
------------------------------ ---------
HR                             26-JAN-16
SPATIAL_CSW_ADMIN_USR          15-AUG-09
SPATIAL_WFS_ADMIN_USR          15-AUG-09

36 rows selected.

=======================
创建数据库语句：
SQL> create table product   
  2     (p_code number(6),
  3     p_name varchar2(30),
  4     p_desc varchar2(100),
  5     p_price number(5,2));

Table created.

SQL> desc product
 Name                                      Null?    Type
 ----------------------------------------- --------
----------------------------
 P_CODE                                             NUMBER(6)
 P_NAME                                             VARCHAR2(30)
 P_DESC                                             VARCHAR2(100)
 P_PRICE                                            NUMBER(5,2)
==================
修改system的密码为manager：
SQL> alter user system identified by manager;
=======================
指定列名并用已存在的表创建新表：
SQL> r
  1  create table t22 (t2_g2_id ,
  2  t2_g2_name ,
  3  t2_member ,
  4  t2_score ,
  5  t2_score2 )
  6  as
  7  select g2_id, g2_name, member, score, score2
  8* from t2
i
Table created.

SQL>select * from t22;

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2
------- --------------- ------- ---------- ----------
002001  qudao           020102          56         56
002001  qudao           020103          69         56
002001  qudao           020104          88         56
002002  file            020201          54         56
002002  file            020202          89         56
003001  shuju           030101          75         56
003001  shuju           030102          70         56
1       ???                                        56
00_11_  escape                                     56
004001  Linshi          40101                      56

21 rows selected.

SQL> drop table t22;

Table dropped.

======================
增加列：
SQL> r
  1* alter table t22 add (add1 varchar2(1))

Table altered.
=========================
修改列属性：
SQL> alter table t22
  2  modify (add1 varchar2(2));

Table altered.

SQL> desc t22;
 Name                                      Null?    Type
 ----------------------------------------- --------
----------------------------
 T2_G2_ID                                           VARCHAR2(7)
 T2_G2_NAME                                         VARCHAR2(15)
 T2_MEMBER                                          VARCHAR2(7)
 T2_SCORE                                           NUMBER(4)
 T2_SCORE2                                          NUMBER(2)
 ADD1                                               VARCHAR2(2)

SQL> alter table t22
  2  modify (add1 varchar2(1));

Table altered.

SQL> desc t22;
 Name                                      Null?    Type
 ----------------------------------------- --------
----------------------------
 T2_G2_ID                                           VARCHAR2(7)
 T2_G2_NAME                                         VARCHAR2(15)
 T2_MEMBER                                          VARCHAR2(7)
 T2_SCORE                                           NUMBER(4)
 T2_SCORE2                                          NUMBER(2)
 ADD1                                               VARCHAR2(1)
====================
对t22增加一列日期类型
SQL> alter table t22
  2  add (date1 date);

Table altered.

修改日期类型列的默认值是系统时间
SQL> alter table t22
  2  modify (date1 default sysdate);

对数据插入一条日期的列是默认值
SQL> insert into t22
  2  (date1)
  3  values(default);

1 row created.

显示插入的内容：
SQL> select * from t22;

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A DATE1
------- --------------- ------- ---------- ---------- - ---------
...
004001  Linshi          40101                      56
                                                        20-DEC-16

22 rows selected.
====================
删除列：
删除前：
SQL> desc t22;
 Name                                      Null?    Type
 ----------------------------------------- --------
----------------------------
 T2_G2_ID                                           VARCHAR2(7)
 T2_G2_NAME                                         VARCHAR2(15)
 T2_MEMBER                                          VARCHAR2(7)
 T2_SCORE                                           NUMBER(4)
 T2_SCORE2                                          NUMBER(2)
 ADD1                                               VARCHAR2(1)
 DATE1                                              DATE
删除操作：
SQL> alter table t22
  2  drop column date1;

Table altered.

删除后：
SQL> desc t22;
 Name                                      Null?    Type
 ----------------------------------------- --------
----------------------------
 T2_G2_ID                                           VARCHAR2(7)
 T2_G2_NAME                                         VARCHAR2(15)
 T2_MEMBER                                          VARCHAR2(7)
 T2_SCORE                                           NUMBER(4)
 T2_SCORE2                                          NUMBER(2)
 ADD1                                               VARCHAR2(1)
===================
标记列为不用列和删除不用列：
多次执行删除未用列不违反任何错误，没有就等于不删；
未用列没有逆向操作命令:
SQL> alter table t22
  2  set unused (date1);

Table altered.

SQL> select * from t22;

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A
------- --------------- ------- ---------- ---------- -
        ???                                        56
001001  qianduan        010102          72         56
001001  qianduan        010103          66         56
001002  lianji          010201          65         56
001001  qianduan        010101          86         56
001002  lianji          010202          56         56
001002  lianji          010202          56         56
001003  rizhong         010301          44         56
001003  rizhong         010302          78         56
001003  rizhong         010303          55         56
002001  qudao           020101          79         56

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A
------- --------------- ------- ---------- ---------- -
002001  qudao           020102          56         56
002001  qudao           020103          69         56
002001  qudao           020104          88         56
002002  file            020201          54         56
002002  file            020202          89         56
003001  shuju           030101          75         56
003001  shuju           030102          70         56
1       ???                                        56
00_11_  escape                                     56
004001  Linshi          40101                      56


T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A
------- --------------- ------- ---------- ---------- -



24 rows selected.

SQL> desc t22;
 Name                                      Null?    Type
 ----------------------------------------- --------
----------------------------
 T2_G2_ID                                           VARCHAR2(7)
 T2_G2_NAME                                         VARCHAR2(15)
 T2_MEMBER                                          VARCHAR2(7)
 T2_SCORE                                           NUMBER(4)
 T2_SCORE2                                          NUMBER(2)
 ADD1                                               VARCHAR2(1)

SQL> alter table t22  
  2  drop unused column;

==================
修改表名字：
SQL> rename t22 to t23;

Table renamed.

修改列名字：
SQL> alter table t22
  2  rename column add2 to add1;

Table altered.
=========================
给表格添加注释：
SQL> comment on table t22
  2  is 'this is exercise';

Comment created.

查看表格注释：
SQL> select comments  
  2  from user_tab_comments
  3  where table_name = 'T22';

COMMENTS
--------------------------------------------------------------------------------
this is exercise

注意表格名字已经用单引号括起来了，区分大小写
像下面这样执行，得不到想查找的结果：
SQL> select comments 
  2  from user_tab_comments
  3  where table_name = 't22';

no rows selected
=========================
给表列添加注释：
SQL> comment on column t22.t2_g2_id
  2  is 'this is group id';

Comment created.

查看表列注释：
SQL> r
  1  select comments
  2  from user_col_comments
  3  where table_name = 'T22'
  4* and column_name = 'T2_G2_ID'

COMMENTS
--------------------------------------------------------------------------------
this is group id

注意查询时的字段使用单引号括起来的，是区分大小写的
像下面这样执行，是得不到想查找的结果的
SQL> select comments
  2  from user_col_comments
  3  where table_name = 't22'
  4  and column_name = 't2_g2_id';

no rows selected

=======================
删除注释只能通过添加空注释的方式，没有删除注释命令
SQL> comment on table t22
  2  is '';
SQL> select comments
  2  from user_tab_comments
  3  where table_name = 'T22';

COMMENTS
--------------------------------------------------------------------------------

=============================
根据t22新创建一个表，再清空表：
SQL> create table t222
  2  as
  3  select * from t22;

Table created.

SQL> select * from t222;

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A DATE1
------- --------------- ------- ---------- ---------- - ---------
        ???                                        56
001001  qianduan        010102          72         56
001001  qianduan        010103          66         56
001002  lianji          010201          65         56
001001  qianduan        010101          86         56
001002  lianji          010202          56         56
001002  lianji          010202          56         56
001003  rizhong         010301          44         56
001003  rizhong         010302          78         56
001003  rizhong         010303          55         56
002001  qudao           020101          79         56

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A DATE1
------- --------------- ------- ---------- ---------- - ---------
002001  qudao           020102          56         56
002001  qudao           020103          69         56
002001  qudao           020104          88         56
002002  file            020201          54         56
002002  file            020202          89         56
003001  shuju           030101          75         56
003001  shuju           030102          70         56
1       ???                                        56
00_11_  escape                                     56
004001  Linshi          40101                      56
                                                        20-DEC-16

22 rows selected.

SQL> truncete table t222;

Table truncated.

查询表没有数据：
SQL> select * from t222;

no rows selected

查询表结构，表结构还在：
SQL> desc t222;
 Name                                      Null?    Type
 ----------------------------------------- --------
----------------------------
 T2_G2_ID                                           VARCHAR2(7)
 T2_G2_NAME                                         VARCHAR2(15)
 T2_MEMBER                                          VARCHAR2(7)
 T2_SCORE                                           NUMBER(4)
 T2_SCORE2                                          NUMBER(2)
 ADD1                                               VARCHAR2(1)
 DATE1                                              DATE

============================
删除表：
SQL> drop table t222;

Table dropped.

SQL> desc t222;
ERROR:
ORA-04043: object t222 does not exist

========================
创建并复制表结构：
下列语句表示创建一个表t222，通过查找表t22创建
而表t22的条件是1=2，此条件永远为假，所以只复制成功了表结构
SQL> create table t222 as select * from t22 where 1=2;

Table created.

SQL> desc t222;
 Name                                      Null?    Type
 ----------------------------------------- --------
----------------------------
 T2_G2_ID                                           VARCHAR2(7)
 T2_G2_NAME                                         VARCHAR2(15)
 T2_MEMBER                                          VARCHAR2(7)
 T2_SCORE                                           NUMBER(4)
 T2_SCORE2                                          NUMBER(2)
 ADD1                                               VARCHAR2(1)
 DATE1                                              DATE

=======================
以＆开头的替代变量：
SQL> r  
  1  select * from t22
  2* where t2_score > &v_score
Enter value for v_score: 60
old   2: where t2_score > &v_score
new   2: where t2_score > 60

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A DATE1
------- --------------- ------- ---------- ---------- - ---------
001001  qianduan        010102          72         56
001001  qianduan        010103          66         56
001002  lianji          010201          65         56
001001  qianduan        010101          86         56
001003  rizhong         010302          78         56
002001  qudao           020101          79         56
002001  qudao           020103          69         56
002001  qudao           020104          88         56
002002  file            020202          89         56
003001  shuju           030101          75         56
003001  shuju           030102          70         56

11 rows selected.

当运行时系统会提示输入要查找的数字比例
======================
开启变量显示原值功能：
SQL> set verify on
SQL> r
  1  select * from t22
  2* where t2_score > &v_score
Enter value for v_score: 60
old   2: where t2_score > &v_score
new   2: where t2_score > 60

========================
字符串变量记得输入单引号：
SQL> r
  1  select * from t22
  2* where t2_g2_name > &v_name
Enter value for v_name: 'qianduan'

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A DATE1
------- --------------- ------- ---------- ---------- - ---------
        ???                                        56
001003  rizhong         010301          44         56
001003  rizhong         010302          78         56
001003  rizhong         010303          55         56
002001  qudao           020101          79         56
002001  qudao           020102          56         56
002001  qudao           020103          69         56
002001  qudao           020104          88         56
003001  shuju           030101          75         56
003001  shuju           030102          70         56
1       ???                                        56

11 rows selected.

=======================
或是直接在脚本的变量两端加上单引号：
SQL> r
  1  select * from t22
  2* where t2_g2_name > '&v_name'
Enter value for v_name: qianduan

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A DATE1
------- --------------- ------- ---------- ---------- - ---------
        ???                                        56
001003  rizhong         010301          44         56
001003  rizhong         010302          78         56
001003  rizhong         010303          55         56
002001  qudao           020101          79         56
002001  qudao           020102          56         56
002001  qudao           020103          69         56
002001  qudao           020104          88         56
003001  shuju           030101          75         56
003001  shuju           030102          70         56
1       ???                                        56

11 rows selected.

======================
&变量名：每次都要重新输入值
&&只需要第一执行的时候输入变量值，以后再执行会自动用以前的旧值
SQL> r
  1  select * from t22
  2* where t2_g2_name > '&&v_name'
Enter value for v_name: qianduan

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A DATE1
------- --------------- ------- ---------- ---------- - ---------
        ???                                        56
001003  rizhong         010301          44         56
001003  rizhong         010302          78         56
001003  rizhong         010303          55         56
002001  qudao           020101          79         56
002001  qudao           020102          56         56
002001  qudao           020103          69         56
002001  qudao           020104          88         56
003001  shuju           030101          75         56
003001  shuju           030102          70         56
1       ???                                        56

11 rows selected.

========================
将变量当作列值：
SQL> select &value from t22;
Enter value for value: *

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A DATE1
------- --------------- ------- ---------- ---------- - ---------
        ???                                        56
001001  qianduan        010102          72         56
001001  qianduan        010103          66         56
001002  lianji          010201          65         56
001001  qianduan        010101          86         56
001002  lianji          010202          56         56
001002  lianji          010202          56         56
001003  rizhong         010301          44         56
001003  rizhong         010302          78         56
001003  rizhong         010303          55         56
002001  qudao           020101          79         56

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A DATE1
------- --------------- ------- ---------- ---------- - ---------
002001  qudao           020102          56         56
002001  qudao           020103          69         56
002001  qudao           020104          88         56
002002  file            020201          54         56
002002  file            020202          89         56
003001  shuju           030101          75         56
003001  shuju           030102          70         56
1       ???                                        56
00_11_  escape                                     56
004001  Linshi          40101                      56
                                                        20-DEC-16

22 rows selected.

SQL> r  
  1* select &value from t22
Enter value for value: t2_g2_id

T2_G2_I
-------

001001
001001
001002
001001
001002
001002
001003
001003
001003
002001

T2_G2_I
-------
002001
002001
002001
002002
002002
003001
003001
1
00_11_
004001


22 rows selected.
====================
变量做表达式：
SQL> r  
  1* select * from t22 where &condition
Enter value for condition: t2_g2_id = '003001'

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A DATE1
------- --------------- ------- ---------- ---------- - ---------
003001  shuju           030101          75         56
003001  shuju           030102          70         56

=======================
define命令的运用：
SQL> define value
SP2-0135: symbol value is UNDEFINED
SQL> define value = t2_g2_id
SQL> define value 
DEFINE VALUE           = "t2_g2_id" (CHAR)
SQL> select &value from t22;

T2_G2_I
-------

001001
001001
001002
001001
001002
001002
001003
001003
001003
002001

T2_G2_I
-------
002001
002001
002001
002002
002002
003001
003001
1
00_11_
004001


22 rows selected.
=================
查看定义的全部变量：
SQL> define
DEFINE _DATE           = "21-DEC-16" (CHAR)
DEFINE _CONNECT_IDENTIFIER = "orcl" (CHAR)
DEFINE _USER           = "SYS" (CHAR)
DEFINE _PRIVILEGE      = "AS SYSDBA" (CHAR)
DEFINE _SQLPLUS_RELEASE = "1102000100" (CHAR)
DEFINE _EDITOR         = "ed" (CHAR)
DEFINE _O_VERSION      = "Oracle Database 11g Enterprise Edition Release
11.2.0.1.0 - 64bit Production
With the Partitioning, OLAP, Data Mining and Real Application Testing options"
(CHAR)
DEFINE _O_RELEASE      = "1102000100" (CHAR)
DEFINE V_NAME          = "qianduan" (CHAR)
DEFINE VALUE           = "t2_g2_id" (CHAR)
======================
带提示设置变量命令accept：
[oracle@ctos oracle]$ cat tmp.sql 
ACCEPT v_name PROMPT 'please enter the v_name tible:'
select * from t22
where t2_g2_name = '&v_name'
/
SQL> @tmp
please enter the v_name tible:qianduan

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A DATE1
------- --------------- ------- ---------- ---------- - ---------
001001  qianduan        010102          72         56
001001  qianduan        010103          66         56
001001  qianduan        010101          86         56
======================
隐藏输入的内容的accept命令：
accept + prompt + hide
[oracle@ctos oracle]$ cat passwd.sql 
accept pwd prompt 'please enter your password:' hide
select * from t22
where '&pwd' = 'manage'
/
SQL> @passwd
please enter your password:

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A DATE1
------- --------------- ------- ---------- ---------- - ---------
        ???                                        56
001001  qianduan        010102          72         56
001001  qianduan        010103          66         56
001002  lianji          010201          65         56
001001  qianduan        010101          86         56
001002  lianji          010202          56         56
001002  lianji          010202          56         56
001003  rizhong         010301          44         56
001003  rizhong         010302          78         56
001003  rizhong         010303          55         56
002001  qudao           020101          79         56

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A DATE1
------- --------------- ------- ---------- ---------- - ---------
002001  qudao           020102          56         56
002001  qudao           020103          69         56
002001  qudao           020104          88         56
002002  file            020201          54         56
002002  file            020202          89         56
003001  shuju           030101          75         56
003001  shuju           030102          70         56
1       ???                                        56
00_11_  escape                                     56
004001  Linshi          40101                      56
                                                        20-DEC-16

22 rows selected.
============================
插入空值的方法，字符串可以用''，也可以用null表示，或是干脆不插入任何in值
SQL> insert into t222
  2  (t2_g2_id, t2_g2_name, t2_member, t2_score, t2_score2)
  3  values ('004003', '',  null, null, null);

1 row created.

SQL> select * from t222 where t2_g2_id = '004003';

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A DATE1
------- --------------- ------- ---------- ---------- - ---------
004003

===========================
通过另外一个表创建表：
SQL> create table t222    
  2  as
  3  select * from t22;

Table created.

SQL> select * from t222;

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A DATE1
------- --------------- ------- ---------- ---------- - ---------
        ???                                        56
001001  qianduan        010102          72         56
001001  qianduan        010103          66         56
001002  lianji          010201          65         56
001001  qianduan        010101          86         56
001002  lianji          010202          56         56
001002  lianji          010202          56         56
001003  rizhong         010301          44         56
001003  rizhong         010302          78         56
001003  rizhong         010303          55         56
002001  qudao           020101          79         56

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A DATE1
------- --------------- ------- ---------- ---------- - ---------
002001  qudao           020102          56         56
002001  qudao           020103          69         56
002001  qudao           020104          88         56
002002  file            020201          54         56
002002  file            020202          89         56
003001  shuju           030101          75         56
003001  shuju           030102          70         56
1       ???                                        56
00_11_  escape                                     56
004001  Linshi          40101                      56
                                                        20-DEC-16

22 rows selected.

=====================
清空t222表，并通过查询子句插入另外一张表达的内容：
SQL> truncate table t222;

Table truncated.

SQL> select * from t222;

no rows selected

执行完命令如下：
SQL> insert into t222    
  2  select * from t22;

22 rows created.

SQL> select * from t222;

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A DATE1
------- --------------- ------- ---------- ---------- - ---------
        ???                                        56
001001  qianduan        010102          72         56
001001  qianduan        010103          66         56
001002  lianji          010201          65         56
001001  qianduan        010101          86         56
001002  lianji          010202          56         56
001002  lianji          010202          56         56
001003  rizhong         010301          44         56
001003  rizhong         010302          78         56
001003  rizhong         010303          55         56
002001  qudao           020101          79         56

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A DATE1
------- --------------- ------- ---------- ---------- - ---------
002001  qudao           020102          56         56
002001  qudao           020103          69         56
002001  qudao           020104          88         56
002002  file            020201          54         56
002002  file            020202          89         56
003001  shuju           030101          75         56
003001  shuju           030102          70         56
1       ???                                        56
00_11_  escape                                     56
004001  Linshi          40101                      56
                                                        20-DEC-16

22 rows selected.

==============================
利用替代变量向数据库中插入数据：
SQL> r
  1  insert into t222
  2  (t2_g2_id, t2_g2_name, t2_member, t2_score, t2_score2, add1, date1)
  3* values ('&g2_id', '&g2_name', '&member', &score, &score, '&a',
to_date('&date1', 'YYYYMMDD'))
Enter value for g2_id: 004004
Enter value for g2_name: 44nn
Enter value for member: 44nn
Enter value for score: 57
Enter value for score: 57
Enter value for a: 1
Enter value for date1: 20161222

1 row created.

将sqlplus中的内容存成脚本文件，replace是覆盖原有文件内容：
SQL> save tmp replace
Wrote file tmp.sql

SQL> select * from t222 where t2_g2_id = '004004';

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A DATE1
------- --------------- ------- ---------- ---------- - ---------
004004  44nn            44nn            57         57 1 22-DEC-16
===================
利用accept命令生成带提示的替代变量的脚本：
[oracle@ctos oracle]$ cat tmp.sql 
accept g2_id prompt 'please enter g2_id:'
accept g2_name prompt 'please enter g2_name:'
accept member prompt 'please enter member:'
accept score prompt 'please enter score:'
accept a prompt 'please enter add1:'
accept date1 prompt 'please enter date1 format YYYYMMDD:'
insert into t222
(t2_g2_id, t2_g2_name, t2_member, t2_score, t2_score2, add1, date1)
values ('&g2_id', '&g2_name', '&member', &score, &score, '&a',
to_date('&date1', 'YYYYMMDD'))
/
SQL> @tmp 
please enter g2_id:004006
please enter g2_name:0406
please enter member:0406
please enter score:61
please enter add1:3
please enter date1 format YYYYMMDD:20161222

1 row created.

SQL> select * from t222 where t2_g2_id = '004006';

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A DATE1
------- --------------- ------- ---------- ---------- - ---------
004006  0406            0406            61         61 3 22-DEC-16
============================
将一列清空，再改变字段大小，重新赋值之后，再将重新赋值之后的数字缩小0.9倍之后重新赋值：
SQL> update t222 set t222 = null;
update t222 set t222 = null
                *
ERROR at line 1:
ORA-00904: "T222": invalid identifier


SQL> update t222 set t2_score2 = null;

25 rows updated.

SQL> select * from t222;

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A DATE1
------- --------------- ------- ---------- ---------- - ---------
        ???
001001  qianduan        010102          65
001001  qianduan        010103          59
001002  lianji          010201          59
001001  qianduan        010101          77
001002  lianji          010202          50
001002  lianji          010202          50
001003  rizhong         010301          40
001003  rizhong         010302          70
001003  rizhong         010303          50
002001  qudao           020101          71

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A DATE1
------- --------------- ------- ---------- ---------- - ---------
002001  qudao           020102          50
002001  qudao           020103          62
002001  qudao           020104          79
002002  file            020201          49
002002  file            020202          80
003001  shuju           030101          68
003001  shuju           030102          63
1       ???
00_11_  escape
004001  Linshi          40101
                                                        20-DEC-16

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A DATE1
------- --------------- ------- ---------- ---------- - ---------
004004  44nn            44nn            51            1 22-DEC-16
004005  004005          004005          52            2 22-DEC-16
004006  0406            0406            55            3 22-DEC-16

25 rows selected.

SQL> alter table t222   
  2  modify (t2_score2 varchar2(3));

Table altered.

SQL> update t222 set t2_score2 = 100;

25 rows updated.

SQL> select * from t222;

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE T2_ A DATE1
------- --------------- ------- ---------- --- - ---------
        ???                                100
001001  qianduan        010102          65 100
001001  qianduan        010103          59 100
001002  lianji          010201          59 100
001001  qianduan        010101          77 100
001002  lianji          010202          50 100
001002  lianji          010202          50 100
001003  rizhong         010301          40 100
001003  rizhong         010302          70 100
001003  rizhong         010303          50 100
002001  qudao           020101          71 100

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE T2_ A DATE1
------- --------------- ------- ---------- --- - ---------
002001  qudao           020102          50 100
002001  qudao           020103          62 100
002001  qudao           020104          79 100
002002  file            020201          49 100
002002  file            020202          80 100
003001  shuju           030101          68 100
003001  shuju           030102          63 100
1       ???                                100
00_11_  escape                             100
004001  Linshi          40101              100
                                           100   20-DEC-16

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE T2_ A DATE1
------- --------------- ------- ---------- --- - ---------
004004  44nn            44nn            51 100 1 22-DEC-16
004005  004005          004005          52 100 2 22-DEC-16
004006  0406            0406            55 100 3 22-DEC-16

25 rows selected.

SQL> update t222 set t2_score2 = t2_score2 * 0.9;

25 rows updated.

SQL> select * from t222;

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE T2_ A DATE1
------- --------------- ------- ---------- --- - ---------
        ???                                90
001001  qianduan        010102          65 90
001001  qianduan        010103          59 90
001002  lianji          010201          59 90
001001  qianduan        010101          77 90
001002  lianji          010202          50 90
001002  lianji          010202          50 90
001003  rizhong         010301          40 90
001003  rizhong         010302          70 90
001003  rizhong         010303          50 90
002001  qudao           020101          71 90

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE T2_ A DATE1
------- --------------- ------- ---------- --- - ---------
002001  qudao           020102          50 90
002001  qudao           020103          62 90
002001  qudao           020104          79 90
002002  file            020201          49 90
002002  file            020202          80 90
003001  shuju           030101          68 90
003001  shuju           030102          63 90
1       ???                                90
00_11_  escape                             90
004001  Linshi          40101              90
                                           90    20-DEC-16

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE T2_ A DATE1
------- --------------- ------- ---------- --- - ---------
004004  44nn            44nn            51 90  1 22-DEC-16
004005  004005          004005          52 90  2 22-DEC-16
004006  0406            0406            55 90  3 22-DEC-16

25 rows selected.

SQL> desc t222;
 Name                                      Null?    Type
 ----------------------------------------- --------
----------------------------
 T2_G2_ID                                           VARCHAR2(7)
 T2_G2_NAME                                         VARCHAR2(15)
 T2_MEMBER                                          VARCHAR2(7)
 T2_SCORE                                           NUMBER(4)
 T2_SCORE2                                          VARCHAR2(3)
 ADD1                                               VARCHAR2(1)
 DATE1                                              DATE

============================
修改两列：
SQL> select * from t222 where t2_g2_id = '004001';

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE T2_ A DATE1
------- --------------- ------- ---------- --- - ---------
004001  Linshi          40101              90
                                           90    20-DEC-16

SQL> update t222 set t2_g2_name = 'linshi'                    
  2  , t2_member = '040101' 
  3  where t2_g2_id = '004001';

1 row updated.

SQL> select * from t222 where t2_g2_id = '004001';

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE T2_ A DATE1
------- --------------- ------- ---------- --- - ---------
004001  linshi          040101             90
==============================
带查询子句的update语句：

SQL> r
  1  update t222 set t2_score = (select low from tab_score)
  2* where t2_score > (select low from tab_score)

20 rows updated.


SQL> select * from t222;

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE T2_ A DATE1
------- --------------- ------- ---------- --- - ---------
        ???                                90
001001  qianduan        010102          60 90
001001  qianduan        010103          60 90
001002  lianji          010201          60 90
001001  qianduan        010101          60 90
001002  lianji          010202          60 90
001002  lianji          010202          60 90
001003  rizhong         010301          60 90
001003  rizhong         010302          60 90
001003  rizhong         010303          60 90
002001  qudao           020101          60 90

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE T2_ A DATE1
------- --------------- ------- ---------- --- - ---------
002001  qudao           020102          60 90
002001  qudao           020103          60 90
002001  qudao           020104          60 90
002002  file            020201          60 90
002002  file            020202          60 90
003001  shuju           030101          60 90
003001  shuju           030102          60 90
1       ???                                90
00_11_  escape                             90
004001  linshi          040101             90
                                           90    20-DEC-16

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE T2_ A DATE1
------- --------------- ------- ---------- --- - ---------
004004  44nn            44nn            60 90  1 22-DEC-16
004005  004005          004005          60 90  2 22-DEC-16
004006  0406            0406            60 90  3 22-DEC-16

25 rows selected.

SQL> select * from tab_score;

     HIGHT        LOW I
---------- ---------- -
       100         60 1

===========================
带多列查询子句的update：
SQL> r
  1  update t222 set (t2_score, t2_score2) = (
  2* select low, hight from tab_score where id = '1')

25 rows updated.

SQL> select * from t222;

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE T2_ A DATE1
------- --------------- ------- ---------- --- - ---------
        ???                             60 100
001001  qianduan        010102          60 100
001001  qianduan        010103          60 100
001002  lianji          010201          60 100
001001  qianduan        010101          60 100
001002  lianji          010202          60 100
001002  lianji          010202          60 100
001003  rizhong         010301          60 100
001003  rizhong         010302          60 100
001003  rizhong         010303          60 100
002001  qudao           020101          60 100

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE T2_ A DATE1
------- --------------- ------- ---------- --- - ---------
002001  qudao           020102          60 100
002001  qudao           020103          60 100
002001  qudao           020104          60 100
002002  file            020201          60 100
002002  file            020202          60 100
003001  shuju           030101          60 100
003001  shuju           030102          60 100
1       ???                             60 100
00_11_  escape                          60 100
004001  linshi          040101          60 100
                                        60 100   20-DEC-16

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE T2_ A DATE1
------- --------------- ------- ---------- --- - ---------
004004  44nn            44nn            60 100 1 22-DEC-16
004005  004005          004005          60 100 2 22-DEC-16
004006  0406            0406            60 100 3 22-DEC-16

25 rows selected.

========================
多条件删除语句：
SQL> insert into t222 
  2  (t2_g2_id, t2_score) 
  3  values ('005001', 70);

1 row created.

SQL> select * from t222
  2  where t2_g2_id = '005001';

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE T2_ A DATE1
------- --------------- ------- ---------- --- - ---------
005001                                  70

SQL> delete t222 where t2_g2_id = '005001'
  2  and t2_score = 70;

1 row deleted.

SQL> select * from t222 where t2_g2_id = '005001';

no rows selected

或执行：
SQL> delete from t222 where t2_g2_id = '005001';

1 row deleted.


==============
查看sqlplus所有的设置：
SQL> show all
appinfo is OFF and set to "SQL*Plus"
arraysize 15
autocommit OFF
autoprint OFF
autorecovery OFF
autotrace OFF
blockterminator "." (hex 2e)
btitle OFF and is the first few characters of the next SELECT statement
cmdsep OFF
colsep " "
compatibility version NATIVE
concat "." (hex 2e)
copycommit 0
COPYTYPECHECK is ON
define "&" (hex 26)
describe DEPTH 1 LINENUM OFF INDENT ON
echo OFF
editfile "afiedt.buf"
embedded OFF
escape OFF
escchar OFF
exitcommit ON
FEEDBACK ON for 6 or more rows
flagger OFF
flush ON
heading ON
headsep "|" (hex 7c)
instance "local"
linesize 80
lno 9
loboffset 1
logsource ""
long 80
longchunksize 80
markup HTML OFF HEAD "<style type='text/css'> body {font:10pt
Arial,Helvetica,sans-serif; color:black; background:White;} p {font:10pt
Arial,Helvetica,sans-serif; color:black; background:White;} table,tr,td
{font:10pt Arial,Helvetica,sans-serif; color:Black; background:#f7f7e7;
padding:0px 0px 0px 0px; margin:0px 0px 0px 0px;} th {font:bold 10pt
Arial,Helvetica,sans-serif; color:#336699; background:#cccc99; padding:0px 0px
0px 0px;} h1 {font:16pt Arial,Helvetica,Geneva,sans-serif; color:#336699;
background-color:White; border-bottom:1px solid #cccc99; margin-top:0pt;
margin-bottom:0pt; padding:0px 0px 0px 0px;-
} h2 {font:bold 10pt Arial,Helvetica,Geneva,sans-serif; color:#336699;
background-color:White; margin-top:4pt; margin-bottom:0pt;} a {font:9pt
Arial,Helvetica,sans-serif; color:#663300; background:#ffffff; margin-top:0pt;
margin-bottom:0pt; vertical-align:top;}</style><title>SQL*Plus Report</title>"
BODY "" TABLE "border='1' width='90%' align='center' summary='Script output'"
SPOOL OFF ENTMAP ON PREFORMAT OFF
newpage 1
null ""
numformat ""
numwidth 10
pagesize 14
PAUSE is OFF
pno 3
recsep WRAP
recsepchar " " (hex 20)
release 1102000100
repfooter OFF and is NULL
repheader OFF and is NULL
securedcol is OFF
serveroutput OFF
shiftinout INVISIBLE
showmode OFF
spool ON
sqlblanklines OFF
sqlcase MIXED
sqlcode 0
sqlcontinue "> "
sqlnumber ON
sqlpluscompatibility 11.2.0
sqlprefix "#" (hex 23)
sqlprompt "SQL> "
sqlterminator ";" (hex 3b)
suffix "sql"
tab ON
termout ON
timing OFF
trimout ON
trimspool OFF
ttitle OFF and is the first few characters of the next SELECT statement
underline "-" (hex 2d)
USER is "SYS"
verify OFF
wrap : lines will be wrapped
errorlogging is OFF
==================
设置自动提交之后，执行dml之后，命令显示自动提交
SQL> set autocommit on
SQL> update t222 set t2_score2 = 75 where t2_g2_id = '005001';

1 row updated.

Commit complete.
=====================
创建索引方法：
建表：
SQL> select * from t1;

G1_ID G1_NAME    G2_ID      G2_NAME
----- ---------- ---------- ----------
0     a          00         A
1     b          01         B
1+    b+         01         B+
3     d          03         D

SQL> select * from t2;

G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
---------- ---------- ---------- ---------- ----------
00         A          0001               60
00         A          0002               59
00         A          0003               61
01         B          0101               80
01         B          0102               90
02         C          0201              100
01         B          0103               61

7 rows selected.

SQL> create table t22 
  2  as
  3  select * from t2 where 1=2;

Table created.

SQL> desc t22;
 Name                                      Null?    Type
 ----------------------------------------- --------
----------------------------
 G2_ID                                              VARCHAR2(10)
 G2_NAME                                            VARCHAR2(10)
 MEMBER                                             VARCHAR2(10)
 SCORE                                              NUMBER(4)
 SCORE2                                             NUMBER(4)

SQL> select * from t22;

no rows selected

建索引：
给表t22的g2_id字段，添加上名为t22_g2_id的索引：
SQL> create index t22_g2_id
  2  on t22(g2_id);

Index created.

查询索引，在user_indexes表中查询表名为T22的索引信息
注意表名区分大小写：
SQL> col index_type for a10
SQL> col index_name for a10
SQL> r
  1   select index_name, index_type, table_name,
  2  uniqueness
  3   from user_indexes
  4*  where table_name = 'T22'

INDEX_NAME INDEX_TYPE TABLE_NAME                     UNIQUENES
---------- ---------- ------------------------------ ---------
T22_G2_ID  NORMAL     T22                            NO
在user_ind_columns表中，查询索引对应的列的情况：
SQL> r
  1   select index_name, table_name, column_name
  2   , column_position
  3   from user_ind_columns
  4* where table_name = 'T22'

INDEX_NAME TABLE_NAME                     COLUMN_NAME     COLUMN_POSITION
---------- ------------------------------ --------------- ---------------
T22_G2_ID  T22                            G2_ID                         1

==========================
表删除之后，表的索引在索引表中也没有了：
SQL> drop table t22;

Table dropped.

SQL> select index_name, table_name, column_name 
  2  , column_position
  3  from user_ind_columns
  4  where table_name = 'T22';

no rows selected

========================
组合索引的建立：
重新建表如下，变动以前列的位置，为稍后验证column_position显示的结果作准备
SQL> r 
  1  create table t22
  2  as
  3* select member, score, g2_name, g2_id, score2 from t2 where 2=1

Table created.

SQL> select * from t22;

no rows selected

SQL> desc t22;
 Name
Null?    Type
 -----------------------------------------------------------------------------------------------------------------
--------
----------------------------------------------------------------------------
 MEMBER
VARCHAR2(10)
 SCORE
NUMBER(4)
 G2_NAME
VARCHAR2(10)
 G2_ID
VARCHAR2(10)
 SCORE2
NUMBER(4)

SQL> create index t22_g2_id_and_name
  2  on t22(g2_id, g2_name);

Index created.

查询索引位置可以看到，column_position显示的列在索引中的位置，而并非是索引所在列在表中的位置
SQL> select index_name, table_name, column_name, column_position
  2  from user_ind_columns
  3  where table_name = 'T22';

INDEX_NAME           TABLE_NAME      COLUMN_NAME     COLUMN_POSITION
-------------------- --------------- --------------- ---------------
T22_G2_ID_AND_NAME   T22             G2_NAME                       2
T22_G2_ID_AND_NAME   T22             G2_ID                         1

======================
索引的删除：
SQL> drop index T22_G2_ID_AND_NAME;

Index dropped.

===========================
建立函数索引：

SQL> create index t22_score_sub_20
  2  on t22(score - 20);

Index created.

查询索引信息：
SQL> get tmp
  1  select index_name, index_type, table_name, uniqueness
  2  from user_indexes
  3* where table_name = 'T22'
SQL> /

INDEX_NAME           INDEX_TYPE                TABLE_NAME      UNIQUENESS
-------------------- ------------------------- ---------------
--------------------
T22_SCORE_SUB_20     FUNCTION-BASED NORMAL     T22             NONUNIQUE

查询索引和列对应的信息：
SQL> select index_name, table_name, column_name, column_position
  2  from user_ind_columns
  3  where table_name = 'T22';

INDEX_NAME           TABLE_NAME      COLUMN_NAME     COLUMN_POSITION
-------------------- --------------- --------------- ---------------
T22_SCORE_SUB_20     T22             SYS_NC00006$                  1

