=====================
order by 后可以填表达或者别名为排序条件，排序条件可以为任意表达式，可以与查询投影一致，也可以不一致，相互独立
SQL> select * from t2 where score > 60 and score < 80 order by score+10;

G2_ID   G2_NAME         MEMBER       SCORE
------- --------------- ------- ----------
001002  lianji          010201          65
001001  qianduan        010103          66
002001  qudao           020103          69
003001  shuju           030102          70
001001  qianduan        010102          72
003001  shuju           030101          75
001003  rizhong         010302          78
002001  qudao           020101          79

8 rows selected.
=====================
order by 后接别名，只要别名命名与当前命名是一致的即可，无论别名命名是否合理
SQL> select g2_id, score+20 as "score+5" from t2 order by "score+5";

G2_ID      score+5
------- ----------
001003          64
002002          74
001003          75
002001          76
001002          76
001002          76
001002          85
001001          86
002001          89
003001          90
001001          92

G2_ID      score+5
------- ----------
003001          95
001003          98
002001          99
001001         106
002001         108
002002         109

1
00_11_

20 rows selected.
====================
转义字符的定义与应用
SQL> select *from t2 where g2_id like '00\_11\_' escape '\';

G2_ID   G2_NAME         MEMBER       SCORE
------- --------------- ------- ----------
00_11_  escape

SQL> select * from t2 where g2_id like '00~_11~_' escape '~';

G2_ID   G2_NAME         MEMBER       SCORE
------- --------------- ------- ----------
00_11_  escape
===================
表达是及别名的运用
SQL> select g2_id, (score + 50)/1.2 "fix" from t2;

G2_ID          fix
------- ----------

001001  101.666667
001001  96.6666667
001002  95.8333333
001001  113.333333
001002  88.3333333
001002  88.3333333
001003  78.3333333
001003  106.666667
001003        87.5
002001       107.5

G2_ID          fix
------- ----------
002001  88.3333333
002001  99.1666667
002001         115
002002  86.6666667
002002  115.833333
003001  104.166667
003001         100
1
00_11_

20 rows selected.
=======================
按列号排序
SQL> select g2_id, score from t2 order by 2;

G2_ID        SCORE
------- ----------
001003          44
002002          54
001003          55
002001          56
001002          56
001002          56
001002          65
001001          66
002001          69
003001          70
001001          72
======================
多列多样式（分别升序或降序）排序
SQL> select score, g2_name from t2 order by g2_name, score desc;

     SCORE G2_NAME
---------- ---------------
           escape
        89 file
        54 file
        65 lianji
        56 lianji
        56 lianji
        86 qianduan
        72 qianduan
        66 qianduan
        88 qudao
        79 qudao
==========================
设置显示宽度
SQL> set linesize 80;
或
SQL> set line 80;
==============================
l（list）和行号 替换内容编辑历史命令
/(run)命令继续执行
SQL> select *  
  2  from t2
  3  where g1_id = '002001';
where g1_id = '002001'
      *
ERROR at line 3:
ORA-00904: "G1_ID": invalid identifier


SQL> 3 where g2_id = '002001';
SQL> l  
  1  select *
  2  from t2
  3* where g2_id = '002001'
SQL> /

G2_ID   G2_NAME         MEMBER       SCORE
------- --------------- ------- ----------
002001  qudao           020101          79
002001  qudao           020102          56
002001  qudao           020103          69
002001  qudao           020104          88
===============
a[ppend]追加命令
SQL> select g2_id
  2  from t2;

G2_ID
-------

001001
001001
001002
001001
001002
001002
001003
001003
001003
002001

G2_ID
-------
002001
002001
002001
002002
002002
003001
003001
1
00_11_

20 rows selected.

SQL> l
  1  select g2_id
  2* from t2
SQL> 1
  1* select g2_id
SQL> a , g2_name
  1* select g2_id, g2_name
SQL> /

G2_ID   G2_NAME
------- ---------------
        ???
001001  qianduan
001001  qianduan
001002  lianji
001001  qianduan
001002  lianji
001002  lianji
001003  rizhong
001003  rizhong
001003  rizhong
002001  qudao

G2_ID   G2_NAME
------- ---------------
002001  qudao
002001  qudao
002001  qudao
002002  file
002002  file
003001  shuju
003001  shuju
1       ???
00_11_  escape

20 rows selected.

===============
运行命令 / 或 r[un]
r回显执行命令的内容
/不回显执行命令内容
SQL> r   
  1  select *
  2* from t1

     G1_ID G1_NAME
---------- ----------
         0 a
         1 b

SQL> /

     G1_ID G1_NAME
---------- ----------
         0 a
         1 b
===============
在最前加一行及删除指定行
SQL> 0 add
SQL> l
  1  add
  2  select g2_id, g2_name
  3* from t2
SQL> del 1
SQL> l
  1  select g2_id, g2_name
  2* from t2
==================
删除一段内容
SQL> l
  1  select *
  2  from t1
  3  where g1_id = '0'
  4* and g1_name = 'a'
SQL> del 3 4
SQL> l
  1  select *
  2* from t1
SQL> 
===================
c[hange]命令，替换行当中的内容
SQL> l  
  1  select g1_id
  2* from t1
SQL> 1 
  1* select g1_id
SQL> c /g1_id/g1_name
  1* select g1_name
SQL> l  
  1  select g1_name
  2* from t1
SQL> /  

G1_NAME
----------
a
b
====================
c命令删除一段内容方法
SQL> l
  1  select g1_id, g1_name
  2* from t1
SQL> /  

     G1_ID G1_NAME
---------- ----------
         0 a
         1 b

SQL> 1
  1* select g1_id, g1_name
SQL> c /g1_id,/
  1* select  g1_name
SQL> /  

G1_NAME
----------
a
b

SQL> l
  1  select  g1_name
  2* from t1
======================
将缓存区中的内容保存成脚本：
SQL> l   
  1  select g1_id
  2* from t1
SQL> save save  
Created file save.sql
查看脚本内容：
$ cat save.sql 
select g1_id
from t1
/
====================
将脚本文件读入缓存区
SQL> get save.sql
  1  select g1_id
  2* from t1
SQL> l  
  1  select g1_id
  2* from t1
SQL> /

     G1_ID
----------
         0
         1
====================
直接运行脚本
SQL> @ save.sql

     G1_ID
----------
         0
         1

SQL> @save

     G1_ID
----------
         0
         1
=========================
将屏幕执行结果记录在文件中：
SQL> spool output
SQL> /  

     G1_ID
----------
         0
         1

SQL> spool off /* 执行后关闭导出 */
查看执行结果文件：
$ cat output.lst 
SQL> /

     G1_ID                                                                      
----------                                                                      
         0                                                                      
         1                                                                      

SQL> spool off
========================
单行函数：
转成小写lower
SQL> r
  1* select Lower('ThIs is lower') from dual

LOWER('THISIS
-------------
this is lower
==========================
转成大写：
SQL> select upper('Sql Is Used Exclusively In Rdbmses')   
  2  from dual;

UPPER('SQLISUSEDEXCLUSIVELYINRDBMS
----------------------------------
SQL IS USED EXCLUSIVELY IN RDBMSES
=====================
将所有单词格式化成首字母大写，其他字母小写
SQL> select initcap('SQL is an english like language')
  2  from dual;

INITCAP('SQLISANENGLISHLIKELANG
-------------------------------
Sql Is An English Like Language
===============================
连接字符串函数：
下面是嵌套两个函数的效果
SQL> r
  1  select concat('Top', concat('Mid', 'Tail'))
  2* from dual

CONCAT('TO
----------
TopMidTail
==================================
substr(str, m[,n])
返回一个字符串的子串
本函数为变参函数，最后一个参数填入，则返回填入的长度，如果不填入，则返回从n开始所有str所有的剩余部分
SQL> r     
  1  select substr('12345 67890', 2)
  2* from dual

SUBSTR('12
----------
2345 67890

SQL> 1  
  1* select substr('12345 67890', 2)
SQL> c /, 2)/, 2, 3)
  1* select substr('12345 67890', 2, 3)
SQL> r
  1  select substr('12345 67890', 2, 3)
  2* from dual

SUB
---
234
==============================
返回字符串的长度
SQL> select length('123456')
  2  from dual;

LENGTH('123456')
----------------
               6
=============================
返回字串的位置：
instr(列名|表达式, str, [m], [n])
instr（'源字符串' , '目标字符串' ,'开始位置','第几次出现'）
区分大小写
其中sourceString代表源字符串；
destString代表要从源字符串中查找的子串；
start代表查找的开始位置，这个参数可选的，默认为1；
appearPosition代表想从源字符中查找出第几次出现的destString，这个参数也是可选的，
默认为1
如果start的值为负数，则代表从右往左进行查找，但是位置数据仍然从左向右计算。
返回值为：查找到的字符串的位置。
-------------------------------------------------------------

对于instr函数，我们经常这样使用：从一个字符串中查找指定子串的位置。例如：

SQL> select instr('abcdefgh','de') position from dual;


POSITION
----------
   4
从1开始算 d排第四所以返回4

SQL>select instr('abcdefghbc','bc',3) position from dual;

POSITION
----------
  9
从第3个字符开始算起 第3个字符是c，所以从3开始以后的字符串找查找bc,返回9

---------------------------
从第1个字符开始，查找第2次出现子串的位置
SQL> select instr('qinyinglianqin','qin', 1, 2) position from dual;
POSITION
----------
  12 
===================
从字符串两端去掉一个指定字符
SQL> r  
  1  select trim ('h' from  'headh') "Trim"
  2* from dual

Tri
---
ead

SQL> select trim(leading 'h' from 'headh') "Trim"
  2  from dual;

Trim
----
eadh

SQL> select trim(trailing 'h' from 'headh') "Trim"
  2  from dual;

Trim
----
head
两端多个连续的字符，都递归的去掉
SQL> select trim('h' from 'hheadhh')   
  2  from dual;

TRI
---
ead
===========================
替换函数
SQL> r
  1  select replace('123456','34', 'ab')
  2* from dual

REPLAC
------
12ab56
========================================
round四舍五入函数
trunc截断函数
SQL> r
  1  select round(168.888, 1), trunc(168.888, 1), round(168.999, 1)
  2* from dual

ROUND(168.888,1) TRUNC(168.888,1) ROUND(168.999,1)
---------------- ---------------- ----------------
           168.9            168.8              169
第三列当百分位向十分位进位之后，0.9变成了1.0，直接只显示整数，小数点后因为是零直接不显示了

精确到个位的处理如以下两种方式表达：
SQL> r
  1  select round(168.888, 0),trunc(168.888, 0)
  2* from dual

ROUND(168.888,0) TRUNC(168.888,0)
---------------- ----------------
             169              168

SQL> select round(168.888), trunc(168.888, 0)
  2  from dual;

ROUND(168.888) TRUNC(168.888,0)
-------------- ----------------
           169              168
可以写0位，或是直接忽略不写

四舍五入到10位：
SQL> select round(168.888, -1), trunc(168.888, -1)
  2  from dual;

ROUND(168.888,-1) TRUNC(168.888,-1)
----------------- -----------------
              170               160
=============================
求余：mod
SQL> select mod(1900, 400)   
  2  from dual;

MOD(1900,400)
-------------
          300
=================================
显示系统时间：
SQL> select sysdate from dual;

SYSDATE
---------
12-DEC-16
日期数据计算：
将当前系统日期减掉一天
SQL> select sysdate - 1    
  2  from dual;

SYSDATE-1
---------
11-DEC-16
日期字符串和日期进行计算：
SQL> select to_date('15-jul-12') - sysdate
  2  from dual;

TO_DATE('15-JUL-12')-SYSDATE
----------------------------
                  -1611.6491
系统日期与小时进行计算：
SQL> select sysdate - 22/24
  2  from dual;

SYSDATE-2
---------
11-DEC-16
SQL> r
  1  select sysdate+ 22/24
  2* from dual

SYSDATE+2
---------
13-DEC-16
==========================
返回两个日期之间的月份：
SQL> select months_between('01-jul-99', '01-jul-98')
  2  from dual;

MONTHS_BETWEEN('01-JUL-99','01-JUL-98')
---------------------------------------
                                     12
=============================
将一个日期加上或减去某一个整月：
SQL> select add_months('01-jul-99', 1)
  2  from dual;

ADD_MONTH
---------
01-AUG-99

SQL> 1  
  1* select add_months('01-jul-99', 1)
SQL> c /, 1/, -1 
  1* select add_months('01-jul-99', -1)
SQL> r
  1  select add_months('01-jul-99', -1)
  2* from dual

ADD_MONTH
---------
01-JUN-99
========================
返回一个日期之后的第一个星期几的日期：
SQL> select next_day('10-may-02', 'monday')
  2  from dual;

NEXT_DAY(
---------
13-MAY-02
===========================
返回当前日期所在月份的最后一天：
SQL> r
  1  select last_day('08-feb-02')
  2* from dual

LAST_DAY(
---------
28-FEB-02
按月份四舍五入之后该日期为以下日期：
SQL> select round(to_date('28-oct-01'), 'month')
  2  from dual;

ROUND(TO_
---------
01-NOV-01

==============================
日期按月份截断：
SQL> select trunc(to_date('28-oct-01'), 'month')
  2  from dual;

TRUNC(TO_
---------
01-OCT-01
=============================
日期按年截断：
SQL> select trunc(to_date('28-oct-01'), 'year')
  2  from dual;

TRUNC(TO_
---------
01-JAN-01
================================
建立月份值：
SQL> r  
  1  insert into e1
  2  (id, name, date1)
  3* values (1, 'b', '01-jul-01')

1 row created.
==================================
将月份转成固定格式字符串：
SQL> r
  1  select to_char(date1, 'DD/MM/YY'),to_char(date1, 'DAY/month/year')
  2* from e1

TO_CHAR( TO_CHAR(DATE1,'DAY/MONTH/YEAR')
--------
--------------------------------------------------------------------------------------------------
01/07/01 SUNDAY   /july     /two thousand one
=================================
SQL> r
  1  select to_char(date1, 'dd/mm/yy'), to_char(date1, 'day month year')
  2* from e1

TO_CHAR( TO_CHAR(DATE1,'DAYMONTHYEAR')
--------
--------------------------------------------------------------------------------------------------
01/07/01 sunday    july      two thousand one


===============================
SQL> r
  1  select to_char(date1, 'fmddspth "of" month year fmHH:MI:ss am')
  2* from e1

TO_CHAR(DATE1,'FMDDSPTH"OF"MONTHYEARFMHH:MI:SSAM')
----------------------------------------------------------------------------------------------------
first of july two thousand one 12:00:00 am

===================================
以金额的固定格式显示数字
SQL> select to_char(score*12,  '$99,999.00') money   
  2  from t2;

MONEY
-----------

    $864.00
    $792.00
    $780.00
  $1,032.00
    $672.00
==================================
分支判断执行函数：
以下语句表示，当member为020102，020103和020104时，分别decode函数的返回值分别是
将score乘以2，3，4，当member不是上述三个值时，则直接返回score
SQL> select member, decode(member, '020102', score*2
  2  ,'020103', score*3
  3  ,'020104', score*4
  4  , score)   
  5  "new_score"
  6  from t2;

MEMBER   new_score
------- ----------

010102          72
010103          66
010201          65
010101          86
010202          56
010202          56
010301          44
010302          78
010303          55
020101          79

MEMBER   new_score
------- ----------
020102         112
020103         207
020104         352
020201          54
020202          89
030101          75
030102          70


40101

21 rows selected.
=============================
函数嵌套并使用别名排序：
SQL> r
  1  select member, nvl(to_char(score), '0') "new_score"
  2  from t2
  3  where member is not null
  4* order by "new_score"

MEMBER  new_score
------- ----------------------------------------
40101   0
010301  44
020201  54
010303  55
020102  56
010202  56
010202  56
010201  65
010103  66
020103  69
030102  70

MEMBER  new_score
------- ----------------------------------------
010102  72
030101  75
010302  78
020101  79
010101  86
020104  88
020202  89

18 rows selected.

===========================
NVL2用法：
SQL> r   
  1  select nvl2(member, to_char(score + 100), '00') "score_new"
  2* from t2
表达式1不为空，则返回表达式2，否则返回表达式3，函数的返回值是表达2的类型
score_new
----------------------------------------
00
172
166
165
186
156
156
144
178
155
179

score_new
----------------------------------------
156
169
188
154
189
175
170
00
00


21 rows selected.
============================
检查两个值是否相等：不相等返回表达式1的值，相等则返回null
SQL> select * from t2;

G2_ID   G2_NAME         MEMBER       SCORE     SCORE2
------- --------------- ------- ---------- ----------
        ???                                        56
001001  qianduan        010102          72         56
001001  qianduan        010103          66         56
001002  lianji          010201          65         56
001001  qianduan        010101          86         56
001002  lianji          010202          56         56
001002  lianji          010202          56         56
001003  rizhong         010301          44         56
001003  rizhong         010302          78         56
001003  rizhong         010303          55         56
002001  qudao           020101          79         56

G2_ID   G2_NAME         MEMBER       SCORE     SCORE2
------- --------------- ------- ---------- ----------
002001  qudao           020102          56         56
002001  qudao           020103          69         56
002001  qudao           020104          88         56
002002  file            020201          54         56
002002  file            020202          89         56
003001  shuju           030101          75         56
003001  shuju           030102          70         56
1       ???                                        56
00_11_  escape                                     56
004001  Linshi          40101                      56

21 rows selected.

SQL> select nullif(score, score2)
  2  from t2;

NULLIF(SCORE,SCORE2)
--------------------

                  72
                  66
                  65
                  86


                  44
                  78
                  55
                  79

NULLIF(SCORE,SCORE2)
--------------------

                  69
                  88
                  54
                  89
                  75
                  70




21 rows selected.
============================
利用nvl2函数和nullif函数判断两列是否相等的结果：
SQL> r       
  1  select nvl2(nullif(score, score2), 'is not null', 'is null')
  2* from t2

NVL2(NULLIF
-----------
is null
is not null
is not null
is not null
is not null
is null
is null
is not null
is not null
is not null
is not null

NVL2(NULLIF
-----------
is null
is not null
is not null
is not null
is not null
is not null
is not null
is null
is null
is null

21 rows selected.
========================
返回直到不为空表达式函数：
SQL> select * from e3;

STR1  STR2  STR3  STR4
----- ----- ----- -----
11
21    22
31    32    33
41    42    43    44

SQL> select coalesce(str4, str3, str2, str1) 
  2  from e3;

COALE
-----
11
22
33
44
=================================
综合数据和分组函数：
SQL> select * from e3;

STR1  STR2  STR3  STR4
----- ----- ----- -----
11
21    22
31    32    33
41    42    43    44

SQL> select count(str1), count(str2), count(str3), count(str4)
  2  from e3;

COUNT(STR1) COUNT(STR2) COUNT(STR3) COUNT(STR4)
----------- ----------- ----------- -----------
          4           3           2           1
===================================
求和函数和求平均值函数：
SQL> select * from t2;

G2_ID   G2_NAME         MEMBER       SCORE     SCORE2
------- --------------- ------- ---------- ----------
        ???                                        56
001001  qianduan        010102          72         56
001001  qianduan        010103          66         56
001002  lianji          010201          65         56
001001  qianduan        010101          86         56
001002  lianji          010202          56         56
001002  lianji          010202          56         56
001003  rizhong         010301          44         56
001003  rizhong         010302          78         56
001003  rizhong         010303          55         56
002001  qudao           020101          79         56

G2_ID   G2_NAME         MEMBER       SCORE     SCORE2
------- --------------- ------- ---------- ----------
002001  qudao           020102          56         56
002001  qudao           020103          69         56
002001  qudao           020104          88         56
002002  file            020201          54         56
002002  file            020202          89         56
003001  shuju           030101          75         56
003001  shuju           030102          70         56
1       ???                                        56
00_11_  escape                                     56
004001  Linshi          40101                      56

SQL> r  
  1  select avg(score) avg, sum(score) sum, count(score) count,
  2  avg(score2) avg2, sum(score2) sum2, count(score2) count2
  3* from t2

       AVG        SUM      COUNT       AVG2       SUM2     COUNT2
---------- ---------- ---------- ---------- ---------- ----------
68.1176471       1158         17         56       1176         21
=========================
最大和最小值得函数：
SQL> r  
  1  select min(score) min_score,
  2  min(score2) min_score2,
  3  max(score) max_score, max(score2) max_score2
  4* from t2

 MIN_SCORE MIN_SCORE2  MAX_SCORE MAX_SCORE2
---------- ---------- ---------- ----------
        44         56         89         56
=========================
求字符串的最大最小值：
SQL> select max(g2_name) max, 
  2  min(g2_name) min
  3  from t2;

MAX             MIN
--------------- ---------------
???             Linshi
============================
按g2_id分组计算成员数量：
SQL> select g2_id, count(member) from t2 group by g2_id;

G2_ID   COUNT(MEMBER)
------- -------------
                    0
002002              2
1                   0
004001              1
001001              3
001003              3
002001              4
003001              2
001002              3
00_11_              0

10 rows selected.
==========================
分组统计数量之后再排序：
SQL> r
  1  select g2_id,
  2  count(member) "count_member"
  3  from t2
  4  group by g2_id
  5* order by "count_member"

G2_ID   count_member
------- ------------
1                  0
00_11_             0
                   0
004001             1
003001             2
002002             2
001003             3
001001             3
001002             3
002001             4

10 rows selected.
===================
使用函数组名进行group by排序：
SQL> r
  1  select g2_id,
  2  count(member) "count_member"
  3  from t2
  4  group by g2_id
  5* order by count(member)

G2_ID   count_member
------- ------------
1                  0
00_11_             0
                   0
004001             1
003001             2
002002             2
001003             3
001001             3
001002             3
002001             4

10 rows selected.
======================
group by + having用法：
SQL> r
  1  select g2_id, avg(score) avg_score
  2  from t2
  3  group by g2_id
  4* having avg(score) > 60

G2_ID    AVG_SCORE
------- ----------
002002        71.5
001001  74.6666667
002001          73
003001        72.5
=====================
正常不加having的结果，60以下和空均显示出来了
SQL> r
  1  select g2_id, avg(score) avg_score
  2  from t2
  3* group by g2_id

G2_ID    AVG_SCORE
------- ----------

002002        71.5
1
004001
001001  74.6666667
001003          59
002001          73
003001        72.5
001002          59
00_11_

10 rows selected.
===================
通过分组函数计算平均值，筛选需要的分组函数结果，再排序：
SQL> r
  1  select g2_id, avg(score) avg_score
  2  from t2
  3  group by g2_id
  4  having avg(score) > 60
  5* order by avg(score)

G2_ID    AVG_SCORE
------- ----------
002002        71.5
003001        72.5
002001          73
001001  74.6666667
=========================
对数据去掉不想要的原始筛选(where)，再根据分组求均值(agv函数＋group by)，再去掉分组均值中不想要的(having)
SQL> r
  1  select g2_id, avg(score) avg_score
  2  from t2
  3  where g2_id not like '003%'
  4  group by g2_id
  5  having avg(score) > 60
  6* order by avg(score)

G2_ID    AVG_SCORE
------- ----------
002002        71.5
002001          73
001001  74.6666667
===============================
分组函数最多只能嵌套两层，并且不能显示其他映射字段，因为有可能根据排序得到的最小值不唯一：
SQL> r
  1  select min(avg(score)),
  2  max(avg(score))
  3  from t2
  4* group by g2_id

MIN(AVG(SCORE)) MAX(AVG(SCORE))
--------------- ---------------
             59      74.6666667
===============================
count函数统计的结果不包括空值：
SQL> r
  1  select avg(score), avg(score2),
  2  sum(score), count(score), sum(score)/count(score), count(score2),
count(nvl(score, 0)),sum(score)/count(nvl(score, 0)), sum(nvl(score,
0))/count(nvl(score, 0))
  3* from t2

AVG(SCORE) AVG(SCORE2) SUM(SCORE) COUNT(SCORE) SUM(SCORE)/COUNT(SCORE)
COUNT(SCORE2) COUNT(NVL(SCORE,0))
---------- ----------- ---------- ------------ -----------------------
------------- -------------------
SUM(SCORE)/COUNT(NVL(SCORE,0)) SUM(NVL(SCORE,0))/COUNT(NVL(SCORE,0))
------------------------------ -------------------------------------
68.1176471          56       1158           17              68.1176471 21                  21
                    55.1428571                            55.1428571


============================================
联合查询，有重名字段必须显示用指定表明对象的方法表示要显示的列名：
SQL> r 
  1  select g1_id, g1_name, t1.g2_id, t1.g2_name, member, score, score2
  2  from t1, t2
  3  where t1.g2_id = t2.g2_id
  4* order by t1.g2_id

G1_ID   G1_NAME         G2_ID   G2_NAME         MEMBER       SCORE     SCORE2
------- --------------- ------- --------------- ------- ---------- ----------
001     yf01            001001  qianduan        010103          66         56
001     yf01            001001  qianduan        010102          72         56
001     yf01            001001  qianduan        010101          86         56
001     yf01            001002  lianji          010201          65         56
001     yf01            001002  lianji          010202          56         56
001     yf01            001002  lianji          010202          56         56
001     yf01            001003  rizhong         010302          78         56
001     yf01            001003  rizhong         010301          44         56
001     yf01            001003  rizhong         010303          55         56
002     yf02            002001  qudao           020101          79         56
002     yf02            002001  qudao           020102          56         56

G1_ID   G1_NAME         G2_ID   G2_NAME         MEMBER       SCORE     SCORE2
------- --------------- ------- --------------- ------- ---------- ----------
002     yf02            002001  qudao           020103          69         56
002     yf02            002001  qudao           020104          88         56
002     yf02            002002  file            020201          54         56
002     yf02            002002  file            020202          89         56
003     yf03            003001  shuju           030101          75         56
003     yf03            003001  shuju           030102          70         56

17 rows selected.
===============================
带条件的连接
SQL> r
  1  select g1_id, g1_name, t1.g2_id, t1.g2_name, member, score, score2
  2  from t1, t2
  3  where t1.g2_id = t2.g2_id
  4* and t2.score >= 60

G1_ID   G1_NAME         G2_ID   G2_NAME         MEMBER       SCORE     SCORE2
------- --------------- ------- --------------- ------- ---------- ----------
001     yf01            001001  qianduan        010102          72         56
001     yf01            001001  qianduan        010103          66         56
001     yf01            001002  lianji          010201          65         56
001     yf01            001001  qianduan        010101          86         56
001     yf01            001003  rizhong         010302          78         56
002     yf02            002001  qudao           020101          79         56
002     yf02            002001  qudao           020103          69         56
002     yf02            002001  qudao           020104          88         56
002     yf02            002002  file            020202          89         56
003     yf03            003001  shuju           030101          75         56
003     yf03            003001  shuju           030102          70         56

11 rows selected.
===========================
代别名的联合连接查询：
SQL> select a.g1_id, a.g1_name, a.g2_id, a.g2_name, b.member, b.score,
b.score2
  2  from t1 a, t2 b
  3  where a.g2_id = b.g2_id
  4  and b.score >= 60;

G1_ID   G1_NAME         G2_ID   G2_NAME         MEMBER       SCORE     SCORE2
------- --------------- ------- --------------- ------- ---------- ----------
001     yf01            001001  qianduan        010102          72         56
001     yf01            001001  qianduan        010103          66         56
001     yf01            001002  lianji          010201          65         56
001     yf01            001001  qianduan        010101          86         56
001     yf01            001003  rizhong         010302          78         56
002     yf02            002001  qudao           020101          79         56
002     yf02            002001  qudao           020103          69         56
002     yf02            002001  qudao           020104          88         56
002     yf02            002002  file            020202          89         56
003     yf03            003001  shuju           030101          75         56
003     yf03            003001  shuju           030102          70         56

11 rows selected.
=====================================
自连接：
SQL> desc work;
 Name                                      Null?    Type
 ----------------------------------------- --------
----------------------------
 ID                                                 VARCHAR2(10)
 NAME                                               VARCHAR2(10)
 JOB                                                VARCHAR2(10)
 MONEY                                              NUMBER(10)
 MANAGE                                             VARCHAR2(10)

SQL> select * from work;

ID         NAME       JOB             MONEY MANAGE
---------- ---------- ---------- ---------- ----------
01         boss       boss            10000 boss
02         manage01   manage           5000 boss
03         normal01   normal           2000 manage
04         normal02   normal           1900 manage

SQL> r 
  1  select a.id, a.name, a.job, a.money, a.manage
  2  from work a, work b
  3  where a.job=b.manage
  4* and b.manage='manage'

ID         NAME       JOB             MONEY MANAGE
---------- ---------- ---------- ---------- ----------
02         manage01   manage           5000 boss
02         manage01   manage           5000 boss

==========================
用between为条件的不等连接:
SQL> select * from money_t;

        ID        LOW      HIGHT
---------- ---------- ----------
         0       1000       2000

SQL> r
  1  select w.id, w.name, w.money, w.job
  2  from work w, money_t m
  3* where w.money between m.low and m.hight

ID         NAME            MONEY JOB
---------- ---------- ---------- ----------
03         normal01         2000 normal
04         normal02         1900 normal

=======================
外连接：
联合两张表当中相等的部分之外
a.name(+)=b.name表示，将a表中没有的，而b表中有的字段也显示出来
投影字段中表a没有的字段则显示为空
将＋放在数据少的那一边
SQL> select * from t2;

G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
---------- ---------- ---------- ---------- ----------
00         A          0001               60
00         A          0002               59
00         A          0003               61
01         B          0101               80
01         B          0102               90
02         C          0201              100

6 rows selected.

SQL> select * from t1;

G1_ID G1_NAME    G2_ID      G2_NAME
----- ---------- ---------- ----------
0     a          00         A
1     b          01         B

SQL> r
  1  select g1_id, g1_name, t1.g2_id, t1.g2_name
  2  , member, score, score2
  3  from t1, t2
  4* where t1.g2_id(+) = t2.g2_id

G1_ID G1_NAME    G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
----- ---------- ---------- ---------- ---------- ---------- ----------
0     a          00         A          0003               61
0     a          00         A          0002               59
0     a          00         A          0001               60
1     b          01         B          0102               90
1     b          01         B          0101               80
                                       0201              100

6 rows selected.

====================================
两张表的笛卡尔积连接，oracle方法和1999标准sql语法：
SQL> r
  1  select g1_id, g1_name, t1.g2_id, t1.g2_name
  2  , member, score, score2
  3  from t1
  4* cross join t2

G1_ID G1_NAME    G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
----- ---------- ---------- ---------- ---------- ---------- ----------
0     a          00         A          0001               60
0     a          00         A          0002               59
0     a          00         A          0003               61
0     a          00         A          0101               80
0     a          00         A          0102               90
0     a          00         A          0201              100
1     b          01         B          0001               60
1     b          01         B          0002               59
1     b          01         B          0003               61
1     b          01         B          0101               80
1     b          01         B          0102               90

G1_ID G1_NAME    G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
----- ---------- ---------- ---------- ---------- ---------- ----------
1     b          01         B          0201              100

12 rows selected.

SQL> r
  1  select g1_id, g1_name, t1.g2_id, t1.g2_name
  2  , member, score, score2
  3* from t1, t2

G1_ID G1_NAME    G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
----- ---------- ---------- ---------- ---------- ---------- ----------
0     a          00         A          0001               60
0     a          00         A          0002               59
0     a          00         A          0003               61
0     a          00         A          0101               80
0     a          00         A          0102               90
0     a          00         A          0201              100
1     b          01         B          0001               60
1     b          01         B          0002               59
1     b          01         B          0003               61
1     b          01         B          0101               80
1     b          01         B          0102               90

G1_ID G1_NAME    G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
----- ---------- ---------- ---------- ---------- ---------- ----------
1     b          01         B          0201              100

12 rows selected.
=======================
使用using的联合等同于相等连接查询：

表样例：
SQL> select * from t1;

G1_ID G1_NAME    G2_ID      G2_NAME
----- ---------- ---------- ----------
0     a          00         A
1     b          01         B
1+    b+         01         B+

SQL> select * from t2;

G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
---------- ---------- ---------- ---------- ----------
00         A          0001               60
00         A          0002               59
00         A          0003               61
01         B          0101               80
01         B          0102               90
02         C          0201              100

6 rows selected.

相等连接：
SQL> select g1_id, g1_name, t1.g2_id, t1.g2_name
  2  , member, score, score2
  3  from t1, t2
  4  where t1.g2_id = t2.g2_id;

G1_ID G1_NAME    G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
----- ---------- ---------- ---------- ---------- ---------- ----------
0     a          00         A          0001               60
0     a          00         A          0002               59
0     a          00         A          0003               61
1+    b+         01         B+         0101               80
1     b          01         B          0101               80
1+    b+         01         B+         0102               90
1     b          01         B          0102               90

7 rows selected.

使用using
SQL> r
  1  select g1_id, g1_name, g2_id, t1.g2_name
  2  , member, score, score2
  3  from t1
  4  join t2
  5  using(g2_id)
  6*

G1_ID G1_NAME    G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
----- ---------- ---------- ---------- ---------- ---------- ----------
0     a          00         A          0001               60
0     a          00         A          0002               59
0     a          00         A          0003               61
1+    b+         01         B+         0101               80
1     b          01         B          0101               80
1+    b+         01         B+         0102               90
1     b          01         B          0102               90

7 rows selected.


==========================
以上t1和t2不变，on语句用法：
SQL> select t1.g1_id, t1.g1_name, t1.g2_id, t1.g2_name
  2  , t2.member, t2.score, t2.score2
  3  from t1 
  4  join t2
  5  on (t1.g2_id = t2.g2_id);

G1_ID G1_NAME    G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
----- ---------- ---------- ---------- ---------- ---------- ----------
0     a          00         A          0001               60
0     a          00         A          0002               59
0     a          00         A          0003               61
1+    b+         01         B+         0101               80
1     b          01         B          0101               80
1+    b+         01         B+         0102               90
1     b          01         B          0102               90

7 rows selected.
==========================
on语句不带表明：
SQL> r
  1  select g1_id, g1_name, t1.g2_id, t1.g2_name,
  2  member, score, score2
  3  from t1
  4  join t2
  5  on(t1.g2_id = t2.g2_id)
  6*

G1_ID G1_NAME    G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
----- ---------- ---------- ---------- ---------- ---------- ----------
0     a          00         A          0001               60
0     a          00         A          0002               59
0     a          00         A          0003               61
1+    b+         01         B+         0101               80
1     b          01         B          0101               80
1+    b+         01         B+         0102               90
1     b          01         B          0102               90

7 rows selected.
===========================
多表连接和附加条件：
SQL> select * from t1;

G1_ID G1_NAME    G2_ID      G2_NAME
----- ---------- ---------- ----------
0     a          00         A
1     b          01         B
1+    b+         01         B+

SQL> select * from t2;

G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
---------- ---------- ---------- ---------- ----------
00         A          0001               60
00         A          0002               59
00         A          0003               61
01         B          0101               80
01         B          0102               90
02         C          0201              100

6 rows selected.

SQL> select * from t3;

ID   NAME       JOB        MANAGE
---- ---------- ---------- ----------
00   0001       boss       boss
01   0002       manage     boss
02   0003       normal     manage

SQL> r
  1  select g1_id, g1_name, t2.g2_id, t2.g2_name
  2  , member, score, score2, name, job, manage
  3  from t1
  4  join t2
  5  on t1.g2_id = t2.g2_id
  6  join t3
  7* on t2.member = t3.name

G1_ID G1_NAME    G2_ID      G2_NAME    MEMBER          SCORE     SCORE2 NAME JOB        MANAGE
----- ---------- ---------- ---------- ---------- ---------- ---------- ---------- ---------- ----------
0     a          00         A          0001               60            0001 boss       boss
0     a          00         A          0002               59            0002 manage     boss
0     a          00         A          0003               61            0003 normal     manage
=========================
相等连接，左连接和右连接：
相等：
SQL> r
  1  select g1_id, g1_name, t1.g2_id, t1.g2_name
  2  , member, score, score2
  3  from t1
  4  join t2
  5* on t1.g2_id = t2.g2_id

G1_ID G1_NAME    G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
----- ---------- ---------- ---------- ---------- ---------- ----------
0     a          00         A          0001               60
0     a          00         A          0002               59
0     a          00         A          0003               61
1+    b+         01         B+         0101               80
1     b          01         B          0101               80
1+    b+         01         B+         0102               90
1     b          01         B          0102               90
左连接和右连接：
SQL> r
  1  select g1_id, g1_name, t1.g2_id, t1.g2_name
  2  , member, score, score2
  3  from t1
  4  left outer join t2
  5* on t1.g2_id = t2.g2_id

G1_ID G1_NAME    G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
----- ---------- ---------- ---------- ---------- ---------- ----------
0     a          00         A          0001               60
0     a          00         A          0002               59
0     a          00         A          0003               61
1+    b+         01         B+         0101               80
1     b          01         B          0101               80
1+    b+         01         B+         0102               90
1     b          01         B          0102               90
3     d          03         D

8 rows selected.

SQL> 4    
  4* left outer join t2
SQL> c /left/right
  4* right outer join t2
SQL> r
  1  select g1_id, g1_name, t1.g2_id, t1.g2_name
  2  , member, score, score2
  3  from t1
  4  right outer join t2
  5* on t1.g2_id = t2.g2_id

G1_ID G1_NAME    G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
----- ---------- ---------- ---------- ---------- ---------- ----------
0     a          00         A          0003               61
0     a          00         A          0002               59
0     a          00         A          0001               60
1     b          01         B          0102               90
1     b          01         B          0101               80
1+    b+         01         B+         0102               90
1+    b+         01         B+         0101               80
                                       0201              100

8 rows selected.
====================
全连接：
SQL> c /right/full
  4* full outer join t2
SQL> r
  1  select g1_id, g1_name, t1.g2_id, t1.g2_name
  2  , member, score, score2
  3  from t1
  4  full outer join t2
  5* on t1.g2_id = t2.g2_id

G1_ID G1_NAME    G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
----- ---------- ---------- ---------- ---------- ---------- ----------
0     a          00         A          0001               60
0     a          00         A          0002               59
0     a          00         A          0003               61
1+    b+         01         B+         0101               80
1     b          01         B          0101               80
1+    b+         01         B+         0102               90
1     b          01         B          0102               90
                                       0201              100
3     d          03         D

9 rows selected.
=================================
子句查询：

SQL> select * from t2;

G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
---------- ---------- ---------- ---------- ----------
00         A          0001               60
00         A          0002               59
00         A          0003               61
01         B          0101               80
01         B          0102               90
02         C          0201              100

6 rows selected.
上述表查询成员0002同组名而且成绩大于成员0001的记录
SQL> r
  1  select * from t2
  2  where g2_id = (
  3  select g2_id from t2 where member = '0002')
  4  and score > (
  5* select score from t2 where member = '0001')

G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
---------- ---------- ---------- ---------- ----------
00         A          0003               61

显示成绩在平均成绩以下的记录：
SQL> select * from t2
  2  where score < ( 
  3  select avg(score) from t2);

G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
---------- ---------- ---------- ---------- ----------
00         A          0001               60
00         A          0002               59
00         A          0003               61

=============================
having子句中的单行子查询：
显示按g2_id分组平均中大于最小平均值的分组：
SQL> r  
  1  select min(score), max(score), avg(score), g2_id
  2  from t2
  3  group by g2_id
  4  having avg(score) >
  5  (select min(avg(score))
  6     from t2
  7*    group by g2_id)

MIN(SCORE) MAX(SCORE) AVG(SCORE) G2_ID
---------- ---------- ---------- ----------
        80         90         85 01
       100        100        100 02
=================================
from子句中单行子句用法：
先得到按g2_id分组的平均值
再按g2_id和表中score成绩进行比较，得到大于平均值的记录：
SQL> r
  1  select a.g2_id, g2_name, member, score, score2
  2  , avg
  3  from t2 a,
  4  (select g2_id, avg(score) avg from t2 group by g2_id) b
  5  where a.g2_id = b.g2_id
  6* and a.score > b.avg

G2_ID      G2_NAME    MEMBER          SCORE     SCORE2        AVG
---------- ---------- ---------- ---------- ---------- ----------
00         A          0003               61                    60
01         B          0102               90                    85

原始数据和未加限定条件大于平均值时情况如下：
SQL> select * from t2;

G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
---------- ---------- ---------- ---------- ----------
00         A          0001               60
00         A          0002               59
00         A          0003               61
01         B          0101               80
01         B          0102               90
02         C          0201              100

6 rows selected.

SQL> select a.g2_id, g2_name, member, score, score2
  2  , avg   
  3  from t2 a,
  4  (select g2_id, avg(score) avg from t2 group by g2_id)
  5  b                   
  6  where a.g2_id = b.g2_id;

G2_ID      G2_NAME    MEMBER          SCORE     SCORE2        AVG
---------- ---------- ---------- ---------- ---------- ----------
00         A          0001               60                    60
00         A          0002               59                    60
00         A          0003               61                    60
01         B          0101               80                    85
01         B          0102               90                    85
02         C          0201              100                   100

6 rows selected.

============================
找到按g2_id分组之后，每组中的最大值的记录：
SQL> r
  1  select a.g2_id, g2_name, member, score
  2  , b.max_score
  3  from t2 a,
  4  (select g2_id, max(score) max_score from t2 group by g2_id) b
  5  where a.g2_id = b.g2_id
  6* and a.score = b.max_score

G2_ID      G2_NAME    MEMBER          SCORE  MAX_SCORE
---------- ---------- ---------- ---------- ----------
00         A          0003               61         61
01         B          0102               90         90
02         C          0201              100        100

====================
多行子句：
通过in操作符的多行子句查询
先通过分组找到分组中的最大值
再通过主句将子句查询到的结果作为条件
找到每个分组当中的最大值记录：
SQL> r
  1  select * from t2
  2  where score in
  3  (select max(score) from t2
  4* group by g2_id)

G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
---------- ---------- ---------- ---------- ----------
00         A          0003               61
01         B          0102               90
02         C          0201              100

====================
子句用以g2_id作为分组，求出分组的平均值
主句再用all < 找到小于返回数据最小值的记录：
SQL> r
  1  select * from t2
  2  where score < all
  3* (select avg(score) from t2 group by g2_id)

G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
---------- ---------- ---------- ---------- ----------
00         A          0002               59
子句得到以g2_id作为分组，求出分组score平均值
主句用any < any找到score小于最大数据的记录：
any < 可理解为小于任意一个，也就是小于最大值
哪怕其余的值都大于都满足条件，所以即为小于最大值
SQL> r
  1  select * from t2
  2  where score >  any
  3* (select avg(score) from t2 group by g2_id)

G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
---------- ---------- ---------- ---------- ----------
02         C          0201              100
01         B          0102               90
01         B          0101               80
00         A          0003               61
==================
多列查询in：
子句按g2_id分组查score最大值和显示g2_id
主句按查到的g2_id和score最大值找所有记录：
子句显示结果如下
成对匹配：
SQL> r
  1* select g2_id, max(score) from t2 group by g2_id

G2_ID      MAX(SCORE)
---------- ----------
00                 61
01                 90
02                100

主句和子句组合之后如下
SQL> select * from t2 where (g2_id, score) in
  2  (select g2_id, max(score) from t2 group by g2_id);

G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
---------- ---------- ---------- ---------- ----------
00         A          0003               61
01         B          0102               90
02         C          0201              100
非成对匹配：
比成对匹配多了一条记录，因为g2_id和最大成绩是分别匹配的
两个集合中任意组合，而成对匹配是两个条件组合已经确定
SQL> select * from t2 where g2_id in (select distinct g2_id from t2)
  2  and score in (select max(score) from t2 group by g2_id);

G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
---------- ---------- ---------- ---------- ----------
01         B          0103               61
00         A          0003               61
01         B          0102               90
02         C          0201              100
=====================
当显示的记录超过一定行数时，则提示行数的数量：
默认6行
SQL> show feedback
FEEDBACK ON for 6 or more rows
改变行数显示设置：
SQL> set feedback 5 
SQL> r  
  1* select  * from t1 where g2_name is not null and g2_name != 'shuju'

G1_ID   G1_NAME         G2_ID   G2_NAME
------- --------------- ------- ---------------
001     yf01            001001  qianduan
001     yf01            001002  lianji
001     yf01            001003  rizhong
002     yf02            002001  qudao
002     yf02            002002  file

5 rows selected.
SQL> show feedback
FEEDBACK ON for 5 or more rows
==============================
SQL> column member clear 
SQL> column member
SP2-0046: COLUMN 'member' not defined
SQL> column heading member member1
SP2-0158: unknown COLUMN option "member"
SQL> column member heading member_1 for a9
SQL> column member
COLUMN   member ON
HEADING  'member_1'
FORMAT   a9
SQL> select * from t2;

G2_ID   G2_NAME         member_1       SCORE     SCORE2
------- --------------- --------- ---------- ----------
        ???                                          56
001001  qianduan        010102            72         56
001001  qianduan        010103            66         56
001002  lianji          010201            65         56
001001  qianduan        010101            86         56
001002  lianji          010202            56         56
001002  lianji          010202            56         56
001003  rizhong         010301            44         56
001003  rizhong         010302            78         56
001003  rizhong         010303            55         56
002001  qudao           020101            79         56

=========================
数字格式：
QL> column score for $999.99
SQL> select * from t2;

G2_ID   G2_NAME         member_1     SCORE     SCORE2
------- --------------- --------- -------- ----------
        ???                                        56
001001  qianduan        010102      $72.00         56
001001  qianduan        010103      $66.00         56

SQL> column score for $000,000.00
SQL> select * from t2;

G2_ID   G2_NAME         member_1         SCORE     SCORE2
------- --------------- --------- ------------ ----------
        ???                                            56
001001  qianduan        010102     $000,072.00         56
001001  qianduan        010103     $000,066.00         56
001002  lianji          010201     $000,065.00         56

本地化货币命令：
SQL> column score for L999,999.99
SQL> select * from t2;

G2_ID   G2_NAME         member_1                  SCORE     SCORE2
------- --------------- --------- --------------------- ----------
        ???                                                     56
001001  qianduan        010102                   $72.00         56
001001  qianduan        010103                   $66.00         56
001002  lianji          010201                   $65.00         56

====================
查询本用户名下所有的表：
SQL> l
  1  select table_name from user_tables
查看当前用户名有哪些可以操作的表：
SQL> l  
  1* select table_name from all_tables where owner not like '%sys'
查看当前用户所有表和属性：
SQL> l
  1  select * from user_catalog
catalog的别名查询办法：
SQL> l
  1  select * from cat
=========================
以下为数据库管理员应当关心内容：
以system数据库管理员登录数据，查看数据库的版本，创建时间和运行模式
SQL> r
  1  select name, created, log_mode
  2* from v$database

NAME      CREATED   LOG_MODE
--------- --------- ------------
ORCL      26-JAN-16 NOARCHIVELOG

实例信息：
SQL> select instance_name, host_name, version, archiver
  2  from v$instance;

INSTANCE_NAME
----------------
HOST_NAME
----------------------------------------------------------------
VERSION           ARCHIVE
----------------- -------
orcl
ctos
11.2.0.1.0        STOPPED

查看系统上有多少用户和创建日期：
SQL> select username, created  
  2  from dba_users;

USERNAME                       CREATED
------------------------------ ---------
MGMT_VIEW                      15-AUG-09
SYS                            15-AUG-09
SYSTEM                         15-AUG-09
DBSNMP                         15-AUG-09
SYSMAN                         15-AUG-09
SCOTT                          15-AUG-09
OUTLN                          15-AUG-09
FLOWS_FILES                    15-AUG-09
MDSYS                          15-AUG-09
ORDSYS                         15-AUG-09
EXFSYS                         15-AUG-09

USERNAME                       CREATED
------------------------------ ---------
WMSYS                          15-AUG-09
APPQOSSYS                      15-AUG-09
APEX_030200                    15-AUG-09
OWBSYS_AUDIT                   15-AUG-09
ORDDATA                        15-AUG-09
CTXSYS                         15-AUG-09
ANONYMOUS                      15-AUG-09
XDB                            15-AUG-09
ORDPLUGINS                     15-AUG-09
OWBSYS                         15-AUG-09
SI_INFORMTN_SCHEMA             15-AUG-09

USERNAME                       CREATED
------------------------------ ---------
OLAPSYS                        15-AUG-09
ORACLE_OCM                     15-AUG-09
XS$NULL                        15-AUG-09
BI                             26-JAN-16
PM                             26-JAN-16
MDDATA                         15-AUG-09
IX                             26-JAN-16
SH                             26-JAN-16
DIP                            15-AUG-09
OE                             26-JAN-16
APEX_PUBLIC_USER               15-AUG-09

USERNAME                       CREATED
------------------------------ ---------
HR                             26-JAN-16
SPATIAL_CSW_ADMIN_USR          15-AUG-09
SPATIAL_WFS_ADMIN_USR          15-AUG-09

36 rows selected.

=======================
创建数据库语句：
SQL> create table product   
  2     (p_code number(6),
  3     p_name varchar2(30),
  4     p_desc varchar2(100),
  5     p_price number(5,2));

Table created.

SQL> desc product
 Name                                      Null?    Type
 ----------------------------------------- --------
----------------------------
 P_CODE                                             NUMBER(6)
 P_NAME                                             VARCHAR2(30)
 P_DESC                                             VARCHAR2(100)
 P_PRICE                                            NUMBER(5,2)
==================
修改system的密码为manager：
SQL> alter user system identified by manager;
=======================
指定列名并用已存在的表创建新表：
SQL> r
  1  create table t22 (t2_g2_id ,
  2  t2_g2_name ,
  3  t2_member ,
  4  t2_score ,
  5  t2_score2 )
  6  as
  7  select g2_id, g2_name, member, score, score2
  8* from t2
i
Table created.

SQL>select * from t22;

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2
------- --------------- ------- ---------- ----------
002001  qudao           020102          56         56
002001  qudao           020103          69         56
002001  qudao           020104          88         56
002002  file            020201          54         56
002002  file            020202          89         56
003001  shuju           030101          75         56
003001  shuju           030102          70         56
1       ???                                        56
00_11_  escape                                     56
004001  Linshi          40101                      56

21 rows selected.

SQL> drop table t22;

Table dropped.

======================
增加列：
SQL> r
  1* alter table t22 add (add1 varchar2(1))

Table altered.
=========================
修改列属性：
SQL> alter table t22
  2  modify (add1 varchar2(2));

Table altered.

SQL> desc t22;
 Name                                      Null?    Type
 ----------------------------------------- --------
----------------------------
 T2_G2_ID                                           VARCHAR2(7)
 T2_G2_NAME                                         VARCHAR2(15)
 T2_MEMBER                                          VARCHAR2(7)
 T2_SCORE                                           NUMBER(4)
 T2_SCORE2                                          NUMBER(2)
 ADD1                                               VARCHAR2(2)

SQL> alter table t22
  2  modify (add1 varchar2(1));

Table altered.

SQL> desc t22;
 Name                                      Null?    Type
 ----------------------------------------- --------
----------------------------
 T2_G2_ID                                           VARCHAR2(7)
 T2_G2_NAME                                         VARCHAR2(15)
 T2_MEMBER                                          VARCHAR2(7)
 T2_SCORE                                           NUMBER(4)
 T2_SCORE2                                          NUMBER(2)
 ADD1                                               VARCHAR2(1)
====================
对t22增加一列日期类型
SQL> alter table t22
  2  add (date1 date);

Table altered.

修改日期类型列的默认值是系统时间
SQL> alter table t22
  2  modify (date1 default sysdate);

对数据插入一条日期的列是默认值
SQL> insert into t22
  2  (date1)
  3  values(default);

1 row created.

显示插入的内容：
SQL> select * from t22;

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A DATE1
------- --------------- ------- ---------- ---------- - ---------
...
004001  Linshi          40101                      56
                                                        20-DEC-16

22 rows selected.
====================
删除列：
删除前：
SQL> desc t22;
 Name                                      Null?    Type
 ----------------------------------------- --------
----------------------------
 T2_G2_ID                                           VARCHAR2(7)
 T2_G2_NAME                                         VARCHAR2(15)
 T2_MEMBER                                          VARCHAR2(7)
 T2_SCORE                                           NUMBER(4)
 T2_SCORE2                                          NUMBER(2)
 ADD1                                               VARCHAR2(1)
 DATE1                                              DATE
删除操作：
SQL> alter table t22
  2  drop column date1;

Table altered.

删除后：
SQL> desc t22;
 Name                                      Null?    Type
 ----------------------------------------- --------
----------------------------
 T2_G2_ID                                           VARCHAR2(7)
 T2_G2_NAME                                         VARCHAR2(15)
 T2_MEMBER                                          VARCHAR2(7)
 T2_SCORE                                           NUMBER(4)
 T2_SCORE2                                          NUMBER(2)
 ADD1                                               VARCHAR2(1)
===================
标记列为不用列和删除不用列：
多次执行删除未用列不违反任何错误，没有就等于不删；
未用列没有逆向操作命令:
SQL> alter table t22
  2  set unused (date1);

Table altered.

SQL> select * from t22;

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A
------- --------------- ------- ---------- ---------- -
        ???                                        56
001001  qianduan        010102          72         56
001001  qianduan        010103          66         56
001002  lianji          010201          65         56
001001  qianduan        010101          86         56
001002  lianji          010202          56         56
001002  lianji          010202          56         56
001003  rizhong         010301          44         56
001003  rizhong         010302          78         56
001003  rizhong         010303          55         56
002001  qudao           020101          79         56

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A
------- --------------- ------- ---------- ---------- -
002001  qudao           020102          56         56
002001  qudao           020103          69         56
002001  qudao           020104          88         56
002002  file            020201          54         56
002002  file            020202          89         56
003001  shuju           030101          75         56
003001  shuju           030102          70         56
1       ???                                        56
00_11_  escape                                     56
004001  Linshi          40101                      56


T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A
------- --------------- ------- ---------- ---------- -



24 rows selected.

SQL> desc t22;
 Name                                      Null?    Type
 ----------------------------------------- --------
----------------------------
 T2_G2_ID                                           VARCHAR2(7)
 T2_G2_NAME                                         VARCHAR2(15)
 T2_MEMBER                                          VARCHAR2(7)
 T2_SCORE                                           NUMBER(4)
 T2_SCORE2                                          NUMBER(2)
 ADD1                                               VARCHAR2(1)

SQL> alter table t22  
  2  drop unused column;

==================
修改表名字：
SQL> rename t22 to t23;

Table renamed.

修改列名字：
SQL> alter table t22
  2  rename column add2 to add1;

Table altered.
=========================
给表格添加注释：
SQL> comment on table t22
  2  is 'this is exercise';

Comment created.

查看表格注释：
SQL> select comments  
  2  from user_tab_comments
  3  where table_name = 'T22';

COMMENTS
--------------------------------------------------------------------------------
this is exercise

注意表格名字已经用单引号括起来了，区分大小写
像下面这样执行，得不到想查找的结果：
SQL> select comments 
  2  from user_tab_comments
  3  where table_name = 't22';

no rows selected
=========================
给表列添加注释：
SQL> comment on column t22.t2_g2_id
  2  is 'this is group id';

Comment created.

查看表列注释：
SQL> r
  1  select comments
  2  from user_col_comments
  3  where table_name = 'T22'
  4* and column_name = 'T2_G2_ID'

COMMENTS
--------------------------------------------------------------------------------
this is group id

注意查询时的字段使用单引号括起来的，是区分大小写的
像下面这样执行，是得不到想查找的结果的
SQL> select comments
  2  from user_col_comments
  3  where table_name = 't22'
  4  and column_name = 't2_g2_id';

no rows selected

=======================
删除注释只能通过添加空注释的方式，没有删除注释命令
SQL> comment on table t22
  2  is '';
SQL> select comments
  2  from user_tab_comments
  3  where table_name = 'T22';

COMMENTS
--------------------------------------------------------------------------------

=============================
根据t22新创建一个表，再清空表：
SQL> create table t222
  2  as
  3  select * from t22;

Table created.

SQL> select * from t222;

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A DATE1
------- --------------- ------- ---------- ---------- - ---------
        ???                                        56
001001  qianduan        010102          72         56
001001  qianduan        010103          66         56
001002  lianji          010201          65         56
001001  qianduan        010101          86         56
001002  lianji          010202          56         56
001002  lianji          010202          56         56
001003  rizhong         010301          44         56
001003  rizhong         010302          78         56
001003  rizhong         010303          55         56
002001  qudao           020101          79         56

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A DATE1
------- --------------- ------- ---------- ---------- - ---------
002001  qudao           020102          56         56
002001  qudao           020103          69         56
002001  qudao           020104          88         56
002002  file            020201          54         56
002002  file            020202          89         56
003001  shuju           030101          75         56
003001  shuju           030102          70         56
1       ???                                        56
00_11_  escape                                     56
004001  Linshi          40101                      56
                                                        20-DEC-16

22 rows selected.

SQL> truncete table t222;

Table truncated.

查询表没有数据：
SQL> select * from t222;

no rows selected

查询表结构，表结构还在：
SQL> desc t222;
 Name                                      Null?    Type
 ----------------------------------------- --------
----------------------------
 T2_G2_ID                                           VARCHAR2(7)
 T2_G2_NAME                                         VARCHAR2(15)
 T2_MEMBER                                          VARCHAR2(7)
 T2_SCORE                                           NUMBER(4)
 T2_SCORE2                                          NUMBER(2)
 ADD1                                               VARCHAR2(1)
 DATE1                                              DATE

============================
删除表：
SQL> drop table t222;

Table dropped.

SQL> desc t222;
ERROR:
ORA-04043: object t222 does not exist

========================
创建并复制表结构：
下列语句表示创建一个表t222，通过查找表t22创建
而表t22的条件是1=2，此条件永远为假，所以只复制成功了表结构
SQL> create table t222 as select * from t22 where 1=2;

Table created.

SQL> desc t222;
 Name                                      Null?    Type
 ----------------------------------------- --------
----------------------------
 T2_G2_ID                                           VARCHAR2(7)
 T2_G2_NAME                                         VARCHAR2(15)
 T2_MEMBER                                          VARCHAR2(7)
 T2_SCORE                                           NUMBER(4)
 T2_SCORE2                                          NUMBER(2)
 ADD1                                               VARCHAR2(1)
 DATE1                                              DATE

=======================
以＆开头的替代变量：
SQL> r  
  1  select * from t22
  2* where t2_score > &v_score
Enter value for v_score: 60
old   2: where t2_score > &v_score
new   2: where t2_score > 60

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A DATE1
------- --------------- ------- ---------- ---------- - ---------
001001  qianduan        010102          72         56
001001  qianduan        010103          66         56
001002  lianji          010201          65         56
001001  qianduan        010101          86         56
001003  rizhong         010302          78         56
002001  qudao           020101          79         56
002001  qudao           020103          69         56
002001  qudao           020104          88         56
002002  file            020202          89         56
003001  shuju           030101          75         56
003001  shuju           030102          70         56

11 rows selected.

当运行时系统会提示输入要查找的数字比例
======================
开启变量显示原值功能：
SQL> set verify on
SQL> r
  1  select * from t22
  2* where t2_score > &v_score
Enter value for v_score: 60
old   2: where t2_score > &v_score
new   2: where t2_score > 60

========================
字符串变量记得输入单引号：
SQL> r
  1  select * from t22
  2* where t2_g2_name > &v_name
Enter value for v_name: 'qianduan'

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A DATE1
------- --------------- ------- ---------- ---------- - ---------
        ???                                        56
001003  rizhong         010301          44         56
001003  rizhong         010302          78         56
001003  rizhong         010303          55         56
002001  qudao           020101          79         56
002001  qudao           020102          56         56
002001  qudao           020103          69         56
002001  qudao           020104          88         56
003001  shuju           030101          75         56
003001  shuju           030102          70         56
1       ???                                        56

11 rows selected.

=======================
或是直接在脚本的变量两端加上单引号：
SQL> r
  1  select * from t22
  2* where t2_g2_name > '&v_name'
Enter value for v_name: qianduan

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A DATE1
------- --------------- ------- ---------- ---------- - ---------
        ???                                        56
001003  rizhong         010301          44         56
001003  rizhong         010302          78         56
001003  rizhong         010303          55         56
002001  qudao           020101          79         56
002001  qudao           020102          56         56
002001  qudao           020103          69         56
002001  qudao           020104          88         56
003001  shuju           030101          75         56
003001  shuju           030102          70         56
1       ???                                        56

11 rows selected.

======================
&变量名：每次都要重新输入值
&&只需要第一执行的时候输入变量值，以后再执行会自动用以前的旧值
SQL> r
  1  select * from t22
  2* where t2_g2_name > '&&v_name'
Enter value for v_name: qianduan

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A DATE1
------- --------------- ------- ---------- ---------- - ---------
        ???                                        56
001003  rizhong         010301          44         56
001003  rizhong         010302          78         56
001003  rizhong         010303          55         56
002001  qudao           020101          79         56
002001  qudao           020102          56         56
002001  qudao           020103          69         56
002001  qudao           020104          88         56
003001  shuju           030101          75         56
003001  shuju           030102          70         56
1       ???                                        56

11 rows selected.

========================
将变量当作列值：
SQL> select &value from t22;
Enter value for value: *

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A DATE1
------- --------------- ------- ---------- ---------- - ---------
        ???                                        56
001001  qianduan        010102          72         56
001001  qianduan        010103          66         56
001002  lianji          010201          65         56
001001  qianduan        010101          86         56
001002  lianji          010202          56         56
001002  lianji          010202          56         56
001003  rizhong         010301          44         56
001003  rizhong         010302          78         56
001003  rizhong         010303          55         56
002001  qudao           020101          79         56

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A DATE1
------- --------------- ------- ---------- ---------- - ---------
002001  qudao           020102          56         56
002001  qudao           020103          69         56
002001  qudao           020104          88         56
002002  file            020201          54         56
002002  file            020202          89         56
003001  shuju           030101          75         56
003001  shuju           030102          70         56
1       ???                                        56
00_11_  escape                                     56
004001  Linshi          40101                      56
                                                        20-DEC-16

22 rows selected.

SQL> r  
  1* select &value from t22
Enter value for value: t2_g2_id

T2_G2_I
-------

001001
001001
001002
001001
001002
001002
001003
001003
001003
002001

T2_G2_I
-------
002001
002001
002001
002002
002002
003001
003001
1
00_11_
004001


22 rows selected.
====================
变量做表达式：
SQL> r  
  1* select * from t22 where &condition
Enter value for condition: t2_g2_id = '003001'

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A DATE1
------- --------------- ------- ---------- ---------- - ---------
003001  shuju           030101          75         56
003001  shuju           030102          70         56

=======================
define命令的运用：
SQL> define value
SP2-0135: symbol value is UNDEFINED
SQL> define value = t2_g2_id
SQL> define value 
DEFINE VALUE           = "t2_g2_id" (CHAR)
SQL> select &value from t22;

T2_G2_I
-------

001001
001001
001002
001001
001002
001002
001003
001003
001003
002001

T2_G2_I
-------
002001
002001
002001
002002
002002
003001
003001
1
00_11_
004001


22 rows selected.
=================
查看定义的全部变量：
SQL> define
DEFINE _DATE           = "21-DEC-16" (CHAR)
DEFINE _CONNECT_IDENTIFIER = "orcl" (CHAR)
DEFINE _USER           = "SYS" (CHAR)
DEFINE _PRIVILEGE      = "AS SYSDBA" (CHAR)
DEFINE _SQLPLUS_RELEASE = "1102000100" (CHAR)
DEFINE _EDITOR         = "ed" (CHAR)
DEFINE _O_VERSION      = "Oracle Database 11g Enterprise Edition Release
11.2.0.1.0 - 64bit Production
With the Partitioning, OLAP, Data Mining and Real Application Testing options"
(CHAR)
DEFINE _O_RELEASE      = "1102000100" (CHAR)
DEFINE V_NAME          = "qianduan" (CHAR)
DEFINE VALUE           = "t2_g2_id" (CHAR)
======================
带提示设置变量命令accept：
[oracle@ctos oracle]$ cat tmp.sql 
ACCEPT v_name PROMPT 'please enter the v_name tible:'
select * from t22
where t2_g2_name = '&v_name'
/
SQL> @tmp
please enter the v_name tible:qianduan

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A DATE1
------- --------------- ------- ---------- ---------- - ---------
001001  qianduan        010102          72         56
001001  qianduan        010103          66         56
001001  qianduan        010101          86         56
======================
隐藏输入的内容的accept命令：
accept + prompt + hide
[oracle@ctos oracle]$ cat passwd.sql 
accept pwd prompt 'please enter your password:' hide
select * from t22
where '&pwd' = 'manage'
/
SQL> @passwd
please enter your password:

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A DATE1
------- --------------- ------- ---------- ---------- - ---------
        ???                                        56
001001  qianduan        010102          72         56
001001  qianduan        010103          66         56
001002  lianji          010201          65         56
001001  qianduan        010101          86         56
001002  lianji          010202          56         56
001002  lianji          010202          56         56
001003  rizhong         010301          44         56
001003  rizhong         010302          78         56
001003  rizhong         010303          55         56
002001  qudao           020101          79         56

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A DATE1
------- --------------- ------- ---------- ---------- - ---------
002001  qudao           020102          56         56
002001  qudao           020103          69         56
002001  qudao           020104          88         56
002002  file            020201          54         56
002002  file            020202          89         56
003001  shuju           030101          75         56
003001  shuju           030102          70         56
1       ???                                        56
00_11_  escape                                     56
004001  Linshi          40101                      56
                                                        20-DEC-16

22 rows selected.
============================
插入空值的方法，字符串可以用''，也可以用null表示，或是干脆不插入任何in值
SQL> insert into t222
  2  (t2_g2_id, t2_g2_name, t2_member, t2_score, t2_score2)
  3  values ('004003', '',  null, null, null);

1 row created.

SQL> select * from t222 where t2_g2_id = '004003';

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A DATE1
------- --------------- ------- ---------- ---------- - ---------
004003

===========================
通过另外一个表创建表：
SQL> create table t222    
  2  as
  3  select * from t22;

Table created.

SQL> select * from t222;

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A DATE1
------- --------------- ------- ---------- ---------- - ---------
        ???                                        56
001001  qianduan        010102          72         56
001001  qianduan        010103          66         56
001002  lianji          010201          65         56
001001  qianduan        010101          86         56
001002  lianji          010202          56         56
001002  lianji          010202          56         56
001003  rizhong         010301          44         56
001003  rizhong         010302          78         56
001003  rizhong         010303          55         56
002001  qudao           020101          79         56

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A DATE1
------- --------------- ------- ---------- ---------- - ---------
002001  qudao           020102          56         56
002001  qudao           020103          69         56
002001  qudao           020104          88         56
002002  file            020201          54         56
002002  file            020202          89         56
003001  shuju           030101          75         56
003001  shuju           030102          70         56
1       ???                                        56
00_11_  escape                                     56
004001  Linshi          40101                      56
                                                        20-DEC-16

22 rows selected.

=====================
清空t222表，并通过查询子句插入另外一张表达的内容：
SQL> truncate table t222;

Table truncated.

SQL> select * from t222;

no rows selected

执行完命令如下：
SQL> insert into t222    
  2  select * from t22;

22 rows created.

SQL> select * from t222;

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A DATE1
------- --------------- ------- ---------- ---------- - ---------
        ???                                        56
001001  qianduan        010102          72         56
001001  qianduan        010103          66         56
001002  lianji          010201          65         56
001001  qianduan        010101          86         56
001002  lianji          010202          56         56
001002  lianji          010202          56         56
001003  rizhong         010301          44         56
001003  rizhong         010302          78         56
001003  rizhong         010303          55         56
002001  qudao           020101          79         56

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A DATE1
------- --------------- ------- ---------- ---------- - ---------
002001  qudao           020102          56         56
002001  qudao           020103          69         56
002001  qudao           020104          88         56
002002  file            020201          54         56
002002  file            020202          89         56
003001  shuju           030101          75         56
003001  shuju           030102          70         56
1       ???                                        56
00_11_  escape                                     56
004001  Linshi          40101                      56
                                                        20-DEC-16

22 rows selected.

==============================
利用替代变量向数据库中插入数据：
SQL> r
  1  insert into t222
  2  (t2_g2_id, t2_g2_name, t2_member, t2_score, t2_score2, add1, date1)
  3* values ('&g2_id', '&g2_name', '&member', &score, &score, '&a',
to_date('&date1', 'YYYYMMDD'))
Enter value for g2_id: 004004
Enter value for g2_name: 44nn
Enter value for member: 44nn
Enter value for score: 57
Enter value for score: 57
Enter value for a: 1
Enter value for date1: 20161222

1 row created.

将sqlplus中的内容存成脚本文件，replace是覆盖原有文件内容：
SQL> save tmp replace
Wrote file tmp.sql

SQL> select * from t222 where t2_g2_id = '004004';

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A DATE1
------- --------------- ------- ---------- ---------- - ---------
004004  44nn            44nn            57         57 1 22-DEC-16
===================
利用accept命令生成带提示的替代变量的脚本：
[oracle@ctos oracle]$ cat tmp.sql 
accept g2_id prompt 'please enter g2_id:'
accept g2_name prompt 'please enter g2_name:'
accept member prompt 'please enter member:'
accept score prompt 'please enter score:'
accept a prompt 'please enter add1:'
accept date1 prompt 'please enter date1 format YYYYMMDD:'
insert into t222
(t2_g2_id, t2_g2_name, t2_member, t2_score, t2_score2, add1, date1)
values ('&g2_id', '&g2_name', '&member', &score, &score, '&a',
to_date('&date1', 'YYYYMMDD'))
/
SQL> @tmp 
please enter g2_id:004006
please enter g2_name:0406
please enter member:0406
please enter score:61
please enter add1:3
please enter date1 format YYYYMMDD:20161222

1 row created.

SQL> select * from t222 where t2_g2_id = '004006';

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A DATE1
------- --------------- ------- ---------- ---------- - ---------
004006  0406            0406            61         61 3 22-DEC-16
============================
将一列清空，再改变字段大小，重新赋值之后，再将重新赋值之后的数字缩小0.9倍之后重新赋值：
SQL> update t222 set t222 = null;
update t222 set t222 = null
                *
ERROR at line 1:
ORA-00904: "T222": invalid identifier


SQL> update t222 set t2_score2 = null;

25 rows updated.

SQL> select * from t222;

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A DATE1
------- --------------- ------- ---------- ---------- - ---------
        ???
001001  qianduan        010102          65
001001  qianduan        010103          59
001002  lianji          010201          59
001001  qianduan        010101          77
001002  lianji          010202          50
001002  lianji          010202          50
001003  rizhong         010301          40
001003  rizhong         010302          70
001003  rizhong         010303          50
002001  qudao           020101          71

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A DATE1
------- --------------- ------- ---------- ---------- - ---------
002001  qudao           020102          50
002001  qudao           020103          62
002001  qudao           020104          79
002002  file            020201          49
002002  file            020202          80
003001  shuju           030101          68
003001  shuju           030102          63
1       ???
00_11_  escape
004001  Linshi          40101
                                                        20-DEC-16

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A DATE1
------- --------------- ------- ---------- ---------- - ---------
004004  44nn            44nn            51            1 22-DEC-16
004005  004005          004005          52            2 22-DEC-16
004006  0406            0406            55            3 22-DEC-16

25 rows selected.

SQL> alter table t222   
  2  modify (t2_score2 varchar2(3));

Table altered.

SQL> update t222 set t2_score2 = 100;

25 rows updated.

SQL> select * from t222;

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE T2_ A DATE1
------- --------------- ------- ---------- --- - ---------
        ???                                100
001001  qianduan        010102          65 100
001001  qianduan        010103          59 100
001002  lianji          010201          59 100
001001  qianduan        010101          77 100
001002  lianji          010202          50 100
001002  lianji          010202          50 100
001003  rizhong         010301          40 100
001003  rizhong         010302          70 100
001003  rizhong         010303          50 100
002001  qudao           020101          71 100

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE T2_ A DATE1
------- --------------- ------- ---------- --- - ---------
002001  qudao           020102          50 100
002001  qudao           020103          62 100
002001  qudao           020104          79 100
002002  file            020201          49 100
002002  file            020202          80 100
003001  shuju           030101          68 100
003001  shuju           030102          63 100
1       ???                                100
00_11_  escape                             100
004001  Linshi          40101              100
                                           100   20-DEC-16

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE T2_ A DATE1
------- --------------- ------- ---------- --- - ---------
004004  44nn            44nn            51 100 1 22-DEC-16
004005  004005          004005          52 100 2 22-DEC-16
004006  0406            0406            55 100 3 22-DEC-16

25 rows selected.

SQL> update t222 set t2_score2 = t2_score2 * 0.9;

25 rows updated.

SQL> select * from t222;

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE T2_ A DATE1
------- --------------- ------- ---------- --- - ---------
        ???                                90
001001  qianduan        010102          65 90
001001  qianduan        010103          59 90
001002  lianji          010201          59 90
001001  qianduan        010101          77 90
001002  lianji          010202          50 90
001002  lianji          010202          50 90
001003  rizhong         010301          40 90
001003  rizhong         010302          70 90
001003  rizhong         010303          50 90
002001  qudao           020101          71 90

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE T2_ A DATE1
------- --------------- ------- ---------- --- - ---------
002001  qudao           020102          50 90
002001  qudao           020103          62 90
002001  qudao           020104          79 90
002002  file            020201          49 90
002002  file            020202          80 90
003001  shuju           030101          68 90
003001  shuju           030102          63 90
1       ???                                90
00_11_  escape                             90
004001  Linshi          40101              90
                                           90    20-DEC-16

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE T2_ A DATE1
------- --------------- ------- ---------- --- - ---------
004004  44nn            44nn            51 90  1 22-DEC-16
004005  004005          004005          52 90  2 22-DEC-16
004006  0406            0406            55 90  3 22-DEC-16

25 rows selected.

SQL> desc t222;
 Name                                      Null?    Type
 ----------------------------------------- --------
----------------------------
 T2_G2_ID                                           VARCHAR2(7)
 T2_G2_NAME                                         VARCHAR2(15)
 T2_MEMBER                                          VARCHAR2(7)
 T2_SCORE                                           NUMBER(4)
 T2_SCORE2                                          VARCHAR2(3)
 ADD1                                               VARCHAR2(1)
 DATE1                                              DATE

============================
修改两列：
SQL> select * from t222 where t2_g2_id = '004001';

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE T2_ A DATE1
------- --------------- ------- ---------- --- - ---------
004001  Linshi          40101              90
                                           90    20-DEC-16

SQL> update t222 set t2_g2_name = 'linshi'                    
  2  , t2_member = '040101' 
  3  where t2_g2_id = '004001';

1 row updated.

SQL> select * from t222 where t2_g2_id = '004001';

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE T2_ A DATE1
------- --------------- ------- ---------- --- - ---------
004001  linshi          040101             90
==============================
带查询子句的update语句：

SQL> r
  1  update t222 set t2_score = (select low from tab_score)
  2* where t2_score > (select low from tab_score)

20 rows updated.


SQL> select * from t222;

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE T2_ A DATE1
------- --------------- ------- ---------- --- - ---------
        ???                                90
001001  qianduan        010102          60 90
001001  qianduan        010103          60 90
001002  lianji          010201          60 90
001001  qianduan        010101          60 90
001002  lianji          010202          60 90
001002  lianji          010202          60 90
001003  rizhong         010301          60 90
001003  rizhong         010302          60 90
001003  rizhong         010303          60 90
002001  qudao           020101          60 90

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE T2_ A DATE1
------- --------------- ------- ---------- --- - ---------
002001  qudao           020102          60 90
002001  qudao           020103          60 90
002001  qudao           020104          60 90
002002  file            020201          60 90
002002  file            020202          60 90
003001  shuju           030101          60 90
003001  shuju           030102          60 90
1       ???                                90
00_11_  escape                             90
004001  linshi          040101             90
                                           90    20-DEC-16

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE T2_ A DATE1
------- --------------- ------- ---------- --- - ---------
004004  44nn            44nn            60 90  1 22-DEC-16
004005  004005          004005          60 90  2 22-DEC-16
004006  0406            0406            60 90  3 22-DEC-16

25 rows selected.

SQL> select * from tab_score;

     HIGHT        LOW I
---------- ---------- -
       100         60 1

===========================
带多列查询子句的update：
SQL> r
  1  update t222 set (t2_score, t2_score2) = (
  2* select low, hight from tab_score where id = '1')

25 rows updated.

SQL> select * from t222;

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE T2_ A DATE1
------- --------------- ------- ---------- --- - ---------
        ???                             60 100
001001  qianduan        010102          60 100
001001  qianduan        010103          60 100
001002  lianji          010201          60 100
001001  qianduan        010101          60 100
001002  lianji          010202          60 100
001002  lianji          010202          60 100
001003  rizhong         010301          60 100
001003  rizhong         010302          60 100
001003  rizhong         010303          60 100
002001  qudao           020101          60 100

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE T2_ A DATE1
------- --------------- ------- ---------- --- - ---------
002001  qudao           020102          60 100
002001  qudao           020103          60 100
002001  qudao           020104          60 100
002002  file            020201          60 100
002002  file            020202          60 100
003001  shuju           030101          60 100
003001  shuju           030102          60 100
1       ???                             60 100
00_11_  escape                          60 100
004001  linshi          040101          60 100
                                        60 100   20-DEC-16

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE T2_ A DATE1
------- --------------- ------- ---------- --- - ---------
004004  44nn            44nn            60 100 1 22-DEC-16
004005  004005          004005          60 100 2 22-DEC-16
004006  0406            0406            60 100 3 22-DEC-16

25 rows selected.

========================
多条件删除语句：
SQL> insert into t222 
  2  (t2_g2_id, t2_score) 
  3  values ('005001', 70);

1 row created.

SQL> select * from t222
  2  where t2_g2_id = '005001';

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE T2_ A DATE1
------- --------------- ------- ---------- --- - ---------
005001                                  70

SQL> delete t222 where t2_g2_id = '005001'
  2  and t2_score = 70;

1 row deleted.

SQL> select * from t222 where t2_g2_id = '005001';

no rows selected

或执行：
SQL> delete from t222 where t2_g2_id = '005001';

1 row deleted.


==============
查看sqlplus所有的设置：
SQL> show all
appinfo is OFF and set to "SQL*Plus"
arraysize 15
autocommit OFF
autoprint OFF
autorecovery OFF
autotrace OFF
blockterminator "." (hex 2e)
btitle OFF and is the first few characters of the next SELECT statement
cmdsep OFF
colsep " "
compatibility version NATIVE
concat "." (hex 2e)
copycommit 0
COPYTYPECHECK is ON
define "&" (hex 26)
describe DEPTH 1 LINENUM OFF INDENT ON
echo OFF
editfile "afiedt.buf"
embedded OFF
escape OFF
escchar OFF
exitcommit ON
FEEDBACK ON for 6 or more rows
flagger OFF
flush ON
heading ON
headsep "|" (hex 7c)
instance "local"
linesize 80
lno 9
loboffset 1
logsource ""
long 80
longchunksize 80
markup HTML OFF HEAD "<style type='text/css'> body {font:10pt
Arial,Helvetica,sans-serif; color:black; background:White;} p {font:10pt
Arial,Helvetica,sans-serif; color:black; background:White;} table,tr,td
{font:10pt Arial,Helvetica,sans-serif; color:Black; background:#f7f7e7;
padding:0px 0px 0px 0px; margin:0px 0px 0px 0px;} th {font:bold 10pt
Arial,Helvetica,sans-serif; color:#336699; background:#cccc99; padding:0px 0px
0px 0px;} h1 {font:16pt Arial,Helvetica,Geneva,sans-serif; color:#336699;
background-color:White; border-bottom:1px solid #cccc99; margin-top:0pt;
margin-bottom:0pt; padding:0px 0px 0px 0px;-
} h2 {font:bold 10pt Arial,Helvetica,Geneva,sans-serif; color:#336699;
background-color:White; margin-top:4pt; margin-bottom:0pt;} a {font:9pt
Arial,Helvetica,sans-serif; color:#663300; background:#ffffff; margin-top:0pt;
margin-bottom:0pt; vertical-align:top;}</style><title>SQL*Plus Report</title>"
BODY "" TABLE "border='1' width='90%' align='center' summary='Script output'"
SPOOL OFF ENTMAP ON PREFORMAT OFF
newpage 1
null ""
numformat ""
numwidth 10
pagesize 14
PAUSE is OFF
pno 3
recsep WRAP
recsepchar " " (hex 20)
release 1102000100
repfooter OFF and is NULL
repheader OFF and is NULL
securedcol is OFF
serveroutput OFF
shiftinout INVISIBLE
showmode OFF
spool ON
sqlblanklines OFF
sqlcase MIXED
sqlcode 0
sqlcontinue "> "
sqlnumber ON
sqlpluscompatibility 11.2.0
sqlprefix "#" (hex 23)
sqlprompt "SQL> "
sqlterminator ";" (hex 3b)
suffix "sql"
tab ON
termout ON
timing OFF
trimout ON
trimspool OFF
ttitle OFF and is the first few characters of the next SELECT statement
underline "-" (hex 2d)
USER is "SYS"
verify OFF
wrap : lines will be wrapped
errorlogging is OFF
==================
设置自动提交之后，执行dml之后，命令显示自动提交
SQL> set autocommit on
SQL> update t222 set t2_score2 = 75 where t2_g2_id = '005001';

1 row updated.

Commit complete.
=====================
创建索引方法：
建表：
SQL> select * from t1;

G1_ID G1_NAME    G2_ID      G2_NAME
----- ---------- ---------- ----------
0     a          00         A
1     b          01         B
1+    b+         01         B+
3     d          03         D

SQL> select * from t2;

G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
---------- ---------- ---------- ---------- ----------
00         A          0001               60
00         A          0002               59
00         A          0003               61
01         B          0101               80
01         B          0102               90
02         C          0201              100
01         B          0103               61

7 rows selected.

SQL> create table t22 
  2  as
  3  select * from t2 where 1=2;

Table created.

SQL> desc t22;
 Name                                      Null?    Type
 ----------------------------------------- --------
----------------------------
 G2_ID                                              VARCHAR2(10)
 G2_NAME                                            VARCHAR2(10)
 MEMBER                                             VARCHAR2(10)
 SCORE                                              NUMBER(4)
 SCORE2                                             NUMBER(4)

SQL> select * from t22;

no rows selected

建索引：
给表t22的g2_id字段，添加上名为t22_g2_id的索引：
SQL> create index t22_g2_id
  2  on t22(g2_id);

Index created.

查询索引，在user_indexes表中查询表名为T22的索引信息
注意表名区分大小写：
SQL> col index_type for a10
SQL> col index_name for a10
SQL> r
  1   select index_name, index_type, table_name,
  2  uniqueness
  3   from user_indexes
  4*  where table_name = 'T22'

INDEX_NAME INDEX_TYPE TABLE_NAME                     UNIQUENES
---------- ---------- ------------------------------ ---------
T22_G2_ID  NORMAL     T22                            NO
在user_ind_columns表中，查询索引对应的列的情况：
SQL> r
  1   select index_name, table_name, column_name
  2   , column_position
  3   from user_ind_columns
  4* where table_name = 'T22'

INDEX_NAME TABLE_NAME                     COLUMN_NAME     COLUMN_POSITION
---------- ------------------------------ --------------- ---------------
T22_G2_ID  T22                            G2_ID                         1

==========================
表删除之后，表的索引在索引表中也没有了：
SQL> drop table t22;

Table dropped.

SQL> select index_name, table_name, column_name 
  2  , column_position
  3  from user_ind_columns
  4  where table_name = 'T22';

no rows selected

========================
组合索引的建立：
重新建表如下，变动以前列的位置，为稍后验证column_position显示的结果作准备
SQL> r 
  1  create table t22
  2  as
  3* select member, score, g2_name, g2_id, score2 from t2 where 2=1

Table created.

SQL> select * from t22;

no rows selected

SQL> desc t22;
 Name
Null?    Type
 -----------------------------------------------------------------------------------------------------------------
--------
----------------------------------------------------------------------------
 MEMBER
VARCHAR2(10)
 SCORE
NUMBER(4)
 G2_NAME
VARCHAR2(10)
 G2_ID
VARCHAR2(10)
 SCORE2
NUMBER(4)

SQL> create index t22_g2_id_and_name
  2  on t22(g2_id, g2_name);

Index created.

查询索引位置可以看到，column_position显示的列在索引中的位置，而并非是索引所在列在表中的位置
SQL> select index_name, table_name, column_name, column_position
  2  from user_ind_columns
  3  where table_name = 'T22';

INDEX_NAME           TABLE_NAME      COLUMN_NAME     COLUMN_POSITION
-------------------- --------------- --------------- ---------------
T22_G2_ID_AND_NAME   T22             G2_NAME                       2
T22_G2_ID_AND_NAME   T22             G2_ID                         1

======================
索引的删除：
SQL> drop index T22_G2_ID_AND_NAME;

Index dropped.

===========================
建立函数索引：

SQL> create index t22_score_sub_20
  2  on t22(score - 20);

Index created.

查询索引信息：
SQL> get tmp
  1  select index_name, index_type, table_name, uniqueness
  2  from user_indexes
  3* where table_name = 'T22'
SQL> /

INDEX_NAME           INDEX_TYPE                TABLE_NAME      UNIQUENESS
-------------------- ------------------------- ---------------
--------------------
T22_SCORE_SUB_20     FUNCTION-BASED NORMAL     T22             NONUNIQUE

查询索引和列对应的信息：
SQL> select index_name, table_name, column_name, column_position
  2  from user_ind_columns
  3  where table_name = 'T22';

INDEX_NAME           TABLE_NAME      COLUMN_NAME     COLUMN_POSITION
-------------------- --------------- --------------- ---------------
T22_SCORE_SUB_20     T22             SYS_NC00006$                  1

============================
SQL> @/home/oracle/app/oracle/product/11.2.0/dbhome_1/rdbms/admin/utlxplan.sql

SQL> explain plan for
  2  select g2_id    
  3  from t22
  4  where (score - 20) < 0;

Explained.

SQL> column id for 999
SQL> column operation for a20
SQL> column options for a15
SQL> column object_name for a18
SQL> r
  1  select id, operation, options, object_name, position
  2* from plan_table

  ID OPERATION            OPTIONS         OBJECT_NAME          POSITION
---- -------------------- --------------- ------------------ ----------
   0 SELECT STATEMENT                                                 0
   1 TABLE ACCESS         BY INDEX ROWID  T22                         1
   2 INDEX                RANGE SCAN      T22_SCORE_SUB_20            1

=========================
SQL> truncate table plan_table;

Table truncated.


SQL> insert into t22 
  2  values('001', 20, '001', '001', 21);

1 row created.

SQL> select * from t22;

MEMBER          SCORE G2_NAME    G2_ID          SCORE2
---------- ---------- ---------- ---------- ----------
001                20 001        001                21


SQL> r
  1  select member, score, g2_name, g2_id, score2
  2  from t22
  3* where (score - 20) >= 0

MEMBER          SCORE G2_NAME    G2_ID          SCORE2
---------- ---------- ---------- ---------- ----------
001                20 001        001                21


=================
++约束：
++非空not null
SQL> alter table t22
  2  modify g2_id not null;

Table altered.

++查看表结构：
SQL> desc t22;
 Name
Null?    Type
 -----------------------------------------------------------------------------------------------------------------
--------
----------------------------------------------------------------------------
 MEMBER
VARCHAR2(10)
 SCORE
NUMBER(4)
 G2_NAME
VARCHAR2(10)
 G2_ID
NOT NULL VARCHAR2(10)
 SCORE2
NUMBER(4)

++验证空值插入：
SQL> insert into t22
  2  (g2_id, member)
  3  values('', 21);
values('', 21)
       *
ERROR at line 3:
ORA-01400: cannot insert NULL into ("SYS"."T22"."G2_ID")
++update验证是否允许空值：
SQL> update t22 
  2  set g2_id = '';
set g2_id = ''
    *
ERROR at line 2:
ORA-01407: cannot update ("SYS"."T22"."G2_ID") to NULL


SQL> update t22
  2  set g2_id = null;
set g2_id = null
    *
ERROR at line 2:
ORA-01407: cannot update ("SYS"."T22"."G2_ID") to NULL

无论是char型还是varchar型，空值的检查条件都是is null

===================
查看表的约束：
SQL> r
  1  select owner, constraint_name, constraint_type
  2  , table_name
  3  from user_constraints
  4* where table_name = 'T22'

OWNER      CONSTRAINT_NAME                C TABLE_NAME
---------- ------------------------------ - ----------
SYS        SYS_C0011294                   C T22

==================
查看约束对应的表和列：
SQL> r
  1  select owner, constraint_name, table_name,
  2  column_name
  3  from user_cons_columns
  4* where table_name = 'T22'

OWNER      CONSTRAINT_NAME                TABLE_NAME COLUMN_NAME
---------- ------------------------------ ---------- ---------------
SYS        SYS_C0011294                   T22        G2_ID
====================
++删除约束：
SQL> alter table t22 
  2  drop constraint SYS_C0011294;

Table altered.

查询表结构t22没有了非空条件：
SQL> desc t22;
 Name
Null?    Type
 -----------------------------------------------------------------------------------------------------------------
--------
----------------------------------------------------------------------------
 MEMBER
VARCHAR2(10)
 SCORE
NUMBER(4)
 G2_NAME
VARCHAR2(10)
 G2_ID
VARCHAR2(10)
 SCORE2
NUMBER(4)

查询约束表中也没有了t22表的约束：
SQL> r
  1  select owner, constraint_name, table_name,
  2  column_name
  3  from user_cons_columns
  4* where table_name = 'T22'

no rows selected

=========================
++唯一约束：

在表t22中添加唯一条件约束：
SQL> alter table t22
  2  add constraint t22_unique unique(g2_id);

Table altered.

++查看表结构，其中没有表示唯一条件的约束，这也验证了，只有非空条件才是列级的约束：
SQL> desc t22;
 Name
Null?    Type
 -----------------------------------------------------------------------------------------------------------------
--------
----------------------------------------------------------------------------
 MEMBER
VARCHAR2(10)
 SCORE
NUMBER(4)
 G2_NAME
VARCHAR2(10)
 G2_ID
VARCHAR2(10)
 SCORE2
NUMBER(4)

++查看约束与表和列之间的关系：
SQL> select owner, constraint_name, table_name, column_name
  2  from user_cons_columns
  3  where table_name = 'T22';

OWNER      CONSTRAINT_NAME                TABLE_NAME COLUMN_NAME
---------- ------------------------------ ---------- ---------------
SYS        T22_UNIQUE                     T22        G2_ID

++验证唯一约束：
当表中已经存在g2_id为001的记录时，再添加001就报范围唯一约束条件错误：
SQL> select * from t22;

MEMBER          SCORE G2_NAME    G2_ID                    SCORE2
---------- ---------- ---------- -------------------- ----------
001                20 001        001                          21

SQL> insert into t22
  2  (g2_id) values ('001');
insert into t22
*
ERROR at line 1:
ORA-00001: unique constraint (SYS.T22_UNIQUE) violated

++查询唯一条件约束用户表，查看t22表的唯一条件约束：
SQL> column seach_condition for a23
SQL> column constraint_name for a20
SQL> select owner, constraint_name, constraint_type,
  2  table_name, search_condition
  3  from user_constraints 
  4  where table_name = 'T22';

OWNER      CONSTRAINT_NAME      C TABLE_NAME SEARCH_CONDITION
---------- -------------------- - ----------
--------------------------------------------------------------------------------
SYS        T22_UNIQUE           U T22


++验证唯一约束unique是否允许插入空值和多列空值：
空值属于不确定，不确定不能与确定或者另外一个不确定比较得到确定的结果
所以空值允许插入，并且允许插入多个
SQL> insert into t22
  2  (member, g2_id) values ('002', '');

1 row created.

SQL> l  
  1  insert into t22
  2* (member, g2_id) values ('002', '')
SQL> c /002/003
  2* (member, g2_id) values ('003', '')
SQL> r
  1  insert into t22
  2* (member, g2_id) values ('003', '')

1 row created.

SQL> select * from t22;

MEMBER          SCORE G2_NAME    G2_ID                    SCORE2
---------- ---------- ---------- -------------------- ----------
001                20 001        001                          21
002
003

=========================
条件检查约束：
SQL> r  
  1  create table person(
  2  id varchar2(10),
  3  name varchar2(20),
  4  gender char(1),
  5  age number,
  6  constraint person_gender_ck
  7     check(gender = 'F'),
  8  constraint person_age_ck
  9     check(age between 18 and 35)
 10* )

Table created.

设置要查询的表列宽：
SQL> column owner for a8
SQL> column constrant_name for a20
SQL> column table_name for a10
SQL> column search_condition for a25

查询约束表内容，查看关于表person的约束内容：
SQL> r
  1  select owner, constraint_name, constraint_type, table_name,
  2  search_condition
  3  from user_constraints
  4* where table_name = 'PERSON'

OWNER    CONSTRAINT_NAME                C TABLE_NAME SEARCH_CONDITION
-------- ------------------------------ - ---------- -------------------------
SYS      PERSON_GENDER_CK               C PERSON     gender = 'F'
SYS      PERSON_AGE_CK                  C PERSON     age between 18 and 35

==========================
验证约束有效性：
性别男不符合要求
SQL> r
  1  insert into person
  2  (id, name, gender, age)
  3* values('01', 'natasha', 'M', 30)
insert into person
*
ERROR at line 1:
ORA-02290: check constraint (SYS.PERSON_GENDER_CK) violated

年龄不符合要求
SQL> r
  1  insert into person
  2  (id, name, gender, age)
  3* values('01', 'natasha', 'F', 36)
insert into person
*
ERROR at line 1:
ORA-02290: check constraint (SYS.PERSON_AGE_CK) violated

=========================
++主键约束：
++当数据没有主键的列有重复记录，向该列添加主键违反约束的
++删除之后，重新添加通过添加了
SQL> select * from person;

ID         NAME                 G        AGE
---------- -------------------- - ----------
01         natasha              F         19
01         natasha              F         30

++第一次添加主键约束因列有重复记录失败：
SQL> alter table person   
  2  add constraint person_id_pk   
  3     primary key(id);
add constraint person_id_pk
               *
ERROR at line 2:
ORA-02437: cannot validate (SYS.PERSON_ID_PK) - primary key violated


SQL> delete person where age = 30;

1 row deleted.

Commit complete.

++再次添加主键约束，成功了
SQL> select * from person;

ID         NAME                 G        AGE
---------- -------------------- - ----------
01         natasha              F         19

SQL> alter table person
  2  add constraint person_id_pk
  3     primary key(id);

Table altered.

++向表插入重复id列重复的列记录，会提示违反唯一约束的提示：
SQL> insert into person
  2  (id, name, gender, age)
  3  values ('01', 'natasha', 'F', 20);
insert into person
*
ERROR at line 1:
ORA-00001: unique constraint (SYS.PERSON_ID_PK) violated

++再次插入主键所在的列为空值，显示违反非空约束：
SQL> r
  1  insert into person
  2  (id, name, gender, age)
  3* values ('', 'natasha', 'F', 20)
values ('', 'natasha', 'F', 20)
        *
ERROR at line 3:
ORA-01400: cannot insert NULL into ("SYS"."PERSON"."ID")

==========================
++主键约束属性查询：
SQL> r
  1  select owner, constraint_name, constraint_type, table_name,
  2     search_condition
  3  from user_constraints
  4* where table_name = 'PERSON'

OWNER    CONSTRAINT_NAME                C TABLE_NAME SEARCH_CONDITION
-------- ------------------------------ - ---------- -------------------------
SYS      PERSON_GENDER_CK               C PERSON     gender = 'F'
SYS      PERSON_AGE_CK                  C PERSON     age between 18 and 35
SYS      PERSON_ID_PK                   P PERSON


++查看主键约束与表和列之间的关系：
SQL> col column_name for a10
SQL> select owner, constraint_name, table_name, column_name, position 
  2  from user_cons_columns
  3  where table_name = 'PERSON';

OWNER    CONSTRAINT_NAME                TABLE_NAME COLUMN_NAM   POSITION
-------- ------------------------------ ---------- ---------- ----------
SYS      PERSON_GENDER_CK               PERSON     GENDER
SYS      PERSON_AGE_CK                  PERSON     AGE
SYS      PERSON_ID_PK                   PERSON     ID                  1

++查询主键的唯一索引的属性：
SQL> select index_name, index_type, table_name, uniqueness
  2  from user_indexes
  3  where table_name = 'PERSON';

INDEX_NAME           INDEX_TYPE TABLE_NAME UNIQUENES
-------------------- ---------- ---------- ---------
PERSON_ID_PK         NORMAL     PERSON     UNIQUE

++查询主键的唯一索引，对应的表和列信息：

SQL> column column_name for a15
SQL> select index_name, table_name, column_name, column_position
  2  from user_ind_columns
  3  where table_name = 'PERSON';

INDEX_NAME           TABLE_NAME COLUMN_NAME     COLUMN_POSITION
-------------------- ---------- --------------- ---------------
PERSON_ID_PK         PERSON     ID                            1

++说明：创建唯一约束和创建包合唯一约束的主键，都会自动创建一个唯一约束索引。

++创建主键：
SQL> alter table t1111
  2  add constraint t1111_g2id_pk
  3  primary key (g2_id);

Table altered.


++删除主键
SQL> alter table t1111
  2  drop constraint T1111_G2ID_PK;

Table altered.

=======================
外键：
创建表t2222
SQL> create table t2222
  2  as
  3  select * from t2 where 1=2;

Table created.

SQL> select * from t2222;

no rows selected

SQL> desc t2222;
 Name                                      Null?    Type
 ----------------------------------------- --------
----------------------------
 G2_ID                                              VARCHAR2(7)
 G2_NAME                                            VARCHAR2(15)
 MEMBER                                             VARCHAR2(7)
 SCORE                                              NUMBER(4)
 SCORE2                                             NUMBER(2)

++创建表t1111
SQL> create table t1111
  2  as
  3  select * from t1 where 1=2;

Table created.

++创建表t1111主键:
SQL> alter table t1111  
  2  add constraint t1111_g2id_pk
  3  primary key(g2_id);

Table altered.

++查看创建主键属性:
SQL> select constraint_name, constraint_type, table_name
  2  from user_constraints
  3  where table_name = 'T1111';

CONSTRAINT_NAME      C TABLE_NAME
-------------------- - --------------------
T1111_G2ID_PK        P T1111

++创建t2222的外键:
SQL> alter table t2222
  2  add constraint t2222_g2id_t1111_fk
  3  foreign key(g2_id) references t1111(g2_id);

Table altered.

++查看t2222的外键属性:
SQL> r
  1  select constraint_name, table_name, r_constraint_name, constraint_type
  2  from user_constraints
  3* where table_name = 'T2222'

CONSTRAINT_NAME      TABLE_NAME           R_CONSTRAINT_NAME              C
-------------------- -------------------- ------------------------------ -
T2222_G2ID_T1111_FK  T2222                T1111_G2ID_PK                  R

++注意:一定要创建带名字的主键和外键,让约束的名字显示的确定

===============
＋＋验证外键：
++向主表当中插入数据：
SQL> insert into t1111
  2  values('001001', 'A', '010101', 'AA');

1 row created.

Commit complete.

++查询主表内容：
SQL> select * from t1111;

G1_ID   G1_NAME         G2_ID   G2_NAME
------- --------------- ------- ---------------
001001  A               010101  AA

++向从表当中插入两条合法内容：
SQL> insert into t2222
  2  values('010101', 'AA', 'AA01', 60, 60);

1 row created.

Commit complete.

SQL> r  
  1  insert into t2222
  2* values('010101', 'AA', 'AA02', 60, 60)

1 row created.

Commit complete.

++查询从表内容：
SQL> select * from t2222;

G2_ID   G2_NAME         MEMBER       SCORE     SCORE2
------- --------------- ------- ---------- ----------
010101  AA              AA01            60         60
010101  AA              AA02            60         60

＋＋向从表插入非法内容：
SQL> r
  1  insert into t2222
  2* values('010102', 'AA', 'AA02', 60, 60)
insert into t2222
*
ERROR at line 1:
ORA-02291: integrity constraint (SYS.T2222_G2ID_T1111_FK) violated - parent
key
not found

++通过以上过程可以验证，只有在主表主键有该值的时候
++从表才能以该值作为字段值，插入了相应的值得
++并且插入的值是可以重复的

++再增加t1111记录的新值，使主键增加一条新记录：
SQL> insert into t1111
  2  values('001001', 'AA', '010102', 'BB');

1 row created.

Commit complete.

查看表t1111内容：
SQL> select * from t1111;

G1_ID   G1_NAME         G2_ID   G2_NAME
------- --------------- ------- ---------------
001001  A               010101  AA
001001  AA              010102  BB

++再想从表插入以表t1111主键新增值为外键值的记录，成功了：
SQL> r
  1  insert into t2222
  2* values('010102', 'AA', 'AA02', 60, 60)

1 row created.

Commit complete.

++查看表t2222内容：
SQL> select * from t2222;

G2_ID   G2_NAME         MEMBER       SCORE     SCORE2
------- --------------- ------- ---------- ----------
010101  AA              AA01            60         60
010101  AA              AA02            60         60
010102  AA              AA02            60         60

++外键总结：
＋＋外键是以另外主表的主键为约束的约束方式，可以重复插入主表主键当中出现的值，但必须是存在的，不存在的将被限制。

==================
++删除对外键的影响：
SQL> r
  1* delete t1111 where g2_id = '010102'
delete t1111 where g2_id = '010102'
*
ERROR at line 1:
ORA-02292: integrity constraint (SYS.T2222_G2ID_T1111_FK) violated - child
record found


++删除从表同值主键对弈姑娘的记录：
SQL> delete t2222 where g2_id = '010102';

1 row deleted.

Commit complete.
SQL> select * from t2222;

G2_ID   G2_NAME         MEMBER       SCORE     SCORE2
------- --------------- ------- ---------- ----------
010101  AA              AA01            60         60
010101  AA              AA02            60         60

再次删除主表当中的同值字段：
SQL> delete t1111 where g2_id = '010102';

1 row deleted.

Commit complete.
SQL> select * from t1111;

G1_ID   G1_NAME         G2_ID   G2_NAME
------- --------------- ------- ---------------
001001  A               010101  AA

已经允许删除！

＋＋当从表中有对主表的引用，主表不允许删除有外键引用的主表记录
＋＋反之，主表可以删除无从表引用的主键记录
＋＋从表则可以随意删除表中记录。

=============================
++外键对update的影响：
直接将从表的内容修改成从表外键所对应的主键值时，报违反约束：
SQL> update t2222 set g2_id = '010202' where g2_id = '010201';
update t2222 set g2_id = '010202' where g2_id = '010201'
*
ERROR at line 1:
ORA-02291: integrity constraint (SYS.T2222_G2ID_T1111_FK) violated - parent
key not found

＋＋直接对主表修改有从表外键引用的值时，报违反完整性约束：
SQL> r  
  1* update t1111 set g2_id = '020101' where g2_id = '010201'
update t1111 set g2_id = '020101' where g2_id = '010201'
*
ERROR at line 1:
ORA-02292: integrity constraint (SYS.T2222_G2ID_T1111_FK) violated - child
record found

++修改前内容：
SQL> select * from t1111;

G1_ID   G1_NAME         G2_ID   G2_NAME
------- --------------- ------- ---------------
001001  A               010101  AA
001002  BB              010201  BB01

SQL> select * from t2222;

G2_ID   G2_NAME         MEMBER       SCORE     SCORE2
------- --------------- ------- ---------- ----------
010101  AA              AA01            60         60
010101  AA              AA02            60         60
010201  BB              BB01            61         62


++将从表外键所在内容修改成空值：
++从表未添加非空约束，且非空为不确定，从表允许非空与主表比对，得到不确定结果
SQL> update t2222 set g2_id = null where g2_id = '010201';

1 row updated.

Commit complete.

++查看内容：
SQL> select * from t2222;

G2_ID   G2_NAME         MEMBER       SCORE     SCORE2
------- --------------- ------- ---------- ----------
010101  AA              AA01            60         60
010101  AA              AA02            60         60
        BB              BB01            61         62

++这时主表已经没有了从表的引用，将主表的值修改成想修改的值：
SQL> update t1111 set g2_id = '020101' where g2_id = '010201';

1 row updated.

Commit complete.
++查看主表内容：
SQL> select * from t1111 where g2_id = '020101';

G1_ID   G1_NAME         G2_ID   G2_NAME
------- --------------- ------- ---------------
001002  BB              020101  BB01

++现在将从表的外键值，修改成主表刚修改成的值：
SQL> select * from t2222 where g2_id is null;

G2_ID   G2_NAME         MEMBER       SCORE     SCORE2
------- --------------- ------- ---------- ----------
        BB              BB01            61         62

SQL> update t2222 set g2_id = '020101' where g2_id is null;

1 row updated.

Commit complete.
++查看从表结果：
SQL> select * from t2222 where g2_id = '020101';

G2_ID   G2_NAME         MEMBER       SCORE     SCORE2
------- --------------- ------- ---------- ----------
020101  BB              BB01            61         62

++最后别忘记提交：
++修改后内容：
SQL> select * from t2222;

G2_ID   G2_NAME         MEMBER       SCORE     SCORE2
------- --------------- ------- ---------- ----------
010101  AA              AA01            60         60
010101  AA              AA02            60         60
020101  BB              BB01            61         62

SQL> select * from t1111;

G1_ID   G1_NAME         G2_ID   G2_NAME
------- --------------- ------- ---------------
001001  A               010101  AA
001002  BB              020101  BB01

==================
++外键对ddl的影响：
SQL> drop table t1111;
drop table t1111
           *
ERROR at line 1:
ORA-02449: unique/primary keys in table referenced by foreign keys


SQL> truncate table t1111;
truncate table t1111
               *
ERROR at line 1:
ORA-02266: unique/primary keys in table referenced by enabled foreign keys

++因为主表被从表引用，所以不允许对主表进行操作
==========================
++外键的修改：只能通过删除和重新增加的办法实现对外键的修改：
++删除重新创建外键：
++首先将外键设置的属性设置成删除规则为置空，即当主表删除外键对应的从表记录时
＋＋从表对应的值设置成空值null
SQL> alter table t2222
  2  drop constraint T2222_G2ID_T1111_FK;

Table altered.

SQL> alter table t2222
  2  add constraint T2222_G2ID_T1111_FK
  3  foreign key(g2_id) references t1111(g2_Id)
  4  on delete set null;

Table altered.

++查看新建的外键属性：
SQL> column delete_rule for a20
SQL> r
  1  select table_name, constraint_type, constraint_name, delete_rule, r_constraint_name
  2  from user_constraints
  3* where table_name = 'T2222'

TABLE_NAME           C CONSTRAINT_NAME                DELETE_RULE          R_CONSTRAINT_NAME
-------------------- - ------------------------------ -------------------- ------------------------------
T2222                R T2222_G2ID_T1111_FK            SET NULL             T1111_G2ID_PK     

＋＋查看主表与从表的内容：
SQL> select * from t1111;

G1_ID   G1_NAME         G2_ID   G2_NAME
------- --------------- ------- ---------------
001001  A               010101  AA
001002  BB              020101  BB01

SQL> select * from t2222;

G2_ID   G2_NAME         MEMBER       SCORE     SCORE2
------- --------------- ------- ---------- ----------
010101  AA              AA01            60         60
010101  AA              AA02            60         60
020101  BB              BB01            61         62

＋＋删除主表内容：
SQL> delete t1111 where g2_id = '020101';

1 row deleted.

++主表内容发生了变化
SQL> select * from t1111;

G1_ID   G1_NAME         G2_ID   G2_NAME
------- --------------- ------- ---------------
001001  A               010101  AA

++从表内容发生了变化
SQL> select * from t2222;

G2_ID   G2_NAME         MEMBER       SCORE     SCORE2
------- --------------- ------- ---------- ----------
010101  AA              AA01            60         60
010101  AA              AA02            60         60
        BB              BB01            61         62

++回滚恢复以前未删除主表数据之前的状态，准备后边的试验
SQL> rollback;

Rollback complete.

＋＋查看主表和从表的内容，回滚成功：
SQL> select * from t1111;

G1_ID   G1_NAME         G2_ID   G2_NAME
------- --------------- ------- ---------------
001001  A               010101  AA
001002  BB              020101  BB01

SQL> select * from t2222;

G2_ID   G2_NAME         MEMBER       SCORE     SCORE2
------- --------------- ------- ---------- ----------
010101  AA              AA01            60         60
010101  AA              AA02            60         60
020101  BB              BB01            61         62

===========================
＋＋设置将外键的属性设置成级联
＋＋即当主表删除从表对应的主表的主键属性时，从表同时删除从表中对应的记录：
＋＋删除后重新插入外键，同时设置成删除规则为级联
SQL> alter table t2222
  2  drop constraint T2222_G2ID_T1111_FK;

Table altered.

SQL> alter table t2222   
  2  add constraint T2222_G2ID_T1111_FK
  3  foreign key(g2_id) references t1111(g2_id)
  4  on delete cascade;

Table altered.

＋＋查看外键属性，可以看到dlete_rule为级联属性：
SQL> select table_name, constraint_type, constraint_name, delete_rule, r_constraint_name
  2  from user_constraints
  3  where table_name = 'T2222';

TABLE_NAME           C CONSTRAINT_NAME                DELETE_RULE          R_CONSTRAINT_NAME
-------------------- - ------------------------------ -------------------- ------------------------------
T2222                R T2222_G2ID_T1111_FK            CASCADE              T1111_G2ID_PK

＋＋未删除之前查看主表和从表：

SQL> select * from t1111;

G1_ID   G1_NAME         G2_ID   G2_NAME
------- --------------- ------- ---------------
001001  A               010101  AA
001002  BB              020101  BB01

SQL> select * from t2222;

G2_ID   G2_NAME         MEMBER       SCORE     SCORE2
------- --------------- ------- ---------- ----------
010101  AA              AA01            60         60
010101  AA              AA02            60         60
020101  BB              BB01            61         62

＋＋删除主表
SQL> delete t1111 where g2_id = '020101';

1 row deleted.

＋＋查看主表和从表的内容，可以看到从表中原来的g2_id 为020101已经没有了
＋＋因为主表的删除动作，使得从表外键同值记录也被删掉
SQL> select * from t1111;

G1_ID   G1_NAME         G2_ID   G2_NAME
------- --------------- ------- ---------------
001001  A               010101  AA

SQL> select * from t2222;

G2_ID   G2_NAME         MEMBER       SCORE     SCORE2
------- --------------- ------- ---------- ----------
010101  AA              AA01            60         60
010101  AA              AA02            60         60

++我们只查看最后的结果，不做保存，回滚即可：
SQL> rollback;

Rollback complete.

++查看回滚的内容：
SQL> select * from t1111;

G1_ID   G1_NAME         G2_ID   G2_NAME
------- --------------- ------- ---------------
001001  A               010101  AA
001002  BB              020101  BB01

SQL> select * from t2222;

G2_ID   G2_NAME         MEMBER       SCORE     SCORE2
------- --------------- ------- ---------- ----------
010101  AA              AA01            60         60
010101  AA              AA02            60         60
020101  BB              BB01            61         62

=============================
＋＋约束的的设置：
++约束的停用或启用
＋＋设置外键为不启用
SQL> alter table t2222    
  2  disable constraint T2222_G2ID_T1111_FK;

Table altered.

＋＋查看外键约束的状态，status为停用
SQL> select table_name, constraint_type, constraint_name, delete_rule, r_constraint_name, status
  2  from user_constraints
  3  where table_name = 'T2222';

TABLE_NAME           C CONSTRAINT_NAME                DELETE_RULE          R_CONSTRAINT_NAME              STATUS
-------------------- - ------------------------------ -------------------- ------------------------------ --------
T2222                R T2222_G2ID_T1111_FK            CASCADE              T1111_G2ID_PK                  DISABLED


＋＋查看主表和从表内容
SQL> select * from t1111;

G1_ID   G1_NAME         G2_ID   G2_NAME
------- --------------- ------- ---------------
001001  A               010101  AA
001002  BB              020101  BB01

SQL> select * from t2222;

G2_ID   G2_NAME         MEMBER       SCORE     SCORE2
------- --------------- ------- ---------- ----------
010101  AA              AA01            60         60
010101  AA              AA02            60         60
020101  BB              BB01            61         62

＋＋向从表插入一条从表关联的主表不存在的记录：
SQL> insert into t2222
  2  values('030101', 'CC', 'CC01', 62, 62);

1 row created.

＋＋在启用约束，我们看到此时约束是无法启用的，因为从表有违反主表外键约束的记录：
SQL> alter table t2222
  2  enable constraint T2222_G2ID_T1111_FK;
enable constraint T2222_G2ID_T1111_FK
                  *
ERROR at line 2:
ORA-02298: cannot validate (SYS.T2222_G2ID_T1111_FK) - parent keys not found

++向主表插入从表刚插入的跟从表相关联的记录：
SQL> insert into t1111
  2  values('001003', 'CC', '030101', 'CC01');

1 row created.

++然后再开启外键约束：

SQL> alter table t2222
  2  enable constraint T2222_G2ID_T1111_FK;

Table altered.

++我们看见外键正确执行了启用，并且查看外键的状态为启用了：
SQL> select table_name, constraint_type, constraint_name, delete_rule, r_constraint_name, status
  2  from user_constraints
  3  where table_name = 'T2222';

TABLE_NAME           C CONSTRAINT_NAME                DELETE_RULE          R_CONSTRAINT_NAME              STATUS
-------------------- - ------------------------------ -------------------- ------------------------------ --------
T2222                R T2222_G2ID_T1111_FK            CASCADE              T1111_G2ID_PK                  ENABLED

======================
++约束的维护
++以下t11为主表，t22为从表：
++主表有主键T11_G2ID_PK，从表有外键T22_G2ID_FK
++主外键视图如下：
SQL> r
  1  select table_name, constraint_name, constraint_type, r_constraint_name, status, delete_rule
  2  from user_constraints
  3* where table_name in ('T11', 'T22')

TABLE_NAME CONSTRAINT_NAME      C R_CONSTRAINT_NAME              STATUS   DELETE_RU
---------- -------------------- - ------------------------------ -------- ---------
T11        T11_G2ID_PK          P                                ENABLED
T22        T22_G2ID_FK          R T11_G2ID_PK                    ENABLED  NO ACTION

++当停用主表主键时，范围从表外键引用完整性，所以报错：
SQL> alter table t11
  2  disable constraint T11_G2ID_PK;
alter table t11
*
ERROR at line 1:
ORA-02297: cannot disable constraint (SYS.T11_G2ID_PK) - dependencies exist

＋＋当我们加上级联命令时，主键从属的外键也跟着主键的关闭而关闭了：
++停用主表主键命令被正确执行：
SQL> l  
  1  alter table t11
  2* disable constraint T11_G2ID_PK
SQL> 2 disable constraint T11_G2ID_PK cascade 
SQL> /

Table altered.

++查看主从表的主外键状态
SQL> select table_name, constraint_name, constraint_type, r_constraint_name, status, delete_rule
  2  from user_constraints
  3  where table_name in ('T11', 'T22')
  4  /

TABLE_NAME CONSTRAINT_NAME      C R_CONSTRAINT_NAME              STATUS   DELETE_RU
---------- -------------------- - ------------------------------ -------- ---------
T11        T11_G2ID_PK          P                                DISABLED
T22        T22_G2ID_FK          R T11_G2ID_PK                    DISABLED NO ACTION

＋＋开启主外键：
＋＋在主键并未开启的状态下，开启外键会报错
SQL> alter table t22  
  2  enable constraint T22_G2ID_FK
  3  /  
alter table t22
*
ERROR at line 1:
ORA-02270: no matching unique or primary key for this column-list

++直接使用带级联的开启外键命令，会报错：
SQL> alter table t11
  2  enable constraint T11_G2ID_PK cascade
  3  ;
enable constraint T11_G2ID_PK cascade
                              *
ERROR at line 2:
ORA-00933: SQL command not properly ended

++开启主键：
SQL> r  
  1  alter table t11
  2* enable constraint T11_G2ID_PK

Table altered.

＋＋查看主外键状态：
SQL> r
  1   select table_name, constraint_name, constraint_type, r_constraint_name, status, delete_rule
  2  from user_constraints
  3* where table_name in ('T11', 'T22')

TABLE_NAME CONSTRAINT_NAME      C R_CONSTRAINT_NAME              STATUS   DELETE_RU
---------- -------------------- - ------------------------------ -------- ---------
T11        T11_G2ID_PK          P                                ENABLED
T22        T22_G2ID_FK          R T11_G2ID_PK                    DISABLED NO ACTION

＋＋开启外键：
SQL> alter table t22
  2  enable constraint T22_G2ID_FK
  3  /

Table altered.

++查看主外键状态，均已开启：
SQL> select table_name, constraint_name, constraint_type, r_constraint_name, status, delete_rule
  2  from user_constraints
  3  where table_name in ('T11', 'T22')
  4  /

TABLE_NAME CONSTRAINT_NAME      C R_CONSTRAINT_NAME              STATUS   DELETE_RU
---------- -------------------- - ------------------------------ -------- ---------
T11        T11_G2ID_PK          P                                ENABLED
T22        T22_G2ID_FK          R T11_G2ID_PK                    ENABLED  NO ACTION

========================
＋＋删除带外键的主键：
++直接删除会报错，违反约束完整性
SQL> alter table t11    
  2  drop constraint T11_G2ID_PK
  3  /
drop constraint T11_G2ID_PK
                *
ERROR at line 2:
ORA-02273: this unique/primary key is referenced by some foreign keys

++用带cascade的删除语句，直接删除级联：

SQL> r
  1  alter table t11
  2* drop constraint T11_G2ID_PK cascade

Table altered.
＋＋删除之后，查看主外键所在视图，已经没有内容
SQL> r  
  1  select table_name, constraint_name, constraint_type, r_constraint_name, status, delete_rule
  2  from user_constraints
  3* where table_name in ('T11', 'T22')

no rows selected

==========================
++当显示全部的时候，用oracle连接两张表的方法，比用sql标准要多一列：
SQL> select * from t1111, t2222   
  2  where t1111.g2_id = t2222.g2_id;

G1_ID   G1_NAME         G2_ID   G2_NAME         G2_ID   G2_NAME         MEMBER       SCORE     SCORE2
------- --------------- ------- --------------- ------- --------------- ------- ---------- ----------
001001  A               010101  AA              010101  AA              AA01            60         60
001001  A               010101  AA              010101  AA              AA02            60         60
001003  CC              030101  CC01            030101  CC              CC01            62         62
001002  BB              020101  BB01            020101  BB              BB01            61         62

SQL> select * from t1111
  2  join t2222
  3  using(g2_id);

G2_ID   G1_ID   G1_NAME         G2_NAME         G2_NAME         MEMBER       SCORE     SCORE2
------- ------- --------------- --------------- --------------- ------- ---------- ----------
010101  001001  A               AA              AA              AA01            60         60
010101  001001  A               AA              AA              AA02            60         60
030101  001003  CC              CC01            CC              CC01            62         62
020101  001002  BB              BB01            BB              BB01            61         62

==========================
＋＋注意当作为using的参数出现时，联合的字段就不用加表明了，因为using一旦用了这个字段，则量表的相同值会显示出来
SQL> r
  1  create or replace view view_t1111_t2222
  2  as
  3  select g1_id, g1_name, g2_id, t1111.g2_name, member, score, score2
  4  from t1111
  5  join t2222
  6* using(g2_id)

View created.

＋＋查看视图：
++查看视图结构：
SQL> desc view_t1111_t2222
 Name                                                                                      Null?    Type
 ----------------------------------------------------------------------------------------- -------- ------------------------------------------------------------
 G1_ID                                                                                              VARCHAR2(7)
 G1_NAME                                                                                            VARCHAR2(15)
 G2_ID                                                                                              VARCHAR2(7)
 G2_NAME                                                                                            VARCHAR2(15)
 MEMBER                                                                                             VARCHAR2(7)
 SCORE                                                                                              NUMBER(4)
 SCORE2                                                                                             NUMBER(2)

++查看视图全部内容：
SQL> select * from view_t1111_t2222;

G1_ID   G1_NAME         G2_ID   G2_NAME         MEMBER       SCORE     SCORE2
------- --------------- ------- --------------- ------- ---------- ----------
001001  A               010101  AA              AA01            60         60
001001  A               010101  AA              AA02            60         60
001003  CC              030101  CC01            CC01            62         62
001002  BB              020101  BB01            BB01            61         62

++查看视图某一列：
SQL> select g1_id from view_t1111_t2222;

G1_ID
-------
001001
001001
001003
001002

===================
＋＋在视图命令当中建立字段名的建立视图命令：
SQL> r
  1  create or replace view view_t1111_t2222("g1_id_r", "g1_name_r", "g2_id_r", "g2_name_r", "member_r", "score_r", "score2_r")
  2  as
  3  select g1_id, g1_name, g2_id, t1111.g2_name, member, score, score2
  4  from t1111
  5  join t2222
  6* using(g2_id)

View created.

SQL> select * from view_t1111_t2222;

g1_id_r g1_name_r       g2_id_r g2_name_r       member_    score_r   score2_r
------- --------------- ------- --------------- ------- ---------- ----------
001001  A               010101  AA              AA01            60         60
001001  A               010101  AA              AA02            60         60
001003  CC              030101  CC01            CC01            62         62
001002  BB              020101  BB01            BB01            61         62

=====================================
++当视图包含创建字段，select语句也包含定义字段，那么视图字段会最终有效：
SQL> get tmp
  1  create or replace view view_t1111_t2222
  2  ("g1_id_r", "g1_name_r", "g2_id_r", "g2_name_r", "member_r", "score_r", "score2_r")
  3  as
  4  select g1_id, g1_name, g2_id, t1111.g2_name, member, score, score2 score2_n
  5  from t1111
  6  join t2222
  7* using(g2_id)
  8  /  

View created.

SQL> select * from view_t1111_t2222;

g1_id_r g1_name_r       g2_id_r g2_name_r       member_    score_r   score2_r
------- --------------- ------- --------------- ------- ---------- ----------
001001  A               010101  AA              AA01            60         60
001001  A               010101  AA              AA02            60         60
001003  CC              030101  CC01            CC01            62         62
001002  BB              020101  BB01            BB01            61         62

========================
＋＋查看当前用户下的视图命令：
＋＋内容太多，不写都有哪些表了：
SQL> l
  1  select view_name, text_length, text
  2* from user_views

++查看VIEW_T1111_T2222视图内容
SQL> r  
  1  select view_name, text_length, text
  2  from user_views
  3* where view_name = 'VIEW_T1111_T2222'

VIEW_NAME                      TEXT_LENGTH TEXT
------------------------------ ----------- --------------------------------------------------------------------------------
VIEW_T1111_T2222                       110 select g1_id, g1_name, g2_id, t1111.g2_name, member, score, score2 score2_n
                                           from

=====================
＋＋视图的删除：

＋＋根据t11一个表创建简单视图：
SQL> create view view_t11
  2  as
  3  select * from t11;

View created.

++查看视图内容
SQL> select * from view_t11;

G1_ID G1_NAME    G2_ID                G2_NAME
----- ---------- -------------------- ----------
0     a          00                   A
1     b          01                   B
3     d          03                   D
2     b          02                   B
++查看t11内容：内容相符
SQL> select * from t11;

G1_ID G1_NAME    G2_ID                G2_NAME
----- ---------- -------------------- ----------
0     a          00                   A
1     b          01                   B
3     d          03                   D
2     b          02                   B

＋＋向简单视图插入内容：
SQL> insert into view_t11
  2  values('4', 'e', '04', 'E');

1 row created.

＋＋查询简单视图内容，增加了插入的一行
SQL> select * from view_t11;

G1_ID G1_NAME    G2_ID                G2_NAME
----- ---------- -------------------- ----------
0     a          00                   A
1     b          01                   B
3     d          03                   D
2     b          02                   B
4     e          04                   E

＋＋查询简单视图的原表，内容也增加：
SQL> select * from t11;

G1_ID G1_NAME    G2_ID                G2_NAME
----- ---------- -------------------- ----------
0     a          00                   A
1     b          01                   B
3     d          03                   D
2     b          02                   B
4     e          04                   E

++删除简单视图的g2_id是04的记录：
SQL> delete view_t11 where g2_id = '04';

1 row deleted.

++查看简单视图内容，04记录增加
SQL> select * from view_t11;

G1_ID G1_NAME    G2_ID                G2_NAME
----- ---------- -------------------- ----------
0     a          00                   A
1     b          01                   B
3     d          03                   D
2     b          02                   B

++查询视图的原表，内容也增加，验证完成
SQL> select * from t11;

G1_ID G1_NAME    G2_ID                G2_NAME
----- ---------- -------------------- ----------
0     a          00                   A
1     b          01                   B
3     d          03                   D
2     b          02                   B

=========================
＋＋带检查子句的视图：
SQL> r
  1  create view view_t2_score60
  2  as
  3  select * from t2
  4  where score >= 60
  5* with  check option constraint score_limit60_ck

View created.

++查看创建的视图：
SQL> select * from view_t2_score60;

G2_ID   G2_NAME         MEMBER       SCORE     SCORE2
------- --------------- ------- ---------- ----------
001001  qianduan        010102          72         56
001001  qianduan        010103          66         56
001002  lianji          010201          65         56
001001  qianduan        010101          86         56
001003  rizhong         010302          78         56
002001  qudao           020101          79         56
002001  qudao           020103          69         56
002001  qudao           020104          88         56
002002  file            020202          89         56
003001  shuju           030101          75         56
003001  shuju           030102          70         56

11 rows selected.

++查看原表内容：
SQL> select * from t2;

G2_ID   G2_NAME         MEMBER       SCORE     SCORE2
------- --------------- ------- ---------- ----------
        ???                                        56
001001  qianduan        010102          72         56
001001  qianduan        010103          66         56
001002  lianji          010201          65         56
001001  qianduan        010101          86         56
001002  lianji          010202          56         56
001002  lianji          010202          56         56
001003  rizhong         010301          44         56
001003  rizhong         010302          78         56
001003  rizhong         010303          55         56
002001  qudao           020101          79         56

G2_ID   G2_NAME         MEMBER       SCORE     SCORE2
------- --------------- ------- ---------- ----------
002001  qudao           020102          56         56
002001  qudao           020103          69         56
002001  qudao           020104          88         56
002002  file            020201          54         56
002002  file            020202          89         56
003001  shuju           030101          75         56
003001  shuju           030102          70         56
1       ???                                        56
00_11_  escape                                     56
004001  Linshi          40101                      56

21 rows selected.

===================
＋＋当试图插入一条约束的记录score小于60的记录时，被约束限制住了：
SQL> r  
  1  insert into view_t2_score60
  2* values ('005001', 'test', '050101', 59, 59)
insert into view_t2_score60
            *
ERROR at line 1:
ORA-01402: view WITH CHECK OPTION where-clause violation


++插入一条限制范围内的记录：
SQL> r
  1  insert into view_t2_score60
  2* values ('005001', 'test', '050101', 60, 59)

1 row created.

++查询视图结果：
SQL> select * from view_t2_score60 where g2_id = '005001';

G2_ID   G2_NAME         MEMBER       SCORE     SCORE2
------- --------------- ------- ---------- ----------
005001  test            050101          60         59

++查询原表格结果：
SQL> r  
  1* select * from t2 where g2_id = '005001'

G2_ID   G2_NAME         MEMBER       SCORE     SCORE2
------- --------------- ------- ---------- ----------
005001  test            050101          60         59

=================================
++只读属性的视图：
++视图创建：
SQL> r  
  1  create or replace view view_t2_only_read
  2  as
  3  select * from t2
  4* with read only

View created.

++视图查看：
SQL> r
  1  select view_name, text_length, text
  2  from user_views
  3* where view_name = 'VIEW_T2_ONLY_READ'

VIEW_NAME                      TEXT_LENGTH TEXT
------------------------------ ----------- --------------------------------------------------------------------------------
VIEW_T2_ONLY_READ                       73 select "G2_ID","G2_NAME","MEMBER","SCORE","SCORE2" from t2
                                           with read only

++使用只读视图删除记录时，会报是只读限制：
SQL> delete VIEW_T2_ONLY_READ where g2_id = '005001';
delete VIEW_T2_ONLY_READ where g2_id = '005001'
       *
ERROR at line 1:
ORA-42399: cannot perform a DML operation on a read-only view

++用约束条件视图删除记录，则成功执行：
SQL> delete view_t2_score60 where g2_id = '005001';

1 row deleted.

++在原表中查询已经不存在记录，成功删除：
SQL> r  
  1  select  * from t2
  2* where g2_id = '005001'

no rows selected

++使用update语句时，也受到限制：
SQL> r
  1* update view_t2_only_read set score = 80 where g2_id = '003001'
update view_t2_only_read set score = 80 where g2_id = '003001'
                             *
ERROR at line 1:
ORA-42399: cannot perform a DML operation on a read-only view

============================
++delete 表名 和 truncate table 表名 两个命令同效：
＋＋一张表t2新建另外一张t33表：
SQL> create table t33 
  2  as
  3  select * from t2;

Table created.

＋＋查看t33表格的内容：
SQL> select * from t33;

G2_ID   G2_NAME         MEMBER       SCORE     SCORE2
------- --------------- ------- ---------- ----------
        ???                                        56
001001  qianduan        010102          72         56
001001  qianduan        010103          66         56
001002  lianji          010201          65         56
001001  qianduan        010101          86         56
001002  lianji          010202          56         56
001002  lianji          010202          56         56
001003  rizhong         010301          44         56
001003  rizhong         010302          78         56
001003  rizhong         010303          55         56
002001  qudao           020101          79         56

G2_ID   G2_NAME         MEMBER       SCORE     SCORE2
------- --------------- ------- ---------- ----------
002001  qudao           020102          56         56
002001  qudao           020103          69         56
002001  qudao           020104          88         56
002002  file            020201          54         56
002002  file            020202          89         56
003001  shuju           030101          75         56
003001  shuju           030102          70         56
1       ???                                        56
00_11_  escape                                     56
004001  Linshi          40101                      56

21 rows selected.

++利用delete语句清空表中所有内容：
SQL> delete t33;

21 rows deleted.

++查看表内容，已经空了：
SQL> select * from t33;

no rows selected

====================
＋＋视图的删除：
SQL> drop view view_t2_only_read;

View dropped.

SQL> drop view view_t2_score60;

View dropped.

++查询视图已不存在：
SQL> select * from user_views                  
  2  where view_name LIKE 'VIEW_T2%';

no rows selected

++查看视图结构，已不存在：
SQL> desc view_t2_only_read;
ERROR:
ORA-04043: object view_t2_only_read does not exist


SQL> desc view_t2_score60;
ERROR:
ORA-04043: object view_t2_score60 does not exist

============================
＋＋创建视图：
SQL> create view view_t2
  2  as
  3  select * from t2;

View created.

++查询视图正确性：
SQL> select * from view_t2;

G2_ID   G2_NAME         MEMBER       SCORE     SCORE2
------- --------------- ------- ---------- ----------
        ???                                        56
001001  qianduan        010102          72         56
001001  qianduan        010103          66         56
001002  lianji          010201          65         56
001001  qianduan        010101          86         56
001002  lianji          010202          56         56
001002  lianji          010202          56         56
001003  rizhong         010301          44         56
001003  rizhong         010302          78         56
001003  rizhong         010303          55         56
002001  qudao           020101          79         56

G2_ID   G2_NAME         MEMBER       SCORE     SCORE2
------- --------------- ------- ---------- ----------
002001  qudao           020102          56         56
002001  qudao           020103          69         56
002001  qudao           020104          88         56
002002  file            020201          54         56
002002  file            020202          89         56
003001  shuju           030101          75         56
003001  shuju           030102          70         56
1       ???                                        56
00_11_  escape                                     56
004001  Linshi          40101                      56

21 rows selected.

++构造视图查询子句：
SQL> r
  1  select * from view_t2
  2  where g2_id like '001___'
  3* order by score desc

G2_ID   G2_NAME         MEMBER       SCORE     SCORE2
------- --------------- ------- ---------- ----------
001001  qianduan        010101          86         56
001003  rizhong         010302          78         56
001001  qianduan        010102          72         56
001001  qianduan        010103          66         56
001002  lianji          010201          65         56
001002  lianji          010202          56         56
001002  lianji          010202          56         56
001003  rizhong         010303          55         56
001003  rizhong         010301          44         56

9 rows selected.

++执行带查询子句的前n行查询分析：
SQL> l  
  1  select * from view_t2
  2  where g2_id like '001___'
  3* order by score desc
SQL> select * from( 
  2  select * from view_t2 where g2_id like '001___' order by score desc
  3  ) 
  4  where rownum <= 5;

G2_ID   G2_NAME         MEMBER       SCORE     SCORE2
------- --------------- ------- ---------- ----------
001001  qianduan        010101          86         56
001003  rizhong         010302          78         56
001001  qianduan        010102          72         56
001001  qianduan        010103          66         56
001002  lianji          010201          65         56

======================
++序列号：
++序列号对象的建立：
SQL> create sequence sequence_test  
  2  start with 1  
  3  increment by 1 
  4  maxvalue 999999
  5  cache 10
  6  cycle;

Sequence created.

++序列号查看：
SQL> r
  1  select sequence_name, min_value, max_value,
  2  increment_by, last_number
  3  from user_sequences
  4* where SEQUENCE_NAME = 'SEQUENCE_TEST'

SEQUENCE_NAME       MIN_VALUE  MAX_VALUE INCREMENT_BY LAST_NUMBER
------------------ ---------- ---------- ------------ -----------
SEQUENCE_TEST               1     999999            1           1

++序列号使用，使用当前序列号值，因为从来都没使用过，所以报错
SQL> select SEQUENCE_TEST.currval from dual;
select SEQUENCE_TEST.currval from dual
       *
ERROR at line 1:
ORA-08002: sequence SEQUENCE_TEST.CURRVAL is not yet defined in this session

＋＋使用下一个值：
SQL> select SEQUENCE_TEST.nextval from dual;

   NEXTVAL
----------
         1
++第一次使用后再进行查询，当前值变成了刚生成的值：
SQL> select SEQUENCE_TEST.currval from dual;

   CURRVAL
----------
         1

++向t2表中添加sequence_test.nextval序列号的值和序列号加1：
SQL> r
  1  insert into t2
  2* values ('005001', 'sequence1', '050101', sequence_test.nextval,
sequence_test.nextval + 1)

1 row created.

++查询结果，结果和我们预想的一样，sequence_test.nextval的值变为了2，加1则是3
SQL> select * from t2 where g2_name = 'sequence1';

G2_ID   G2_NAME         MEMBER       SCORE     SCORE2
------- --------------- ------- ---------- ----------
005001  sequence1       050101           2          3

===========================
＋＋创建不缓存的序列号：
++序列号的连续性
SQL> r
  1  create sequence sequence_test2
  2  start with 10000
  3  increment by 1
  4  maxvalue 99999
  5  nocache
  6* nocycle

Sequence created.

＋＋查看序列号表中的内容：
SQL> select * from user_sequences where sequence_name like upper('sequence_test%');

SEQUENCE_NAME       MIN_VALUE  MAX_VALUE INCREMENT_BY C O CACHE_SIZE LAST_NUMBER
------------------ ---------- ---------- ------------ - - ---------- -----------
SEQUENCE_TEST               1     999999            1 Y N         10          11
SEQUENCE_TEST2              1      99999            1 N N          0       10000

＋＋利用不缓存的序列号语句，可以通过序列号表查询到下一个要应用的值，如果对其他值赋值失败
＋＋则不会产生不联系的序号：
SQL> select SEQUENCE_TEST2.nextval from dual;

   NEXTVAL
----------
     10001

SQL> select * from user_sequences where sequence_name like upper('sequence_test%');

SEQUENCE_NAME       MIN_VALUE  MAX_VALUE INCREMENT_BY C O CACHE_SIZE LAST_NUMBER
------------------ ---------- ---------- ------------ - - ---------- -----------
SEQUENCE_TEST               1     999999            1 Y N         10          11
SEQUENCE_TEST2              1      99999            1 N N          0       10002

++对序列号表进行查询时得到结果：
SQL> SQL> r
  1* select LAST_NUMBER from user_sequences where sequence_name like upper('sequence_test2')

LAST_NUMBER
-----------
      10002

++当我们取序列号表中的last_number时，无论做多少次操作，序列号都不会发生变化，所以不会影响序列号的值：
++例如如果以下的插入子句要是发生错误，不会影响序列号的连续性
SQL> r  
  1  insert into t22
  2  (t2_score)
  3  values(
  4  (select LAST_NUMBER from user_sequences where sequence_name = upper('sequence_test2'))
  5  )
  6*
(select LAST_NUMBER from user_sequences where sequence_name = upper('sequence_test2'))
        *
ERROR at line 4:
ORA-01438: value larger than specified precision allowed for this column

=======================
＋＋序列号的修改，也可修改多个属性，如创建时那样用
++只是初始值start　with选项不能修改，要想重新开始只能删掉重新创建
SQL> alter sequence sequence_test  
  2  increment by 2;

Sequence altered.

＋＋当属性修改时，可以看见，当前的序列号的值并未发生变化：
SQL> select SEQUENCE_TEST.currval from dual;

   CURRVAL
----------
         2

++只是下一个值发生了变化：
SQL> select * from user_sequences where sequence_name like upper('sequence_test%');

SEQUENCE_NAME       MIN_VALUE  MAX_VALUE INCREMENT_BY C O CACHE_SIZE LAST_NUMBER
------------------ ---------- ---------- ------------ - - ---------- -----------
SEQUENCE_TEST               1     999999            2 Y N         10           4
SEQUENCE_TEST2              1      99999            1 N N          0       10002
++修改后的序列号只影响修改以后的数据，不影响修改之前的数据。这和初始值不能修改的初衷是一直的

===============
＋＋序列号的删除：
SQL> drop sequence sequence_test;

Sequence dropped.
++此命令为数据库定义语言，会自动提交。

======================
++同义词：
++创建同义词：
SQL> create synonym t_s
  2  for t22;

Synonym created.

++查询同义词：
SQL> select * from t_s;

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A DATE1
------- --------------- ------- ---------- ---------- - ---------
        ???                                        56
001001  qianduan        010102          72         56
001001  qianduan        010103          66         56
001002  lianji          010201          65         56
001001  qianduan        010101          86         56
001002  lianji          010202          56         56
001002  lianji          010202          56         56
001003  rizhong         010301          44         56
001003  rizhong         010302          78         56
001003  rizhong         010303          55         56
002001  qudao           020101          79         56

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A DATE1
------- --------------- ------- ---------- ---------- - ---------
002001  qudao           020102          56         56
002001  qudao           020103          69         56
002001  qudao           020104          88         56
002002  file            020201          54         56
002002  file            020202          89         56
003001  shuju           030101          75         56
003001  shuju           030102          70         56
1       ???                                        56
00_11_  escape                                     56
004001  Linshi          40101                      56
                                                        20-DEC-16

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A DATE1
------- --------------- ------- ---------- ---------- - ---------
005001                                                  27-DEC-16
                                        11              30-DEC-16
                                        11              30-DEC-16
                                        11              30-DEC-16

26 rows selected.

++用其他用户通过同义词对表进行访问时，得到查询不到对象的结果
＋＋因为对象不是公共的，对其他用户是隐藏的：
SQL> connect system        
Enter password: 
Connected.
SQL> select * from t_s;  
select * from t_s
              *
ERROR at line 1:
ORA-00942: table or view does not exist

++通过用户对象访问私有同义词是可以访问到的：
SQL> select * from sys.t_s;

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A DATE1
------- --------------- ------- ---------- ---------- - ---------
        ???                                        56
001001  qianduan        010102          72         56
001001  qianduan        010103          66         56
001002  lianji          010201          65         56
001001  qianduan        010101          86         56
001002  lianji          010202          56         56
001002  lianji          010202          56         56
001003  rizhong         010301          44         56
001003  rizhong         010302          78         56
001003  rizhong         010303          55         56
002001  qudao           020101          79         56

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A DATE1
------- --------------- ------- ---------- ---------- - ---------
002001  qudao           020102          56         56
002001  qudao           020103          69         56
002001  qudao           020104          88         56
002002  file            020201          54         56
002002  file            020202          89         56
003001  shuju           030101          75         56
003001  shuju           030102          70         56
1       ???                                        56
00_11_  escape                                     56
004001  Linshi          40101                      56
                                                        20-DEC-16

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A DATE1
------- --------------- ------- ---------- ---------- - ---------
005001                                                  27-DEC-16
                                        11              30-DEC-16
                                        11              30-DEC-16
                                        11              30-DEC-16

26 rows selected.


＋＋通过用户工程表查询同义词定义：
SQL> column object_name for a20
SQL> r
  1  select object_name,  object_type, created, status
  2  from user_objects
  3* where object_type like upper('synonym')

OBJECT_NAME          OBJECT_TYPE         CREATED   STATUS
-------------------- ------------------- --------- -------
DEF$_AQCALL          SYNONYM             15-AUG-09 VALID
DEF$_CALLDEST        SYNONYM             15-AUG-09 VALID
DEF$_DEFAULTDEST     SYNONYM             15-AUG-09 VALID
DEF$_ERROR           SYNONYM             15-AUG-09 VALID
DEF$_LOB             SYNONYM             15-AUG-09 VALID
DEF$_SCHEDULE        SYNONYM             15-AUG-09 VALID
T_S                  SYNONYM             30-DEC-16 VALID
XMLDOM               SYNONYM             15-AUG-09 VALID
XMLPARSER            SYNONYM             15-AUG-09 VALID
XSLPROCESSOR         SYNONYM             15-AUG-09 VALID

10 rows selected.

++通过用户同义词表查询同义词的用户信息：
++可以看到同义词名为t_s的表名为t22
SQL> column table_owner for a12
SQL> column table_name for a12
SQL> select synonym_name, table_owner, table_name
  2  from user_synonyms;
i  
SYNONYM_NAME                   TABLE_OWNER  TABLE_NAME
------------------------------ ------------ ------------
DEF$_AQCALL                    SYSTEM       DEF$_AQCALL
DEF$_CALLDEST                  SYSTEM       DEF$_CALLDES
                                            T

DEF$_SCHEDULE                  SYSTEM       DEF$_SCHEDUL
                                            E

DEF$_ERROR                     SYSTEM       DEF$_ERROR
DEF$_DEFAULTDEST               SYSTEM       DEF$_DEFAULT
                                            DEST


SYNONYM_NAME                   TABLE_OWNER  TABLE_NAME
------------------------------ ------------ ------------
DEF$_LOB                       SYSTEM       DEF$_LOB
XMLDOM                         XDB          DBMS_XMLDOM
XMLPARSER                      XDB          DBMS_XMLPARS
                                            ER

XSLPROCESSOR                   XDB          DBMS_XSLPROC
                                            ESSOR

T_S                            SYS          T22

10 rows selected.
===================
＋＋公共同义词的创建：
++在sys用户下，创建以下同义词：
SQL> create public synonym t_s_p  
  2  for sys.t22;

Synonym created.

++在非sys用户下，通过同义词查看表内容：
SQL> select * from t_s_p;

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A DATE1
------- --------------- ------- ---------- ---------- - ---------
        ???                                        56
001001  qianduan        010102          72         56
001001  qianduan        010103          66         56
001002  lianji          010201          65         56
001001  qianduan        010101          86         56
001002  lianji          010202          56         56
001002  lianji          010202          56         56
001003  rizhong         010301          44         56
001003  rizhong         010302          78         56
001003  rizhong         010303          55         56
002001  qudao           020101          79         56

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A DATE1
------- --------------- ------- ---------- ---------- - ---------
002001  qudao           020102          56         56
002001  qudao           020103          69         56
002001  qudao           020104          88         56
002002  file            020201          54         56
002002  file            020202          89         56
003001  shuju           030101          75         56
003001  shuju           030102          70         56
1       ???                                        56
00_11_  escape                                     56
004001  Linshi          40101                      56
                                                        20-DEC-16

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A DATE1
------- --------------- ------- ---------- ---------- - ---------
005001                                                  27-DEC-16
                                        11              30-DEC-16
                                        11              30-DEC-16
                                        11              30-DEC-16

26 rows selected.

=============
++删除同义词：
++删除前查看用户同义词表：
SQL> r  
  1  select synonym_name, table_owner, table_name
  2  from user_synonyms
  3* where SYNONYM_NAME = 'T_S'

SYNONYM_NAME                   TABLE_OWNER  TABLE_NAME
------------------------------ ------------ ------------
T_S                            SYS          T22

++删除用户同义词：
SQL> drop synonym  t_s;

Synonym dropped.

++删除后再查看用户同义词表：
SQL> select synonym_name, table_owner, table_name
  2  from user_synonyms
  3  where SYNONYM_NAME = 'T_S';

no rows selected
＋＋已经没有同义词为t_s的同义词

=================================
＋＋用户管理：
++格式create user user_name identified by password;

SQL> create user dog
  2  identified by wangwang;

User created.

++查看创建的用户：
SQL> r
  1  select username, created
  2  from dba_users
  3* where round(created, 'DAY') = round(sysdate, 'DAY')

USERNAME                       CREATED
------------------------------ ---------
DOG                            30-DEC-16

++建立用户后进行数据库登录，显示没有建立连接权限，即不允许该用户登录
SQL> connect dog
Enter password: 
ERROR:
ORA-01045: user DOG lacks CREATE SESSION privilege; logon denied


Warning: You are no longer connected to ORACLE.

＋＋用sys登录的用户，或是用system用户登录，给dog用户授权登录权限：
SQL> grant create session to dog;

Grant succeeded.

++用新建的dog用户再次登录，有登录权限了：
SQL> connect dog
Enter password: 
Connected.
SQL>    

++在dog用户下查询用户对象表：
SQL> select object_name, created
  2  from user_objects;

no rows selected
++因为没有授权，而没有任何对象访问权限

++新建一个用户cat，并创建后修改密码：
SQL> create user cat identified by cat;

User created.

SQL> alter user cat identified by miaomiao;

User altered.

++授权给dog和cat用户进行：
SQL> grant select any table, create table, create view
  2  to dog, cat;

Grant succeeded.

++登录cat用户查看system用户下的t22表：
SQL> select  * from system.t22;

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A
------- --------------- ------- ---------- ---------- -
        ???                                        56
001001  qianduan        010102          72         56
001001  qianduan        010103          66         56
001002  lianji          010201          65         56
001001  qianduan        010101          86         56
001002  lianji          010202          56         56
001002  lianji          010202          56         56
001003  rizhong         010301          44         56
001003  rizhong         010302          78         56
001003  rizhong         010303          55         56
002001  qudao           020101          79         56

T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A
------- --------------- ------- ---------- ---------- -
002001  qudao           020102          56         56
002001  qudao           020103          69         56
002001  qudao           020104          88         56
002002  file            020201          54         56
002002  file            020202          89         56
003001  shuju           030101          75         56
003001  shuju           030102          70         56
1       ???                                        56
00_11_  escape                                     56
004001  Linshi          40101                      56


T2_G2_I T2_G2_NAME      T2_MEMB   T2_SCORE  T2_SCORE2 A
------- --------------- ------- ---------- ---------- -



24 rows selected.
++在cat用户下创建表：
SQL> create table t1    
  2  (id varchar2(4), score number(3));

Table created.
++但插入数据失败了：
SQL> insert into t1 
  2  values('0101', 60);
insert into t1
            *
ERROR at line 1:
ORA-01950: no privileges on tablespace 'USERS'
++因为该新建用户没有表空间。

++在system用户下，查找：
SQL> select tablespace_name from dba_tablespaces;

TABLESPACE_NAME
------------------------------
SYSTEM
SYSAUX
UNDOTBS1
TEMP
USERS
EXAMPLE

6 rows selected.

++分配表空间，将cat用户的表空间，分配在users表空间上：
SQL> alter user cat   
  2  default tablespace users;

User altered.

++删除用户名：
SQL> drop user cat cascade;

User dropped.

++给cat用户创建表空间，是用users表空间，使用20m
SQL> alter user cat
  2  default tablespace users
  3  quota 20m on users;

User altered.

++回到cat用户下，向表cat下的表插入数据，先前的表更改为现在这表名：================
SQL> r
  1  insert into table_test
  2* values('0101', 60)
i
1 row created.


++连接dog用户：
SQL>connect dog
Enter password: 
Connected.
++查看cat用户下table_test表的内容：
SQL> select * from cat.table_test;

ID        SCORE
---- ----------
0101         60

==================
++用户权限查看：
++登录cat用户，查询session_privs字典，查看当前用户权限
SQL> select * from session_privs;

PRIVILEGE
----------------------------------------
CREATE SESSION
CREATE TABLE
SELECT ANY TABLE
CREATE VIEW

=======================
++角色：role
++回首dog和cat用户下的以下权限：
SQL> revoke create session, select any table, create table,
  2  create view
  3  from dog, cat;

++用dog和cat用户连接，都显示没有权限：
SQL> connect cat/miaomiao;
ERROR:
ORA-01045: user CAT lacks CREATE SESSION privilege; logon denied


Warning: You are no longer connected to ORACLE.
SQL> connect dog/wangwang
ERROR:
ORA-01045: user DOG lacks CREATE SESSION privilege; logon denied

++创建用户pig（猪）：
SQL> create user pig
  2  identified by hengheng;

User created.

++创建角色animal（动物）：
SQL> create role animal;

Role created.

++授权给角色以下权限：
SQL> grant create session, select any table, create table, create view
  2  to animal;

Grant succeeded.

++用角色animal给cat，dog和pig赋权限：
SQL> grant animal to dog, cat, pig;

Grant succeeded.

++查询角色animal的权限：
SQL> select * from role_sys_privs
  2  where role = upper('animal');

ROLE                           PRIVILEGE                                ADM
------------------------------ ---------------------------------------- ---
ANIMAL                         CREATE TABLE                             NO
ANIMAL                         CREATE VIEW                              NO
ANIMAL                         CREATE SESSION                           NO
ANIMAL                         SELECT ANY TABLE                         NO

++查看管理员角色权限表，查找animal都授予了那些用户：
SQL> select *         
  2  from dba_role_privs
  3  where granted_role = upper('animal');

GRANTEE                        GRANTED_ROLE                   ADM DEF
------------------------------ ------------------------------ --- ---
SYS                            ANIMAL                         YES YES
CAT                            ANIMAL                         NO  YES
DOG                            ANIMAL                         NO  YES
PIG                            ANIMAL                         NO  YES

++也可以通过登录上被授予权限的用户，直接查询当前登录用户的session权限：
SQL> connect dog/wangwang
Connected.

＋＋查看用户拥有的角色：
SQL> SELECT * FROM USER_ROLE_PRIVS;

USERNAME                       GRANTED_ROLE                   ADM DEF OS_
------------------------------ ------------------------------ --- --- ---
CAT                            ANIMAL                         NO  YES NO


SQL> select * from session_privs;

PRIVILEGE
----------------------------------------
CREATE SESSION
CREATE TABLE
SELECT ANY TABLE
CREATE VIEW

===============
＋＋角色权限的改变，对授权用户的影响：
＋＋连接pig用户，用其查看cat下的t1表，并查看本连接的权限
SQL> connect pig    
Enter password: 
Connected.
＋＋能看到cat下t1表有内容：
SQL> select * from cat.t1;

ID        SOCRE
---- ----------
0101         60

＋＋查看sesstion是有权限的：
SQL> select * from session_privs;

PRIVILEGE
----------------------------------------
CREATE SESSION
CREATE TABLE
SELECT ANY TABLE
CREATE VIEW

++连接system管理员角色用户，并将animal角色的查看表格权限回收
SQL> connect system/manager
Connected.
SQL> revoke select any table
  2  from animal;

Revoke succeeded.

++连接pig用户，再查看cat.t1下的表格，已经查看不到内容
SQL> connect pig/hengheng
Connected.
SQL> select * from cat.t1;
select * from cat.t1
                  *
ERROR at line 1:
ORA-00942: table or view does not exist

++查看当前用户连接的权限，已经没有查看表格的权限
SQL> select * from session_privs;

PRIVILEGE
----------------------------------------
CREATE SESSION
CREATE TABLE
CREATE VIEW

++登录cat用户查看表格内容是存在，验证了我们的结论，是因为没有查看表格权限：
SQL> connect cat/miaomiao
Connected.
SQL> select * from t1;

ID        SOCRE
---- ----------
0101         60

++在cat用户上，将t1表格查询权限，单独赋给pig用户：
SQL> grant select         
  2  on t1
  3  to pig
  4  with grant option;

Grant succeeded.

++登录pig用户，再次查询cat.t1表格的权限，已经能查看到了，说明已经有权限了： 
SQL> connect pig/hengheng;
Connected.
SQL> select * from cat.t1;

ID        SOCRE
---- ----------
0101         60

++登录dog用户，查询cat.t1表，查询不到内容，因为没有授权：
SQL> connect dog
Enter password: 
Connected.
SQL> select * from cat.t1;
select * from cat.t1
                  *
ERROR at line 1:
ORA-00942: table or view does not exist

++登录pig用户，将cat用户给的有授权权限的查询cat.t1的权限，再授权给dog：
SQL> connect pig
Enter password: 
Connected.
SQL> grant     
  2  select on cat.t1
  3  to dog;

Grant succeeded.

++登录dog，查询cat.t1，能查询到内容：
SQL> connect dog/wangwang;
Connected.
SQL> select * from cat.t1;

ID        SOCRE
---- ----------
0101         60

++登录cat用户，创建public_cat_t1表，通过查询子句完成创建；
SQL> r
  1  create table public_cat_t1
  2  as
  3* select * from t1

Table created.

SQL> connect cat/miaomiao;
Connected.
++登录pig用户，对刚的cat.publib_cat_t1进行查询，没有权限：
SQL> connect pig/hengheng;
Connected.
SQL> select * from cat.public_cat_t1;
select * from cat.public_cat_t1
                  *
ERROR at line 1:
ORA-00942: table or view does not exist

++登录cat用户，将表我的查询权限授权给所有用户：
++这样的授权方法，对以后创建的用户，只要有select any table权限，也有效
SQL> connect cat/miaomiao;
Connected.
SQL> grant   
  2  select on public_cat_t1
  3  to public;

Grant succeeded.
++登录上dog用户和pig用户，都能查询到cat下对所有用户公开的表：
SQL> connect dog/wangwang;
Connected.
SQL> select * from cat.public_cat_t1;

ID        SOCRE
---- ----------
0101         60

SQL> connect pig/hengheng;
Connected.
SQL> select * from cat.public_cat_t1;

ID        SOCRE
---- ----------
0101         60

++查看当前用户都授权了那些自己有的权限：
SQL> connect cat/miaomiao;
Connected.

SQL> column grantee for a8
SQL> column table_name for a20
SQL> column grantor for a8
SQL> column privilege for a18

SQL> r
  1* select * from user_tab_privs_made

GRANTEE  TABLE_NAME           GRANTOR  PRIVILEGE          GRA HIE
-------- -------------------- -------- ------------------ --- ---
PIG      T1                   CAT      SELECT             YES NO
DOG      T1                   PIG      SELECT             NO  NO
PUBLIC   PUBLIC_CAT_T1        CAT      SELECT             NO  NO

++以上表明，cat用户把表t1授权给了pig用户，并且pig可以继续将授权其他用户
＋＋第二行表明，pig用户确实对t1表作了进一步的授权，授权给了dog用户，并且权限是不能继续授权：
＋＋除此以外，cat用户还把PUBLIC_CAT_T1表做了公开。
++即完成cat(t1表)->pig->dog依次授权。
==================
＋＋修改列授权：
++登录cat用户，并将修改score列授权给dog用户：
SQL> connect cat/miaomiao;
Connected.
SQL> grant update(score)
  2  on t1
  3  to dog;

Grant succeeded.
++查看用户的列权限：
SQL> select * from user_col_privs;

GRANTEE    OWNER                          TABLE_NAME           COLUMN_NAME                    GRANTOR    PRIVILEGE  GRA
---------- ------------------------------ -------------------- ------------------------------ ---------- ---------- ---
DOG        CAT                            T1                   SCORE                          CAT        UPDATE     NO

++连接dog用户，修改成功：
SQL> connect dog;
Enter password: 
Connected.
SQL> update cat.t1 t set t.score = 65 where t.id = '0101';

1 row updated.

++查询表情况，已经修改成功：
SQL> select * from cat.t1;

ID        SCORE
---- ----------
0102         61
0101         65

====================
＋＋回收权限：
SQL> revoke select
  2  on t1
  3  from pig;

Revoke succeeded.

++回收之后，以前的cat(t1)->pig->dog依次的授权顺序都没有了
＋＋如果想要恢复以前的授权，只能再重新做一次授权
＋＋这很容易理解，如果授权的发生变化，还有以前的授权顺序存在，很显然会造成混乱
SQL> select * from user_tab_privs;

GRANTEE    OWNER                          TABLE_NAME           GRANTOR    PRIVILEGE  GRA HIE
---------- ------------------------------ -------------------- ---------- ---------- --- ---
PUBLIC     CAT                            PUBLIC_CAT_T1        CAT        SELECT     NO  NO

++登录pig和dog查看，用户不在有权限查看了：
SQL> connect pig;     
Enter password: 
Connected.
SQL> select * from user_tab_privs;

no rows selected

SQL> select * from cat.t1;
select * from cat.t1
                  *
ERROR at line 1:
ORA-00942: table or view does not exist


SQL> connect dog;
Enter password: 
Connected.
SQL> select * from user_tab_privs;

no rows selected

SQL> select * from cat.t1;
select * from cat.t1
                  *
ERROR at line 1:
ORA-01031: insufficient privileges

＋＋重新连接cat进行授权：
SQL> connect cat/miaomiao;
Connected.
SQL> grant select  
  2  on t1
  3  to pig
  4  with grant option;

Grant succeeded.

++只能看到pig被授权了：
SQL> select * from user_tab_privs;

GRANTEE    OWNER                          TABLE_NAME           GRANTOR    PRIVILEGE  GRA HIE
---------- ------------------------------ -------------------- ---------- ---------- --- ---
PUBLIC     CAT                            PUBLIC_CAT_T1        CAT        SELECT     NO  NO
PIG        CAT                            T1                   CAT        SELECT     YES NO

++分别连接pig和dog进行验证，可以看到pig有查看cat.t1权限，而dog没有
＋＋要想变成以前的样子，要重新授权：
++pig有权限：
SQL> connect pig/hengheng;
Connected.
SQL> select * from user_tab_privs;

GRANTEE    OWNER                          TABLE_NAME           GRANTOR    PRIVILEGE  GRA HIE
---------- ------------------------------ -------------------- ---------- ---------- --- ---
PIG        CAT                            T1                   CAT        SELECT     YES NO

SQL> select * from cat.t1;

ID        SCORE
---- ----------
0102         61
0101         65

++dog因为撤销过权限，而失去了从pig用户授予的查询cat.t1的权限：
SQL> connect dog/wangwang
Connected.
SQL> select * from user_tab_privs;

no rows selected

SQL> select * from cat.t1;
select * from cat.t1
                  *
ERROR at line 1:
ORA-01031: insufficient privileges


