lsnrctl start --运行书库软件
lsnrctl stop --停止数据库软件
lsnrctl status --查看数据库功能
$ sqlplus / as sysdba 以sys管理员身份链接oracle
SQL> startup 启动数据库
SQL> set echo on/off 开启和关闭脚本执行命令回显
SQL> set serveroutput on/off 开启和关闭执行结果显示

定义及查看一个定义的变量
SQL> define x = "is me"
SQL> define x
DEFINE X               = "is me" (CHAR)

声明和查看一个变量：
SQL> begin  
  2  :x :='hello';
  3  end;
  4  /

PL/SQL procedure successfully completed.

SQL> print :x

X
--------------------------------
hello

在引用的脚本中再应用当前目录下的脚本，而能够不受调用路径影响，用两个@@：
@@abc.sql

开启导出执行日志功能：(从此刻开始的命令以及提示都会被保存在日志文件中）
spool filename(.sql)/filename.define_suffix

关闭输出保存
spool off

设置编辑器
SQL> define _egitor /bin/vi 

察看编辑器：
SQL> define _egitor
DEFINE _EGITOR         = "/bin/vi" (CHAR)

将函数授权给其他用户
SQL> grant execute on wordcount to scott;

Grant succeeded.

查询函数都有哪些用户有权限执行：
SQL> select table_name, grantee, privilege
  2   from user_tab_privs_made
  3  where table_name='WORDCOUNT';

TABLE_NAME                     GRANTEE
------------------------------ ------------------------------
PRIVILEGE
----------------------------------------
WORDCOUNT                      SCOTT
EXECUTE

撤销用户执行函数的权限：
SQL> revoke execute on wordcount from scott;

Revoke succeeded.

-----------------------
删除函数：
SQL> drop function wordcount;

Function dropped.

SHO(W) ERROR --显示错误
SHO(W) ERROR category(种类。例如fuction) [schema.]object(例如函数名）
-----------------------
example: show error fuction my_fuction_custom --查询一个自定义函数的相关错误
--#脚本执行
相对路径：
@abc.sql 或 @abc
--此两个命令都是等价的，都会寻找当前路径下的abc.sql文件，如果不加扩展名，命令会自动添加扩展名
绝对路径：
--绝对路径则添加整个脚本所在的路径即可
"@" 与 start 命令是等价的
SQL> start abs[.sql]
--#查看内置变量和配置的值
SQL> show all;

===================
sqlplus内置变量设置
SQL> define x="g1_name"
SQL> select '&x' from t1;
old   1: select '&x' from t1
new   1: select 'g1_name' from t1

'G1_NAM
-------
g1_name
g1_name
g1_name
g1_name
g1_name
g1_name

6 rows selected.

SQL> select &x from t1;
old   1: select &x from t1
new   1: select g1_name from t1

G1_NAME
---------------
yf01
yf01
yf01
yf02
yf02
yf03

6 rows selected.


