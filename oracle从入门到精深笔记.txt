1.
oracle企业管理器启动：
[oracle@ctos oracle]$ emctl start dbconsole
Oracle Enterprise Manager 11g Database Control Release 11.2.0.1.0 
Copyright (c) 1996, 2009 Oracle Corporation.  All rights reserved.
https://ctos:1158/em/console/aboutApplication
 - An instance of Oracle Enterprise Manager 11g Database Control is already running. 
企业管理器登录地址：
https://192.168.118.128:1158/em/
别忘了设置或关闭防火墙，要不然访问的地址是不允许访问的
2.
oracle配置助手：
$ netca
====================
＋＋关闭数据库：
SQL> shutdown immediate
Database closed.
Database dismounted.
ORACLE instance shut down.
＋＋startup nomount
startup
nomount选项启动实例，但不安装数据库。当数据库以这个模式启动时，参数文件被读取；后台进程和内存结构被启动；但它们不被附加或与数据库的磁盘结构进行通信。当实例处于这个状态时，数据库是不可使用的。
SQL> startup nomount;
ORACLE instance started.

Total System Global Area  839282688 bytes
Fixed Size                  2217992 bytes
Variable Size             591398904 bytes
Database Buffers          239075328 bytes
Redo Buffers                6590464 bytes

＋＋当我们用命令查询数据表时，发现不能操作：
SQL> select * from student;
select * from student
              *
ERROR at line 1:
ORA-01219: database not open: queries allowed on fixed tables/views only


＋＋我们重新关闭并用默认的加载数据库方式进行启动，发现多了加载和打开数据库两个操作
SQL> shutdown immediate;
ORA-01507: database not mounted


ORACLE instance shut down.
SQL> startup 
ORACLE instance started.

Total System Global Area  839282688 bytes
Fixed Size                  2217992 bytes
Variable Size             591398904 bytes
Database Buffers          239075328 bytes
Redo Buffers                6590464 bytes
Database mounted.
Database opened.
++这时我们再查询操作，发现数据库是可以进行操作的：
SQL> select * from student;

SNO        SNAME            SAGE SSEX
---------- ---------- ---------- ----------
s001       张三               23 男
s002       李四               23 男
s003       吴鹏               25 男
s004       琴沁               20 女
s005       王丽               20 女
s006       李波               21 男
s007       刘玉               21 男
s008       萧蓉               21 女
s009       陈萧晓             23 女
s010       陈美               22 女

10 rows selected.

++当然如果数据库格式显示有问题，则要对字段宽度显示作个设置。

++startup mount
＋＋停止数据库时有关闭和卸载过程，这是因为打开时作了加载和打开操作：
++startup mount命令启动数据库实例，加载数据库，但不打开数据库：
SQL> shutdown immediate
Database closed.
Database dismounted.
ORACLE instance shut down.
SQL> startup mount
ORACLE instance started.

Total System Global Area  839282688 bytes
Fixed Size                  2217992 bytes
Variable Size             603981816 bytes
Database Buffers          226492416 bytes
Redo Buffers                6590464 bytes
Database mounted.
SQL> 

++startup mount启动的命令执行关闭样貌
SQL> shutdown immediate
ORA-01109: database not open


Database dismounted.
ORACLE instance shut down.

++startup [open]
SQL> startup open
ORACLE instance started.

Total System Global Area  839282688 bytes
Fixed Size                  2217992 bytes
Variable Size             603981816 bytes
Database Buffers          226492416 bytes
Redo Buffers                6590464 bytes
Database mounted.
Database opened.
SQL> shutdown immediate
Database closed.
Database dismounted.
ORACLE instance shut down.
++或如下这样执行：
SQL> startup
ORACLE instance started.

Total System Global Area  839282688 bytes
Fixed Size                  2217992 bytes
Variable Size             603981816 bytes
Database Buffers          226492416 bytes
Redo Buffers                6590464 bytes
Database mounted.
Database opened.
＋＋startup 执行关闭样貌
SQL> shutdown immediate
Database closed.
Database dismounted.
lORACLE instance shut down.
============
SQL>startup force
++startup force强制启动，在其他启动选项都不可用的情况下
ORACLE instance started.

Total System Global Area  839282688 bytes
Fixed Size                  2217992 bytes
Variable Size             603981816 bytes
Database Buffers          226492416 bytes
Redo Buffers                6590464 bytes
Database mounted.
Database opened.

======================
＋＋关闭数据库实例：
++shutdown normal
++禁止新连接，等当前用户主动断开连接，然后关闭数据库
SQL> shutdown normal
Database closed.
Database dismounted.
ORACLE instance shut down.

++shutdown transactional
++保持现有事物能进行提交，阻止新连接和阻止新事物，当所有用户都进行完事物提交后，断开用户连接，然后关闭数据库
SQL> shutdown transactional
Database closed.
Database dismounted.
ORACLE instance shut down.

++shutdown immediate
++将用户的事物回退，并关闭连接，关闭数据库
SQL> shutdown immediate
Database closed.
Database dismounted.
ORACLE instance shut down.

++shutdown abort
＋＋阻止新用户建立连接和阻止新事物，取消提交的事物，但不回滚，断开用户连接，关闭数据库 
SQL> shutdown abort 
ORACLE instance shut down.

=================
++oracle标准块大小查看：
SQL> column name format a30
SQL> column value format a20
SQL> r  
  1  select name, value
  2  from v$parameter
  3* where name = 'db_block_size'

NAME                           VALUE
------------------------------ --------------------
db_block_size                  8192
===================
＋＋查询数据库字典信息：
SQL> column table_name format a30
SQL> column comments format a30
SQL> select * from dict;
/* 结果只展示最后几行 */
TABLE_NAME                     COMMENTS
------------------------------ ------------------------------
V$MVREFRESH                    Synonym for V_$MVREFRESH
V$SQL_BIND_CAPTURE             Synonym for V_$SQL_BIND_CAPTUR
                               E

GV$SQL_BIND_CAPTURE            Synonym for GV_$SQL_BIND_CAPTU
                               RE

ALL_OLAP2_AWS                  Synonym for ALL$OLAP2_AWS

2553 rows selected.

===================
++查询数据库内部系统表信息：
SQL> column view_name format a30
SQL> column view_difinition format a30
SQL> select * from v$fixed_view_definition;
/* 结果只展示最后几行 */
VIEW_NAME                      VIEW_DEFINITION
------------------------------ ------------------------------
                               sabled_knlasg  FROM x$knlasg

V$STREAMS_POOL_STATISTICS      SELECT TOTAL_MEMORY_ALLOCATED,
                                CURRENT_SIZE, SGA_TARGET_VALU
                               E,         SHRINK_PHASE, ADVIC
                               E_DISABLED  FROM   GV$STREAMS_
                               POOL_STATISTICS WHERE  INST_ID
                                = USERENV('Instance')


1023 rows selected.

===================
++查询oracle系统文件信息：
SQL> select file_name, tablespace_name       
  2  from dba_data_files;

FILE_NAME
--------------------------------------------------
TABLESPACE_NAME
------------------------------------------------------------------------------------------
/home/oracle/app/oradata/orcl/users01.dbf
USERS

/home/oracle/app/oradata/orcl/undotbs01.dbf
UNDOTBS1

/home/oracle/app/oradata/orcl/sysaux01.dbf
SYSAUX


FILE_NAME
--------------------------------------------------
TABLESPACE_NAME
------------------------------------------------------------------------------------------
/home/oracle/app/oradata/orcl/system01.dbf
SYSTEM

=======================
++系统表查询：
SQL> select * from dba_data_files;

FILE_NAME                                             FILE_ID
-------------------------------------------------- ----------
TABLESPACE_NAME
------------------------------------------------------------------------------------------
     BYTES     BLOCKS STATUS                      RELATIVE_FNO AUTOEXTEN
MAXBYTES  MAXBLOCKS
---------- ---------- --------------------------- ------------ ---------
---------- ----------
INCREMENT_BY USER_BYTES USER_BLOCKS ONLINE_STATUS
------------ ---------- ----------- ---------------------
/home/oracle/app/oradata/orcl/users01.dbf                   4
USERS
   5242880        640 AVAILABLE                              4 YES  3.4360E+10
4194302
         160    4194304         512 ONLINE


FILE_NAME                                             FILE_ID
-------------------------------------------------- ----------
TABLESPACE_NAME
------------------------------------------------------------------------------------------
     BYTES     BLOCKS STATUS                      RELATIVE_FNO AUTOEXTEN
MAXBYTES  MAXBLOCKS
---------- ---------- --------------------------- ------------ ---------
---------- ----------
INCREMENT_BY USER_BYTES USER_BLOCKS ONLINE_STATUS
------------ ---------- ----------- ---------------------
/home/oracle/app/oradata/orcl/undotbs01.dbf                 3
UNDOTBS1
  99614720      12160 AVAILABLE                              3 YES  3.4360E+10
4194302
         640   98566144       12032 ONLINE


FILE_NAME                                             FILE_ID
-------------------------------------------------- ----------
TABLESPACE_NAME
------------------------------------------------------------------------------------------
     BYTES     BLOCKS STATUS                      RELATIVE_FNO AUTOEXTEN
MAXBYTES  MAXBLOCKS
---------- ---------- --------------------------- ------------ ---------
---------- ----------
INCREMENT_BY USER_BYTES USER_BLOCKS ONLINE_STATUS
------------ ---------- ----------- ---------------------
/home/oracle/app/oradata/orcl/sysaux01.dbf                  2
SYSAUX
 576716800      70400 AVAILABLE                              2 YES  3.4360E+10
4194302
        1280  575668224       70272 ONLINE


FILE_NAME                                             FILE_ID
-------------------------------------------------- ----------
TABLESPACE_NAME
------------------------------------------------------------------------------------------
     BYTES     BLOCKS STATUS                      RELATIVE_FNO AUTOEXTEN
MAXBYTES  MAXBLOCKS
---------- ---------- --------------------------- ------------ ---------
---------- ----------
INCREMENT_BY USER_BYTES USER_BLOCKS ONLINE_STATUS
------------ ---------- ----------- ---------------------
/home/oracle/app/oradata/orcl/system01.dbf                  1
SYSTEM
 713031680      87040 AVAILABLE                              1 YES  3.4360E+10
4194302
        1280  711983104       86912 SYSTEM


＋＋系统临时表：
SQL> select * from dba_temp_files;

FILE_NAME                                             FILE_ID
-------------------------------------------------- ----------
TABLESPACE_NAME
------------------------------------------------------------------------------------------
     BYTES     BLOCKS STATUS                RELATIVE_FNO AUTOEXTEN   MAXBYTES
MAXBLOCKS
---------- ---------- --------------------- ------------ --------- ----------
----------
INCREMENT_BY USER_BYTES USER_BLOCKS
------------ ---------- -----------
/home/oracle/app/oradata/orcl/temp01.dbf                    1
TEMP
  30408704       3712 ONLINE                           1 YES
3.4360E+10    4194302
          80   29360128        3584

======================
++系统空间名字对应文件名：
SQL> r
  1* select file_name, tablespace_name from dba_data_files

FILE_NAME
--------------------------------------------------
TABLESPACE_NAME
------------------------------------------------------------------------------------------
/home/oracle/app/oradata/orcl/users01.dbf
USERS

/home/oracle/app/oradata/orcl/undotbs01.dbf
UNDOTBS1

/home/oracle/app/oradata/orcl/sysaux01.dbf
SYSAUX


FILE_NAME
--------------------------------------------------
TABLESPACE_NAME
------------------------------------------------------------------------------------------
/home/oracle/app/oradata/orcl/system01.dbf
SYSTEM


++临时表空间及其文件名：
SQL> select file_name, tablespace_name 
  2  from dba_temp_files;

FILE_NAME
--------------------------------------------------
TABLESPACE_NAME
------------------------------------------------------------------------------------------
/home/oracle/app/oradata/orcl/temp01.dbf
TEMP
++控制文件：
SQL> column name format a60
SQL> select name from v$controlfile;  

NAME
------------------------------------------------------------
/home/oracle/app/oradata/orcl/control01.ctl
/home/oracle/app/recovery_area/orcl/control02.ctl

===================
＋＋查看oracle日志文件：
SQL> column member format a50
SQL> select member from v$logfile;

MEMBER
--------------------------------------------------
/home/oracle/app/oradata/orcl/redo03.log
/home/oracle/app/oradata/orcl/redo02.log
/home/oracle/app/oradata/orcl/redo01.log

======================
++查看oracle数据库是否采用日志归档：
SQL> select dbid, name, log_mode from v$database;

      DBID NAME                           LOG_MODE
---------- ------------------------------ ------------------------------------
1460352071 ORCL                           NOARCHIVELOG

====================
++查看归档文件所在的路径：
SQL> set pagesize 30;
SQL> show parameter log_archive_dest;

NAME                                 TYPE
------------------------------------ ---------------------------------
VALUE
------------------------------
log_archive_dest                     string

log_archive_dest_1                   string

log_archive_dest_10                  string

log_archive_dest_11                  string

log_archive_dest_12                  string

log_archive_dest_13                  string

log_archive_dest_14                  string

log_archive_dest_15                  string

log_archive_dest_16                  string

log_archive_dest_17                  string

log_archive_dest_18                  string

log_archive_dest_19                  string

log_archive_dest_2                   string

NAME                                 TYPE
------------------------------------ ---------------------------------
VALUE
------------------------------

log_archive_dest_20                  string

log_archive_dest_21                  string

log_archive_dest_22                  string

log_archive_dest_23                  string

log_archive_dest_24                  string

log_archive_dest_25                  string

log_archive_dest_26                  string

log_archive_dest_27                  string

log_archive_dest_28                  string

log_archive_dest_29                  string

log_archive_dest_3                   string

log_archive_dest_30                  string


NAME                                 TYPE
------------------------------------ ---------------------------------
VALUE
------------------------------
log_archive_dest_31                  string

log_archive_dest_4                   string

log_archive_dest_5                   string

log_archive_dest_6                   string

log_archive_dest_7                   string

log_archive_dest_8                   string

log_archive_dest_9                   string

log_archive_dest_state_1             string
enable
log_archive_dest_state_10            string
enable
log_archive_dest_state_11            string
enable
log_archive_dest_state_12            string
enable
log_archive_dest_state_13            string
enable
log_archive_dest_state_14            string

NAME                                 TYPE
------------------------------------ ---------------------------------
VALUE
------------------------------
enable
log_archive_dest_state_15            string
enable
log_archive_dest_state_16            string
enable
log_archive_dest_state_17            string
enable
log_archive_dest_state_18            string
enable
log_archive_dest_state_19            string
enable
log_archive_dest_state_2             string
enable
log_archive_dest_state_20            string
enable
log_archive_dest_state_21            string
enable
log_archive_dest_state_22            string
enable
log_archive_dest_state_23            string
enable
log_archive_dest_state_24            string
enable
log_archive_dest_state_25            string
enable

NAME                                 TYPE
------------------------------------ ---------------------------------
VALUE
------------------------------
log_archive_dest_state_26            string
enable
log_archive_dest_state_27            string
enable
log_archive_dest_state_28            string
enable
log_archive_dest_state_29            string
enable
log_archive_dest_state_3             string
enable
log_archive_dest_state_30            string
enable
log_archive_dest_state_31            string
enable
log_archive_dest_state_4             string
enable
log_archive_dest_state_5             string
enable
log_archive_dest_state_6             string
enable
log_archive_dest_state_7             string
enable
log_archive_dest_state_8             string
enable
log_archive_dest_state_9             string

NAME                                 TYPE
------------------------------------ ---------------------------------
VALUE
------------------------------
enable
=====================
＋＋查看参数值，能否被修改以及是否被修改过：
SQL> r
  1  select name, value, ismodified
  2* from v$parameter
NAME                           VALUE                          ISMODIFIED
------------------------------ ------------------------------
------------------------------
asm_preferred_read_failure_gro                                FALSE
ups

asm_diskgroups                                                FALSE
asm_power_limit                1                              FALSE
control_management_pack_access NONE                           FALSE
sqltune_category               DEFAULT                        FALSE
diagnostic_dest                /home/oracle/app               FALSE
tracefile_identifier                                          FALSE
max_dump_file_size             unlimited                      FALSE
trace_enabled                  TRUE                           FALSE

342 rows selected.

=====================
++查看服务器参数：

SQL> show parameter
NAME                                 TYPE
------------------------------------ ---------------------------------
VALUE
------------------------------
tracefile_identifier                 string

transactions                         integer
272
transactions_per_rollback_segment    integer
5
undo_management                      string
AUTO
undo_retention                       integer
900
undo_tablespace                      string
UNDOTBS1
use_indirect_data_buffers            boolean
FALSE
user_dump_dest                       string
/home/oracle/app/diag/rdbms/or
cl/orcl/trace
utl_file_dir                         string

workarea_size_policy                 string
AUTO
xml_db_events                        string
enable

==================
++查看sqlplus参数：
SQL> show all;
appinfo is OFF and set to "SQL*Plus"
arraysize 15
autocommit OFF
autoprint OFF
autorecovery OFF
autotrace OFF
blockterminator "." (hex 2e)
btitle OFF and is the first few characters of the next SELECT statement
cmdsep OFF
colsep " "
compatibility version NATIVE
concat "." (hex 2e)
copycommit 0
COPYTYPECHECK is ON
define "&" (hex 26)
describe DEPTH 1 LINENUM OFF INDENT ON
echo OFF
editfile "afiedt.buf"
embedded OFF
escape OFF
escchar OFF
exitcommit ON
FEEDBACK ON for 6 or more rows
flagger OFF
flush ON
heading ON
headsep "|" (hex 7c)
instance "local"
linesize 100
lno 28
loboffset 1
logsource ""
long 80
longchunksize 80
markup HTML OFF HEAD "<style type='text/css'> body {font:10pt
Arial,Helvetica,sans-serif; color:black; background:White;} p {font:10pt
Arial,Helvetica,sans-serif; color:black; background:White;} table,tr,td
{font:10pt Arial,Helvetica,sans-serif; color:Black; background:#f7f7e7;
padding:0px 0px 0px 0px; margin:0px 0px 0px 0px;} th {font:bold 10pt
Arial,Helvetica,sans-serif; color:#336699; background:#cccc99; padding:0px 0px
0px 0px;} h1 {font:16pt Arial,Helvetica,Geneva,sans-serif; color:#336699;
background-color:White; border-bottom:1px solid #cccc99; margin-top:0pt;
margin-bottom:0pt; padding:0px 0px 0px 0px;-
} h2 {font:bold 10pt Arial,Helvetica,Geneva,sans-serif; color:#336699;
background-color:White; margin-top:4pt; margin-bottom:0pt;} a {font:9pt
Arial,Helvetica,sans-serif; color:#663300; background:#ffffff; margin-top:0pt;
margin-bottom:0pt; vertical-align:top;}</style><title>SQL*Plus Report</title>"
BODY "" TABLE "border='1' width='90%' align='center' summary='Script output'"
SPOOL OFF ENTMAP ON PREFORMAT OFF
newpage 1
null ""
numformat ""
numwidth 10
pagesize 30
PAUSE is OFF
pno 28
recsep WRAP
recsepchar " " (hex 20)
release 1102000100
repfooter OFF and is NULL
repheader OFF and is NULL
securedcol is OFF
serveroutput OFF
shiftinout INVISIBLE
showmode OFF
spool OFF
sqlblanklines OFF
sqlcase MIXED
sqlcode 0
sqlcontinue "> "
sqlnumber ON
sqlpluscompatibility 11.2.0
sqlprefix "#" (hex 23)
sqlprompt "SQL> "
sqlterminator ";" (hex 3b)
suffix "sql"
tab ON
termout ON
timing OFF
trimout ON
trimspool OFF
ttitle OFF and is the first few characters of the next SELECT statement
underline "-" (hex 2d)
USER is "SYS"
verify ON
wrap : lines will be wrapped
errorlogging is OFF

===================
++查看某个系统参数方法：
SQL> show parameter db_block_size;

NAME                                 TYPE
------------------------------------ ---------------------------------
VALUE
------------------------------
db_block_size                        integer
8192
++设置系统参数方法：
++因为某些原因，修改参数失败了
SQL> alter system set db_block_size=8192;
alter system set db_block_size=8192
                 *
ERROR at line 1:
ORA-02095: specified initialization parameter cannot be modified

++密码文件：
 /home/oracle/app/oracle/product/11.2.0/dbhome_1/dbs/orapworcl
＋＋或是:
$ORACLE_HOME/dbs/orapworcl
/home/oracle/app/oracle/product/11.2.0/dbhome_1/dbs/orapworcl
$ORACLE_HOME/dbs/orapw<sid>

===============
++创建密码文件：
[oracle@ctos oracle]$ orapwd
file=/home/oracle/app/oracle/product/11.2.0/dbhome_1/dbs/orapwd_text
entries=40 password=123456
[oracle@ctos oracle]$ ls
/home/oracle/app/oracle/product/11.2.0/dbhome_1/dbs/orapwd_text
/home/oracle/app/oracle/product/11.2.0/dbhome_1/dbs/orapwd_text

=================
++警告文件：
SQL> r
  1  select name, value from v$parameter
  2* where name = 'background_dump_dest'

NAME                 VALUE
-------------------- --------------------------------------------------
background_dump_dest /home/oracle/app/diag/rdbms/orcl/orcl/trace

++文件众多，只展示部分：
[oracle@ctos oracle]$ ls /home/oracle/app/diag/rdbms/orcl/orcl/trace
alert_orcl.log       orcl_ora_23986.trm
orcl_cjq0_14085.trc  orcl_ora_23989.trc
orcl_cjq0_14085.trm  orcl_ora_23989.trm
orcl_cjq0_22139.trc  orcl_ora_24021.trc
orcl_cjq0_22139.trm  orcl_ora_24021.trm
orcl_cjq0_23618.trc  orcl_ora_24110.trc
... ...

++跟踪文件：
++用于跟踪sql语句的执行情况，能看得出sql语句的执行效率
SQL> select value from v$parameter 
  2  where name = 'user_dump_dest';

VALUE
--------------------------------------------------
/home/oracle/app/diag/rdbms/orcl/orcl/trace

++文件众多，只展示部分：
[oracle@ctos oracle]$ ls /home/oracle/app/diag/rdbms/orcl/orcl/trace
alert_orcl.log       orcl_ora_23986.trm
orcl_cjq0_14085.trc  orcl_ora_23989.trc
orcl_cjq0_14085.trm  orcl_ora_23989.trm
orcl_cjq0_22139.trc  orcl_ora_24021.trc
orcl_cjq0_22139.trm  orcl_ora_24021.trm
... ...

++查看系统参数共享池大小：
SQL> show parameter shared_pool_size;

NAME                                 TYPE
------------------------------------ ---------------------------------
VALUE
------------------------------
shared_pool_size                     big integer
0
＋＋修改共享池大小：
SQL> alter system set shared_pool_size=30m;

System altered.

++修改之后大小
SQL> show parameter shared_pool_size;

NAME                                 TYPE
------------------------------------ ---------------------------------
VALUE
------------------------------
shared_pool_size                     big integer
32M

++设置前后的大型池：
SQL> show parameter large_pool_size;

NAME                                 TYPE
------------------------------------ ---------------------------------
VALUE
------------------------------
large_pool_size                      big integer
0

SQL> alter system set large_pool_size=30m
  2  ;  
it
System altered.

SQL       
SQL> show parameter large_pool_size;

NAME                                 TYPE
------------------------------------ ---------------------------------
VALUE
------------------------------
large_pool_size                      big integer
32M
SQL>    

++查看全局区大小：

SQL> show parameter pga;

NAME                                 TYPE
------------------------------------ ---------------------------------
VALUE
------------------------------
pga_aggregate_target                 big integer
0
++查询当前实例进程信息：
SQL> column description format a50
SQL> r  
  1* select name, description from v$bgprocess

NAME            DESCRIPTION
--------------- --------------------------------------------------
PMON            process cleanup
VKTM            Virtual Keeper of TiMe process
GEN0            generic0
DIAG            diagnosibility process
DBRM            DataBase Resource Manager
VKRM            Virtual sKeduler for Resource Manager
RSMN            Remote Slave Monitor
PING            interconnect latency measurement
FMON            File Mapping Monitor Process
PSP0            process spawner 0
ACMS            Atomic Controlfile to Memory Server
DSKM            slave DiSKMon process
DIA0            diagnosibility process 0
DIA1            diagnosibility process 1
DIA2            diagnosibility process 2
DIA3            diagnosibility process 3
DIA4            diagnosibility process 4
DIA5            diagnosibility process 5
DIA6            diagnosibility process 6
DIA7            diagnosibility process 7
DIA8            diagnosibility process 8
DIA9            diagnosibility process 9
LMON            global enqueue service monitor
LMD0            global enqueue service daemon 0
LMS0            global cache service process 0
LMS1            global cache service process 1
LMS2            global cache service process 2
LMS3            global cache service process 3
LMS4            global cache service process 4
LMS5            global cache service process 5
LMS6            global cache service process 6
LMS7            global cache service process 7
LMS8            global cache service process 8
LMS9            global cache service process 9
LMSa            global cache service process 10
LMSb            global cache service process 11
LMSc            global cache service process 12
LMSd            global cache service process 13
LMSe            global cache service process 14
LMSf            global cache service process 15
LMSg            global cache service process 16
LMSh            global cache service process 17
LMSi            global cache service process 18
LMSj            global cache service process 19
LMSk            global cache service process 20
LMSl            global cache service process 21
LMSm            global cache service process 22

NAME            DESCRIPTION
--------------- --------------------------------------------------
LMSn            global cache service process 23
LMSo            global cache service process 24
LMSp            global cache service process 25
LMSq            global cache service process 26
LMSr            global cache service process 27
LMSs            global cache service process 28
LMSt            global cache service process 29
LMSu            global cache service process 30
LMSv            global cache service process 31
LMSw            global cache service process 32
LMSx            global cache service process 33
LMSy            global cache service process 34
RMS0            rac management server
LMHB            lm heartbeat monitor
MMAN            Memory Manager
DBW0            db writer process 0
DBW1            db writer process 1
DBW2            db writer process 2
DBW3            db writer process 3
DBW4            db writer process 4
DBW5            db writer process 5
DBW6            db writer process 6
DBW7            db writer process 7
DBW8            db writer process 8
DBW9            db writer process 9
DBWa            db writer process 10 (a)
DBWb            db writer process 11 (b)
DBWc            db writer process 12 (c)
DBWd            db writer process 13 (d)
DBWe            db writer process 14 (e)
DBWf            db writer process 15 (f)
DBWg            db writer process 16 (g)
DBWh            db writer process 17 (h)
DBWi            db writer process 18 (i)
DBWj            db writer process 19 (j)
DBWk            db writer process 20 (k)
DBWl            db writer process 21 (l)
DBWm            db writer process 22 (m)
DBWn            db writer process 23 (n)
DBWo            db writer process 24 (o)
DBWp            db writer process 25 (p)
DBWq            db writer process 26 (q)
DBWr            db writer process 27 (r)
DBWs            db writer process 28 (s)
DBWt            db writer process 29 (t)
DBWu            db writer process 30 (u)
DBWv            db writer process 31 (v)

NAME            DESCRIPTION
--------------- --------------------------------------------------
DBWw            db writer process 32 (s)
DBWx            db writer process 33 (t)
DBWy            db writer process 34 (u)
DBWz            db writer process 35 (v)
MRP0            Managed Standby Recovery
ARC0            Archival Process 0
ARC1            Archival Process 1
ARC2            Archival Process 2
ARC3            Archival Process 3
ARC4            Archival Process 4
ARC5            Archival Process 5
ARC6            Archival Process 6
ARC7            Archival Process 7
ARC8            Archival Process 8
ARC9            Archival Process 9
ARCa            Archival Process 10
ARCb            Archival Process 11
ARCc            Archival Process 12
ARCd            Archival Process 13
ARCe            Archival Process 14
ARCf            Archival Process 15
ARCg            Archival Process 16
ARCh            Archival Process 17
ARCi            Archival Process 18
ARCj            Archival Process 19
ARCk            Archival Process 20
ARCl            Archival Process 21
ARCm            Archival Process 22
ARCn            Archival Process 23
ARCo            Archival Process 24
ARCp            Archival Process 25
ARCq            Archival Process 26
ARCr            Archival Process 27
ARCs            Archival Process 28
ARCt            Archival Process 29
NSA1            Redo transport NSA1
NSS1            Redo transport NSS1
NSA2            Redo transport NSA2
NSS2            Redo transport NSS2
NSA3            Redo transport NSA3
NSS3            Redo transport NSS3
NSA4            Redo transport NSA4
NSS4            Redo transport NSS4
NSA5            Redo transport NSA5
NSS5            Redo transport NSS5
NSA6            Redo transport NSA6
NSS6            Redo transport NSS6

NAME            DESCRIPTION
--------------- --------------------------------------------------
NSA7            Redo transport NSA7
NSS7            Redo transport NSS7
NSA8            Redo transport NSA8
NSS8            Redo transport NSS8
NSA9            Redo transport NSA9
NSS9            Redo transport NSS9
NSAA            Redo transport NSAA
NSSA            Redo transport NSSA
NSAB            Redo transport NSAB
NSSB            Redo transport NSSB
NSAC            Redo transport NSAC
NSSC            Redo transport NSSC
NSAD            Redo transport NSAD
NSSD            Redo transport NSSD
NSAE            Redo transport NSAE
NSSE            Redo transport NSSE
NSAF            Redo transport NSAF
NSSF            Redo transport NSSF
NSAG            Redo transport NSAG
NSSG            Redo transport NSSG
NSAH            Redo transport NSAH
NSSH            Redo transport NSSH
NSAI            Redo transport NSAI
NSSI            Redo transport NSSI
NSAJ            Redo transport NSAJ
NSSJ            Redo transport NSSJ
NSAK            Redo transport NSAK
NSSK            Redo transport NSSK
NSAL            Redo transport NSAL
NSSL            Redo transport NSSL
NSAM            Redo transport NSAM
NSSM            Redo transport NSSM
NSAN            Redo transport NSAN
NSSN            Redo transport NSSN
NSAO            Redo transport NSAO
NSSO            Redo transport NSSO
NSAP            Redo transport NSAP
NSSP            Redo transport NSSP
NSAQ            Redo transport NSAQ
NSSQ            Redo transport NSSQ
NSAR            Redo transport NSAR
NSSR            Redo transport NSSR
NSAS            Redo transport NSAS
NSSS            Redo transport NSSS
NSAT            Redo transport NSAT
NSST            Redo transport NSST
NSAU            Redo transport NSAU

NAME            DESCRIPTION
--------------- --------------------------------------------------
NSSU            Redo transport NSSU
NSAV            Redo transport NSAV
NSSV            Redo transport NSSV
LGWR            Redo etc.
LCK0            Lock Process 0
CKPT            checkpoint
ABMR            Auto BMR Background Process
LSP1            Dictionary build process for Logical Standby
LSP0            Logical Standby
LSP2            Set Guard Standby Information for Logical Standby
CTWR            Change Tracking Writer
RVWR            Recovery Writer
FBDA            Flashback Data Archiver Process
SMON            System Monitor Process
SMCO            Space Manager Process
RECO            distributed recovery
GTX0            Global Txn process 0
GTX1            Global Txn process 1
GTX2            Global Txn process 2
GTX3            Global Txn process 3
GTX4            Global Txn process 4
GTX5            Global Txn process 5
GTX6            Global Txn process 6
GTX7            Global Txn process 7
GTX8            Global Txn process 8
GTX9            Global Txn process 9
GTXa            Global Txn process 10
GTXb            Global Txn process 11
GTXc            Global Txn process 12
GTXd            Global Txn process 13
GTXe            Global Txn process 14
GTXf            Global Txn process 15
GTXg            Global Txn process 16
GTXh            Global Txn process 17
GTXi            Global Txn process 18
GTXj            Global Txn process 19
CJQ0            Job Queue Coordinator
RCBG            Result Cache: Background
EMNC            EMON Coordinator
QMNC            AQ Coordinator
DMON            DG Broker Monitor Process
RSM0            Data Guard Broker Resource Guard Process 0
NSV0            Data Guard Broker NetSlave Process 0
NSV1            Data Guard Broker NetSlave Process 1
NSV2            Data Guard Broker NetSlave Process 2
NSV3            Data Guard Broker NetSlave Process 3
NSV4            Data Guard Broker NetSlave Process 4

NAME            DESCRIPTION
--------------- --------------------------------------------------
NSV5            Data Guard Broker NetSlave Process 5
NSV6            Data Guard Broker NetSlave Process 6
NSV7            Data Guard Broker NetSlave Process 7
NSV8            Data Guard Broker NetSlave Process 8
NSV9            Data Guard Broker NetSlave Process 9
NSVA            Data Guard Broker NetSlave Process A
NSVB            Data Guard Broker NetSlave Process B
NSVC            Data Guard Broker NetSlave Process C
NSVD            Data Guard Broker NetSlave Process D
NSVE            Data Guard Broker NetSlave Process E
NSVF            Data Guard Broker NetSlave Process F
NSVG            Data Guard Broker NetSlave Process G
NSVH            Data Guard Broker NetSlave Process H
NSVI            Data Guard Broker NetSlave Process I
NSVJ            Data Guard Broker NetSlave Process J
NSVK            Data Guard Broker NetSlave Process K
NSVL            Data Guard Broker NetSlave Process L
NSVM            Data Guard Broker NetSlave Process M
NSVN            Data Guard Broker NetSlave Process N
NSVO            Data Guard Broker NetSlave Process O
NSVP            Data Guard Broker NetSlave Process P
NSVQ            Data Guard Broker NetSlave Process Q
NSVR            Data Guard Broker NetSlave Process R
NSVS            Data Guard Broker NetSlave Process S
NSVT            Data Guard Broker NetSlave Process T
NSVU            Data Guard Broker NetSlave Process U
INSV            Data Guard Broker INstance SlaVe Process
FSFP            Data Guard Broker FSFO Pinger
RBAL            ASM Rebalance master
ARB0            ASM Rebalance 0
ARB1            ASM Rebalance 1
ARB2            ASM Rebalance 2
ARB3            ASM Rebalance 3
ARB4            ASM Rebalance 4
ARB5            ASM Rebalance 5
ARB6            ASM Rebalance 6
ARB7            ASM Rebalance 7
ARB8            ASM Rebalance 8
ARB9            ASM Rebalance 9
ARBA            ASM Rebalance 10
ASMB            ASM Background
MARK            mark AU for resync koordinator
GMON            diskgroup monitor
VBG0            Volume BG 0
VBG1            Volume BG 1
VBG2            Volume BG 2
VBG3            Volume BG 3

NAME            DESCRIPTION
--------------- --------------------------------------------------
VBG4            Volume BG 4
VBG5            Volume BG 5
VBG6            Volume BG 6
VBG7            Volume BG 7
VBG8            Volume BG 8
VBG9            Volume BG 9
VDBG            Volume Driver BG
VMB0            Volume Membership 0
ACFS            ACFS CSS
MMON            Manageability Monitor Process
MMNL            Manageability Monitor Process 2
XDMG            cell automation manager
XDWK            cell automation worker actions

295 rows selected.

++查找表的中间一部分：
SQL> l  
  1  select * from (
  2  select a.*, rownum as rn from dba_segments a
  3  where rownum < 100
  4* ) b where b.rn < 50
++先查找一个表格的一部分，并将表格加上行号的一列
＋＋并将此列命名成一个新字段，并作为主查询表的子句表
＋＋外层查询查询另外一部分条件即可

++开启跟踪计划：
SQL> set autotrace traceonly explain

SQL> select user from dual;

Execution Plan
----------------------------------------------------------
Plan hash value: 1388734953

-----------------------------------------------------------------
| Id  | Operation        | Name | Rows  | Cost (%CPU)| Time     |
-----------------------------------------------------------------
|   0 | SELECT STATEMENT |      |     1 |     2   (0)| 00:00:01 |
|   1 |  FAST DUAL       |      |     1 |     2   (0)| 00:00:01 |
-----------------------------------------------------------------

SQL> r
  1  select * from (
  2  select a.*, rownum as rn from dba_segments a
  3  where rownum < 100
  4* ) b where b.rn < 50

Execution Plan
----------------------------------------------------------
Plan hash value: 3287195197

------------------------------------------------------------------------------------------------------
| Id  | Operation                           | Name           | Rows  | Bytes | Cost (%CPU)| Time     |
------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                    |                |    99 | 33561 |  1453   (1)| 00:00:18 |
|*  1 |  VIEW                               |                |    99 | 33561 |  1453   (1)| 00:00:18 |
|*  2 |   COUNT STOPKEY                     |                |       |       |            |          |
|   3 |    VIEW                             | SYS_DBA_SEGS   |  1449 |   568K|  1453   (1)| 00:00:18 |
|   4 |     UNION-ALL                       |                |       |       |            |          |
|   5 |      NESTED LOOPS OUTER             |                |     1 |   183 |  1375   (1)| 00:00:17 |
|   6 |       NESTED LOOPS                  |                |     1 |   165 |  1374   (1)| 00:00:17 |
|   7 |        NESTED LOOPS                 |                |     1 |   146 |  1373   (1)| 00:00:17 |
|   8 |         NESTED LOOPS                |                |     1 |   137 |  1372   (1)| 00:00:17 |
|*  9 |          HASH JOIN                  |                |     8 |   768 |  1356   (1)| 00:00:17 |
|  10 |           VIEW                      | SYS_OBJECTS    |  7677 |   247K|  1309   (1)| 00:00:16 |
|  11 |            UNION-ALL                |                |       |       |            |          |
|* 12 |             TABLE ACCESS FULL       | TAB$           |  2769 | 63687 |   365   (0)| 00:00:05 |
|  13 |             TABLE ACCESS FULL       | TABPART$       |   106 |  1696 |     3   (0)| 00:00:01 |
|  14 |             TABLE ACCESS FULL       | CLU$           |    10 |   140 |   365   (0)| 00:00:05 |
|* 15 |             TABLE ACCESS FULL       | IND$           |  4663 | 83934 |   365   (0)| 00:00:05 |
|  16 |             TABLE ACCESS FULL       | INDPART$       |   123 |  1968 |     3   (0)| 00:00:01 |
|* 17 |             TABLE ACCESS FULL       | LOB$           |     3 |    60 |   201   (0)| 00:00:03 |
|  18 |             TABLE ACCESS FULL       | TABSUBPART$    |     1 |    52 |     2   (0)| 00:00:01 |
|  19 |             TABLE ACCESS FULL       | INDSUBPART$    |     1 |    52 |     2   (0)| 00:00:01 |
|  20 |             TABLE ACCESS FULL       | LOBFRAG$       |     1 |    17 |     2   (0)| 00:00:01 |
|  21 |           TABLE ACCESS FULL         | SEG$           |  5449 |   335K|    46   (0)| 00:00:01 |
|  22 |          TABLE ACCESS BY INDEX ROWID| OBJ$           |     1 |    41 |     2   (0)| 00:00:01 |
|* 23 |           INDEX RANGE SCAN          | I_OBJ1         |     1 |       |     1   (0)| 00:00:01 |
|  24 |         TABLE ACCESS BY INDEX ROWID | FILE$          |     1 |     9 |     1   (0)| 00:00:01 |
|* 25 |          INDEX UNIQUE SCAN          | I_FILE2        |     1 |       |     0   (0)| 00:00:01 |
|  26 |        TABLE ACCESS CLUSTER         | TS$            |     1 |    19 |     1   (0)| 00:00:01 |
|* 27 |         INDEX UNIQUE SCAN           | I_TS#          |     1 |       |     0   (0)| 00:00:01 |
|  28 |       TABLE ACCESS CLUSTER          | USER$          |     1 |    18 |     1   (0)| 00:00:01 |
|* 29 |        INDEX UNIQUE SCAN            | I_USER#        |     1 |       |     0   (0)| 00:00:01 |
|* 30 |      HASH JOIN OUTER                |                |     7 |  1043 |    23   (9)| 00:00:01 |
|* 31 |       HASH JOIN                     |                |     7 |   917 |    19   (6)| 00:00:01 |
|* 32 |        HASH JOIN                    |                |     7 |   784 |    16   (7)| 00:00:01 |
|  33 |         NESTED LOOPS                |                |     7 |   721 |    13   (0)| 00:00:01 |
|* 34 |          TABLE ACCESS FULL          | UNDO$          |    11 |   407 |     2   (0)| 00:00:01 |
|* 35 |          TABLE ACCESS CLUSTER       | SEG$           |     1 |    66 |     1   (0)| 00:00:01 |
|* 36 |           INDEX UNIQUE SCAN         | I_FILE#_BLOCK# |     1 |       |     0   (0)| 00:00:01 |
|  37 |         TABLE ACCESS FULL           | FILE$          |     4 |    36 |     2   (0)| 00:00:01 |
|  38 |        TABLE ACCESS FULL            | TS$            |     5 |    95 |     3   (0)| 00:00:01 |
|  39 |       TABLE ACCESS FULL             | USER$          |    87 |  1566 |     3   (0)| 00:00:01 |
|* 40 |      HASH JOIN RIGHT OUTER          |                |  1441 |   160K|    56   (4)| 00:00:01 |
|  41 |       TABLE ACCESS FULL             | USER$          |    87 |  1566 |     3   (0)| 00:00:01 |
|* 42 |       HASH JOIN                     |                |  1441 |   135K|    52   (2)| 00:00:01 |
|  43 |        TABLE ACCESS FULL            | TS$            |     5 |    95 |     3   (0)| 00:00:01 |
|* 44 |        HASH JOIN                    |                |  1441 |   108K|    49   (3)| 00:00:01 |
|  45 |         TABLE ACCESS FULL           | FILE$          |     4 |    36 |     2   (0)| 00:00:01 |
|* 46 |         TABLE ACCESS FULL           | SEG$           |  1441 | 97988 |    46   (0)| 00:00:01 |
------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   1 - filter("B"."RN"<50)
   2 - filter(ROWNUM<100)
   9 - access("S"."FILE#"="SO"."HEADER_FILE" AND "S"."BLOCK#"="SO"."HEADER_BLOCK" AND
              "S"."TS#"="SO"."TS_NUMBER" AND "S"."TYPE#"="SO"."SEGMENT_TYPE_ID")
  12 - filter(BITAND("T"."PROPERTY",1024)=0)
  15 - filter("I"."TYPE#"=1 OR "I"."TYPE#"=2 OR "I"."TYPE#"=3 OR "I"."TYPE#"=4 OR
              "I"."TYPE#"=6 OR "I"."TYPE#"=7 OR "I"."TYPE#"=8 OR "I"."TYPE#"=9)
  17 - filter(BITAND("L"."PROPERTY",64)=0 OR BITAND("L"."PROPERTY",128)=128)
  23 - access("O"."OBJ#"="SO"."OBJECT_ID" AND "O"."TYPE#"="SO"."OBJECT_TYPE_ID")
       filter("O"."TYPE#"="SO"."OBJECT_TYPE_ID")
  25 - access("S"."TS#"="F"."TS#" AND "S"."FILE#"="F"."RELFILE#")
  27 - access("S"."TS#"="TS"."TS#")
  29 - access("O"."OWNER#"="U"."USER#"(+))
  30 - access("S"."USER#"="U"."USER#"(+))
  31 - access("S"."TS#"="TS"."TS#")
  32 - access("UN"."TS#"="F"."TS#" AND "UN"."FILE#"="F"."RELFILE#")
  34 - filter("UN"."STATUS$"<>1)
  35 - filter("S"."TYPE#"=1 OR "S"."TYPE#"=10)
  36 - access("S"."TS#"="UN"."TS#" AND "S"."FILE#"="UN"."FILE#" AND
              "S"."BLOCK#"="UN"."BLOCK#")
  40 - access("S"."USER#"="U"."USER#"(+))
  42 - access("S"."TS#"="TS"."TS#")
  44 - access("S"."TS#"="F"."TS#" AND "S"."FILE#"="F"."RELFILE#")
  46 - filter("S"."TYPE#"<>6 AND "S"."TYPE#"<>5 AND "S"."TYPE#"<>8 AND "S"."TYPE#"<>10 AND
              "S"."TYPE#"<>1)
++打开所有跟踪计划：
SQL> set autotrace on
49 rows selected.


Execution Plan
----------------------------------------------------------
Plan hash value: 3287195197

------------------------------------------------------------------------------------------------------
| Id  | Operation                           | Name           | Rows  | Bytes |
Cost (%CPU)| Time     |
------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                    |                |    99 | 33561 |
1453   (1)| 00:00:18 |
|*  1 |  VIEW                               |                |    99 | 33561 |
1453   (1)| 00:00:18 |
|*  2 |   COUNT STOPKEY                     |                |       |       |
|          |
|   3 |    VIEW                             | SYS_DBA_SEGS   |  1449 |   568K|
1453   (1)| 00:00:18 |
|   4 |     UNION-ALL                       |                |       |       |
|          |
|   5 |      NESTED LOOPS OUTER             |                |     1 |   183 |
1375   (1)| 00:00:17 |
|   6 |       NESTED LOOPS                  |                |     1 |   165 |
1374   (1)| 00:00:17 |
|   7 |        NESTED LOOPS                 |                |     1 |   146 |
1373   (1)| 00:00:17 |
|   8 |         NESTED LOOPS                |                |     1 |   137 |
1372   (1)| 00:00:17 |
|*  9 |          HASH JOIN                  |                |     8 |   768 |
1356   (1)| 00:00:17 |
|  10 |           VIEW                      | SYS_OBJECTS    |  7677 |   247K|
1309   (1)| 00:00:16 |
|  11 |            UNION-ALL                |                |       |       |
|          |
|* 12 |             TABLE ACCESS FULL       | TAB$           |  2769 | 63687 |
365   (0)| 00:00:05 |
|  13 |             TABLE ACCESS FULL       | TABPART$       |   106 |  1696 |
3   (0)| 00:00:01 |
|  14 |             TABLE ACCESS FULL       | CLU$           |    10 |   140 |
365   (0)| 00:00:05 |
|* 15 |             TABLE ACCESS FULL       | IND$           |  4663 | 83934 |
365   (0)| 00:00:05 |
|  16 |             TABLE ACCESS FULL       | INDPART$       |   123 |  1968 |
3   (0)| 00:00:01 |
|* 17 |             TABLE ACCESS FULL       | LOB$           |     3 |    60 |
201   (0)| 00:00:03 |
|  18 |             TABLE ACCESS FULL       | TABSUBPART$    |     1 |    52 |
2   (0)| 00:00:01 |
|  19 |             TABLE ACCESS FULL       | INDSUBPART$    |     1 |    52 |
2   (0)| 00:00:01 |
|  20 |             TABLE ACCESS FULL       | LOBFRAG$       |     1 |    17 |
2   (0)| 00:00:01 |
|  21 |           TABLE ACCESS FULL         | SEG$           |  5449 |   335K|
46   (0)| 00:00:01 |
|  22 |          TABLE ACCESS BY INDEX ROWID| OBJ$           |     1 |    41 |
2   (0)| 00:00:01 |
|* 23 |           INDEX RANGE SCAN          | I_OBJ1         |     1 |       |
1   (0)| 00:00:01 |
|  24 |         TABLE ACCESS BY INDEX ROWID | FILE$          |     1 |     9 |
1   (0)| 00:00:01 |
|* 25 |          INDEX UNIQUE SCAN          | I_FILE2        |     1 |       |
0   (0)| 00:00:01 |
|  26 |        TABLE ACCESS CLUSTER         | TS$            |     1 |    19 |
1   (0)| 00:00:01 |
|* 27 |         INDEX UNIQUE SCAN           | I_TS#          |     1 |       |
0   (0)| 00:00:01 |
|  28 |       TABLE ACCESS CLUSTER          | USER$          |     1 |    18 |
1   (0)| 00:00:01 |
|* 29 |        INDEX UNIQUE SCAN            | I_USER#        |     1 |       |
0   (0)| 00:00:01 |
|* 30 |      HASH JOIN OUTER                |                |     7 |  1043 |
23   (9)| 00:00:01 |
|* 31 |       HASH JOIN                     |                |     7 |   917 |
19   (6)| 00:00:01 |
|* 32 |        HASH JOIN                    |                |     7 |   784 |
16   (7)| 00:00:01 |
|  33 |         NESTED LOOPS                |                |     7 |   721 |
13   (0)| 00:00:01 |
|* 34 |          TABLE ACCESS FULL          | UNDO$          |    11 |   407 |
2   (0)| 00:00:01 |
|* 35 |          TABLE ACCESS CLUSTER       | SEG$           |     1 |    66 |
1   (0)| 00:00:01 |
|* 36 |           INDEX UNIQUE SCAN         | I_FILE#_BLOCK# |     1 |       |
0   (0)| 00:00:01 |
|  37 |         TABLE ACCESS FULL           | FILE$          |     4 |    36 |
2   (0)| 00:00:01 |
|  38 |        TABLE ACCESS FULL            | TS$            |     5 |    95 |
3   (0)| 00:00:01 |
|  39 |       TABLE ACCESS FULL             | USER$          |    87 |  1566 |
3   (0)| 00:00:01 |
|* 40 |      HASH JOIN RIGHT OUTER          |                |  1441 |   160K|
56   (4)| 00:00:01 |
|  41 |       TABLE ACCESS FULL             | USER$          |    87 |  1566 |
3   (0)| 00:00:01 |
|* 42 |       HASH JOIN                     |                |  1441 |   135K|
52   (2)| 00:00:01 |
|  43 |        TABLE ACCESS FULL            | TS$            |     5 |    95 |
3   (0)| 00:00:01 |
|* 44 |        HASH JOIN                    |                |  1441 |   108K|
49   (3)| 00:00:01 |
|  45 |         TABLE ACCESS FULL           | FILE$          |     4 |    36 |
2   (0)| 00:00:01 |
|* 46 |         TABLE ACCESS FULL           | SEG$           |  1441 | 97988 |
46   (0)| 00:00:01 |
------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   1 - filter("B"."RN"<50)
   2 - filter(ROWNUM<100)
   9 - access("S"."FILE#"="SO"."HEADER_FILE" AND
"S"."BLOCK#"="SO"."HEADER_BLOCK" AND
              "S"."TS#"="SO"."TS_NUMBER" AND
"S"."TYPE#"="SO"."SEGMENT_TYPE_ID")
  12 - filter(BITAND("T"."PROPERTY",1024)=0)
  15 - filter("I"."TYPE#"=1 OR "I"."TYPE#"=2 OR "I"."TYPE#"=3 OR "I"."TYPE#"=4
OR
              "I"."TYPE#"=6 OR "I"."TYPE#"=7 OR "I"."TYPE#"=8 OR
"I"."TYPE#"=9)
  17 - filter(BITAND("L"."PROPERTY",64)=0 OR BITAND("L"."PROPERTY",128)=128)
  23 - access("O"."OBJ#"="SO"."OBJECT_ID" AND
"O"."TYPE#"="SO"."OBJECT_TYPE_ID")
       filter("O"."TYPE#"="SO"."OBJECT_TYPE_ID")
  25 - access("S"."TS#"="F"."TS#" AND "S"."FILE#"="F"."RELFILE#")
  27 - access("S"."TS#"="TS"."TS#")
  29 - access("O"."OWNER#"="U"."USER#"(+))
  30 - access("S"."USER#"="U"."USER#"(+))
  31 - access("S"."TS#"="TS"."TS#")
  32 - access("UN"."TS#"="F"."TS#" AND "UN"."FILE#"="F"."RELFILE#")
  34 - filter("UN"."STATUS$"<>1)
  35 - filter("S"."TYPE#"=1 OR "S"."TYPE#"=10)
  36 - access("S"."TS#"="UN"."TS#" AND "S"."FILE#"="UN"."FILE#" AND
              "S"."BLOCK#"="UN"."BLOCK#")
  40 - access("S"."USER#"="U"."USER#"(+))
  42 - access("S"."TS#"="TS"."TS#")
  44 - access("S"."TS#"="F"."TS#" AND "S"."FILE#"="F"."RELFILE#")
  46 - filter("S"."TYPE#"<>6 AND "S"."TYPE#"<>5 AND "S"."TYPE#"<>8 AND
"S"."TYPE#"<>10 AND
              "S"."TYPE#"<>1)


Statistics
----------------------------------------------------------
          0  recursive calls
          0  db block gets
        537  consistent gets
          0  physical reads
          0  redo size
       4629  bytes sent via SQL*Net to client
        557  bytes received via SQL*Net from client
          5  SQL*Net roundtrips to/from client
          0  sorts (memory)
          0  sorts (disk)
         49  rows processed

49 rows selected.


Execution Plan
----------------------------------------------------------
Plan hash value: 3287195197

------------------------------------------------------------------------------------------------------
| Id  | Operation                           | Name           | Rows  | Bytes | Cost (%CPU)| Time     |
------------------------------------------------------------------------------------------------------
|   0 | SELECT STATEMENT                    |                |    99 | 33561 |  1453   (1)| 00:00:18 |
|*  1 |  VIEW                               |                |    99 | 33561 |  1453   (1)| 00:00:18 |
|*  2 |   COUNT STOPKEY                     |                |       |       |            |          |
|   3 |    VIEW                             | SYS_DBA_SEGS   |  1449 |   568K|  1453   (1)| 00:00:18 |
|   4 |     UNION-ALL                       |                |       |       |            |          |
|   5 |      NESTED LOOPS OUTER             |                |     1 |   183 |  1375   (1)| 00:00:17 |
|   6 |       NESTED LOOPS                  |                |     1 |   165 |  1374   (1)| 00:00:17 |
|   7 |        NESTED LOOPS                 |                |     1 |   146 |  1373   (1)| 00:00:17 |
|   8 |         NESTED LOOPS                |                |     1 |   137 |  1372   (1)| 00:00:17 |
|*  9 |          HASH JOIN                  |                |     8 |   768 |  1356   (1)| 00:00:17 |
|  10 |           VIEW                      | SYS_OBJECTS    |  7677 |   247K|  1309   (1)| 00:00:16 |
|  11 |            UNION-ALL                |                |       |       |            |          |
|* 12 |             TABLE ACCESS FULL       | TAB$           |  2769 | 63687 |   365   (0)| 00:00:05 |
|  13 |             TABLE ACCESS FULL       | TABPART$       |   106 |  1696 |     3   (0)| 00:00:01 |
|  14 |             TABLE ACCESS FULL       | CLU$           |    10 |   140 |   365   (0)| 00:00:05 |
|* 15 |             TABLE ACCESS FULL       | IND$           |  4663 | 83934 |   365   (0)| 00:00:05 |
|  16 |             TABLE ACCESS FULL       | INDPART$       |   123 |  1968 |     3   (0)| 00:00:01 |
|* 17 |             TABLE ACCESS FULL       | LOB$           |     3 |    60 |   201   (0)| 00:00:03 |
|  18 |             TABLE ACCESS FULL       | TABSUBPART$    |     1 |    52 |     2   (0)| 00:00:01 |
|  19 |             TABLE ACCESS FULL       | INDSUBPART$    |     1 |    52 |     2   (0)| 00:00:01 |
|  20 |             TABLE ACCESS FULL       | LOBFRAG$       |     1 |    17 |     2   (0)| 00:00:01 |
|  21 |           TABLE ACCESS FULL         | SEG$           |  5449 |   335K|    46   (0)| 00:00:01 |
|  22 |          TABLE ACCESS BY INDEX ROWID| OBJ$           |     1 |    41 |     2   (0)| 00:00:01 |
|* 23 |           INDEX RANGE SCAN          | I_OBJ1         |     1 |       |     1   (0)| 00:00:01 |
|  24 |         TABLE ACCESS BY INDEX ROWID | FILE$          |     1 |     9 |     1   (0)| 00:00:01 |
|* 25 |          INDEX UNIQUE SCAN          | I_FILE2        |     1 |       |     0   (0)| 00:00:01 |
|  26 |        TABLE ACCESS CLUSTER         | TS$            |     1 |    19 |     1   (0)| 00:00:01 |
|* 27 |         INDEX UNIQUE SCAN           | I_TS#          |     1 |       |     0   (0)| 00:00:01 |
|  28 |       TABLE ACCESS CLUSTER          | USER$          |     1 |    18 |     1   (0)| 00:00:01 |
|* 29 |        INDEX UNIQUE SCAN            | I_USER#        |     1 |       |     0   (0)| 00:00:01 |
|* 30 |      HASH JOIN OUTER                |                |     7 |  1043 |    23   (9)| 00:00:01 |
|* 31 |       HASH JOIN                     |                |     7 |   917 |    19   (6)| 00:00:01 |
|* 32 |        HASH JOIN                    |                |     7 |   784 |    16   (7)| 00:00:01 |
|  33 |         NESTED LOOPS                |                |     7 |   721 |    13   (0)| 00:00:01 |
|* 34 |          TABLE ACCESS FULL          | UNDO$          |    11 |   407 |     2   (0)| 00:00:01 |
|* 35 |          TABLE ACCESS CLUSTER       | SEG$           |     1 |    66 |     1   (0)| 00:00:01 |
|* 36 |           INDEX UNIQUE SCAN         | I_FILE#_BLOCK# |     1 |       |     0   (0)| 00:00:01 |
|  37 |         TABLE ACCESS FULL           | FILE$          |     4 |    36 |     2   (0)| 00:00:01 |
|  38 |        TABLE ACCESS FULL            | TS$            |     5 |    95 |     3   (0)| 00:00:01 |
|  39 |       TABLE ACCESS FULL             | USER$          |    87 |  1566 |     3   (0)| 00:00:01 |
|* 40 |      HASH JOIN RIGHT OUTER          |                |  1441 |   160K|    56   (4)| 00:00:01 |
|  41 |       TABLE ACCESS FULL             | USER$          |    87 |  1566 |     3   (0)| 00:00:01 |
|* 42 |       HASH JOIN                     |                |  1441 |   135K|    52   (2)| 00:00:01 |
|  43 |        TABLE ACCESS FULL            | TS$            |     5 |    95 |     3   (0)| 00:00:01 |
|* 44 |        HASH JOIN                    |                |  1441 |   108K|    49   (3)| 00:00:01 |
|  45 |         TABLE ACCESS FULL           | FILE$          |     4 |    36 |     2   (0)| 00:00:01 |
|* 46 |         TABLE ACCESS FULL           | SEG$           |  1441 | 97988 |    46   (0)| 00:00:01 |
------------------------------------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   1 - filter("B"."RN"<50)
   2 - filter(ROWNUM<100)
   9 - access("S"."FILE#"="SO"."HEADER_FILE" AND "S"."BLOCK#"="SO"."HEADER_BLOCK" AND
              "S"."TS#"="SO"."TS_NUMBER" AND "S"."TYPE#"="SO"."SEGMENT_TYPE_ID")
  12 - filter(BITAND("T"."PROPERTY",1024)=0)
  15 - filter("I"."TYPE#"=1 OR "I"."TYPE#"=2 OR "I"."TYPE#"=3 OR "I"."TYPE#"=4 OR
              "I"."TYPE#"=6 OR "I"."TYPE#"=7 OR "I"."TYPE#"=8 OR "I"."TYPE#"=9)
  17 - filter(BITAND("L"."PROPERTY",64)=0 OR BITAND("L"."PROPERTY",128)=128)
  23 - access("O"."OBJ#"="SO"."OBJECT_ID" AND "O"."TYPE#"="SO"."OBJECT_TYPE_ID")
       filter("O"."TYPE#"="SO"."OBJECT_TYPE_ID")
  25 - access("S"."TS#"="F"."TS#" AND "S"."FILE#"="F"."RELFILE#")
  27 - access("S"."TS#"="TS"."TS#")
  29 - access("O"."OWNER#"="U"."USER#"(+))
  30 - access("S"."USER#"="U"."USER#"(+))
  31 - access("S"."TS#"="TS"."TS#")
  32 - access("UN"."TS#"="F"."TS#" AND "UN"."FILE#"="F"."RELFILE#")
  34 - filter("UN"."STATUS$"<>1)
  35 - filter("S"."TYPE#"=1 OR "S"."TYPE#"=10)
  36 - access("S"."TS#"="UN"."TS#" AND "S"."FILE#"="UN"."FILE#" AND
              "S"."BLOCK#"="UN"."BLOCK#")
  40 - access("S"."USER#"="U"."USER#"(+))
  42 - access("S"."TS#"="TS"."TS#")
  44 - access("S"."TS#"="F"."TS#" AND "S"."FILE#"="F"."RELFILE#")
  46 - filter("S"."TYPE#"<>6 AND "S"."TYPE#"<>5 AND "S"."TYPE#"<>8 AND "S"."TYPE#"<>10 AND
              "S"."TYPE#"<>1)


Statistics
----------------------------------------------------------
          0  recursive calls
          0  db block gets
        537  consistent gets
          0  physical reads
          0  redo size
       4629  bytes sent via SQL*Net to client
        557  bytes received via SQL*Net from client
          5  SQL*Net roundtrips to/from client
          0  sorts (memory)
          0  sorts (disk)
         49  rows processed

++关闭执行计划：
SQL> set autotrace off

++添加表描述：
SQL> comment on table student is '学生表';

Comment created.

++查看表描述：
SQL> select * from user_tab_comments where table_name = 'STUDENT';

TABLE_NAME           TABLE_TYPE                        COMMENTS
-------------------- --------------------------------- --------------------
STUDENT              TABLE                             学生表

++添加表列描述及其查看方法：
SQL> comment on column student.sname is '名字'; 

Comment created.

SQL> select * from user_col_comments where table_name = 'STUDENT';

TABLE_NAME           COLUMN_NAME          COMMENTS
-------------------- -------------------- --------------------
STUDENT              SNO
STUDENT              SNAME                名字
STUDENT              SAGE
STUDENT              SSEX


=============
++设置sqlplus环境：
++set time
++设置命令提示行是否显示时间
SQL> show linesize  
linesize 80
SQL> set time on
10:09:56 SQL> set time off
SQL> 
++set pagesize
++设置每页行数：
SQL> set pagesize 10
SQL> r   
  1  select user_id, username, account_status
  2* from dba_users

    USER_ID USERNAME             ACCOUNT_STATUS
----------- -------------------- --------------------
         74 MGMT_VIEW            OPEN
          0 SYS                  OPEN
          5 SYSTEM               OPEN
         30 DBSNMP               OPEN
         72 SYSMAN               OPEN
          9 OUTLN                EXPIRED & LOCKED
         75 FLOWS_FILES          EXPIRED & LOCKED

    USER_ID USERNAME             ACCOUNT_STATUS
----------- -------------------- --------------------
         57 MDSYS                EXPIRED & LOCKED
         53 ORDSYS               EXPIRED & LOCKED
         42 EXFSYS               EXPIRED & LOCKED
         32 WMSYS                EXPIRED & LOCKED
         31 APPQOSSYS            EXPIRED & LOCKED
         78 APEX_030200          EXPIRED & LOCKED
         83 OWBSYS_AUDIT         EXPIRED & LOCKED

    USER_ID USERNAME             ACCOUNT_STATUS
----------- -------------------- --------------------
         54 ORDDATA              EXPIRED & LOCKED
         43 CTXSYS               EXPIRED & LOCKED
         46 ANONYMOUS            EXPIRED & LOCKED
         45 XDB                  EXPIRED & LOCKED
         55 ORDPLUGINS           EXPIRED & LOCKED
         79 OWBSYS               EXPIRED & LOCKED
         56 SI_INFORMTN_SCHEMA   EXPIRED & LOCKED

    USER_ID USERNAME             ACCOUNT_STATUS
----------- -------------------- --------------------
         61 OLAPSYS              EXPIRED & LOCKED
         84 SCOTT                EXPIRED & LOCKED
         21 ORACLE_OCM           EXPIRED & LOCKED
 2147483638 XS$NULL              EXPIRED & LOCKED
         65 MDDATA               EXPIRED & LOCKED
         14 DIP                  EXPIRED & LOCKED
         76 APEX_PUBLIC_USER     EXPIRED & LOCKED

    USER_ID USERNAME             ACCOUNT_STATUS
----------- -------------------- --------------------
         70 SPATIAL_CSW_ADMIN_US EXPIRED & LOCKED
            R

         67 SPATIAL_WFS_ADMIN_US EXPIRED & LOCKED
            R


30 rows selected.

++set newpage
++设置每一页空行的数量：
SQL> set newpage 4
SQL> show newpage
newpage 4
SQL> r  
  1  select user_id, username, account_status
  2* from dba_users




    USER_ID USERNAME             ACCOUNT_STATUS
----------- -------------------- --------------------
         74 MGMT_VIEW            OPEN
          0 SYS                  OPEN
          5 SYSTEM               OPEN
         30 DBSNMP               OPEN




    USER_ID USERNAME             ACCOUNT_STATUS
----------- -------------------- --------------------
         72 SYSMAN               OPEN
          9 OUTLN                EXPIRED & LOCKED
         75 FLOWS_FILES          EXPIRED & LOCKED
         57 MDSYS                EXPIRED & LOCKED




    USER_ID USERNAME             ACCOUNT_STATUS
----------- -------------------- --------------------
         53 ORDSYS               EXPIRED & LOCKED
         42 EXFSYS               EXPIRED & LOCKED
         32 WMSYS                EXPIRED & LOCKED
         31 APPQOSSYS            EXPIRED & LOCKED




    USER_ID USERNAME             ACCOUNT_STATUS
----------- -------------------- --------------------
         78 APEX_030200          EXPIRED & LOCKED
         83 OWBSYS_AUDIT         EXPIRED & LOCKED
         54 ORDDATA              EXPIRED & LOCKED
         43 CTXSYS               EXPIRED & LOCKED




    USER_ID USERNAME             ACCOUNT_STATUS
----------- -------------------- --------------------
         46 ANONYMOUS            EXPIRED & LOCKED
         45 XDB                  EXPIRED & LOCKED
         55 ORDPLUGINS           EXPIRED & LOCKED
         79 OWBSYS               EXPIRED & LOCKED




    USER_ID USERNAME             ACCOUNT_STATUS
----------- -------------------- --------------------
         56 SI_INFORMTN_SCHEMA   EXPIRED & LOCKED
         61 OLAPSYS              EXPIRED & LOCKED
         84 SCOTT                EXPIRED & LOCKED
         21 ORACLE_OCM           EXPIRED & LOCKED




    USER_ID USERNAME             ACCOUNT_STATUS
----------- -------------------- --------------------
 2147483638 XS$NULL              EXPIRED & LOCKED
         65 MDDATA               EXPIRED & LOCKED
         14 DIP                  EXPIRED & LOCKED
         76 APEX_PUBLIC_USER     EXPIRED & LOCKED




    USER_ID USERNAME             ACCOUNT_STATUS
----------- -------------------- --------------------
         70 SPATIAL_CSW_ADMIN_US EXPIRED & LOCKED
            R

         67 SPATIAL_WFS_ADMIN_US EXPIRED & LOCKED




    USER_ID USERNAME             ACCOUNT_STATUS
----------- -------------------- --------------------
            R


30 rows selected.

++set pause
++设置每一页显示是否停顿，停顿则每次回车继续
＋＋不停顿则直接显示完
++以下是设置停顿，并且每页显示结束后提示按enter继续
SQL> set pause "press enter continue"
SQL> set pause on
SQL> r  
  1  select user_id, username, account_status
  2* from dba_users
press enter continue




    USER_ID USERNAME             ACCOUNT_STATUS
----------- -------------------- --------------------
         74 MGMT_VIEW            OPEN
          0 SYS                  OPEN
          5 SYSTEM               OPEN
         30 DBSNMP               OPEN
press enter continue




    USER_ID USERNAME             ACCOUNT_STATUS
----------- -------------------- --------------------
         72 SYSMAN               OPEN
          9 OUTLN                EXPIRED & LOCKED
         75 FLOWS_FILES          EXPIRED & LOCKED
         57 MDSYS                EXPIRED & LOCKED
press enter continue




    USER_ID USERNAME             ACCOUNT_STATUS
----------- -------------------- --------------------
         53 ORDSYS               EXPIRED & LOCKED
         42 EXFSYS               EXPIRED & LOCKED
         32 WMSYS                EXPIRED & LOCKED
         31 APPQOSSYS            EXPIRED & LOCKED
press enter continue




    USER_ID USERNAME             ACCOUNT_STATUS
----------- -------------------- --------------------
         78 APEX_030200          EXPIRED & LOCKED
         83 OWBSYS_AUDIT         EXPIRED & LOCKED
         54 ORDDATA              EXPIRED & LOCKED
         43 CTXSYS               EXPIRED & LOCKED
press enter continue




    USER_ID USERNAME             ACCOUNT_STATUS
----------- -------------------- --------------------
         46 ANONYMOUS            EXPIRED & LOCKED
         45 XDB                  EXPIRED & LOCKED
         55 ORDPLUGINS           EXPIRED & LOCKED
         79 OWBSYS               EXPIRED & LOCKED
press enter continue




    USER_ID USERNAME             ACCOUNT_STATUS
----------- -------------------- --------------------
         56 SI_INFORMTN_SCHEMA   EXPIRED & LOCKED
         61 OLAPSYS              EXPIRED & LOCKED
         84 SCOTT                EXPIRED & LOCKED
         21 ORACLE_OCM           EXPIRED & LOCKED
press enter continue




    USER_ID USERNAME             ACCOUNT_STATUS
----------- -------------------- --------------------
 2147483638 XS$NULL              EXPIRED & LOCKED
         65 MDDATA               EXPIRED & LOCKED
         14 DIP                  EXPIRED & LOCKED
         76 APEX_PUBLIC_USER     EXPIRED & LOCKED
press enter continue




    USER_ID USERNAME             ACCOUNT_STATUS
----------- -------------------- --------------------
         70 SPATIAL_CSW_ADMIN_US EXPIRED & LOCKED
            R

         67 SPATIAL_WFS_ADMIN_US EXPIRED & LOCKED
press enter continue




    USER_ID USERNAME             ACCOUNT_STATUS
----------- -------------------- --------------------
            R


30 rows selected.

++set numformat
＋＋设置数字显示格式
SQL> set numformat $999,999.00
SQL> r  
  1* select * from student




SNO                  SNAME                        SAGE SSEX
-------------------- -------------------- ------------ --------------------
s001                 张三                       $23.00 男
s002                 李四                       $23.00 男
s003                 吴鹏                       $25.00 男
s004                 琴沁                       $20.00 女




SNO                  SNAME                        SAGE SSEX
-------------------- -------------------- ------------ --------------------
s005                 王丽                       $20.00 女
s006                 李波                       $21.00 男
s007                 刘玉                       $21.00 男
s008                 萧蓉                       $21.00 女




SNO                  SNAME                        SAGE SSEX
-------------------- -------------------- ------------ --------------------
s009                 陈萧晓                     $23.00 女
s010                 陈美                       $22.00 女

10 rows selected.

++常用sqlplus命令：
++help命令，查看sqlplus命令的用法：
SQL> help startup

 STARTUP
 -------

 Starts an Oracle instance with several options, including mounting,
 and opening a database.

 STARTUP options | upgrade_options

 where options has the following syntax:
    [FORCE] [RESTRICT] [PFILE=filename] [QUIET] [ MOUNT [dbname] |
    [ OPEN [open_options] [dbname] ] |
    NOMOUNT ]

 where open_options has the following syntax:
    READ {ONLY | WRITE [RECOVER]} | RECOVER

 and where upgrade_options has the following syntax:
    [PFILE=filename] {UPGRADE | DOWNGRADE} [QUIET]


++help index
++查看sqlplus命令清单：
Enter Help [topic] for help.

 @             COPY         PAUSE                    SHUTDOWN
 @@            DEFINE       PRINT                    SPOOL
 /             DEL          PROMPT                   SQLPLUS
 ACCEPT        DESCRIBE     QUIT                     START
 APPEND        DISCONNECT   RECOVER                  STARTUP
 ARCHIVE LOG   EDIT         REMARK                   STORE
 ATTRIBUTE     EXECUTE      REPFOOTER                TIMING
 BREAK         EXIT         REPHEADER                TTITLE
 BTITLE        GET          RESERVED WORDS (SQL)     UNDEFINE
 CHANGE        HELP         RESERVED WORDS (PL/SQL)  VARIABLE
 CLEAR         HOST         RUN                      WHENEVER OSERROR
 COLUMN        INPUT        SAVE                     WHENEVER SQLERROR
 COMPUTE       LIST         SET                      XQUERY
 CONNECT       PASSWORD     SHOW

++describe 命令
＋＋查看表结构：
SQL> describe student;
 Name                                      Null?    Type
 ----------------------------------------- -------- ----------------------------
 SNO                                       NOT NULL VARCHAR2(10)
 SNAME                                              VARCHAR2(20)
 SAGE                                               NUMBER(2)
 SSEX                                               VARCHAR2(5)

++describe命令在其他语句执行过程当中，临时调用的方法：
SQL> select     
  2  #describe student
 Name                                      Null?    Type
 ----------------------------------------- -------- ----------------------------
 SNO                                       NOT NULL VARCHAR2(10)
 SNAME                                              VARCHAR2(20)
 SAGE                                               NUMBER(2)
 SSEX                                               VARCHAR2(5)

  2  sno, sname, sage, ssex
  3  from student;

SNO                  SNAME                        SAGE SSEX
-------------------- -------------------- ------------ --------------------
s001                 张三                       $23.00 男
s002                 李四                       $23.00 男
s003                 吴鹏                       $25.00 男
s004                 琴沁                       $20.00 女
s005                 王丽                       $20.00 女
s006                 李波                       $21.00 男
s007                 刘玉                       $21.00 男
s008                 萧蓉                       $21.00 女
s009                 陈萧晓                     $23.00 女
s010                 陈美                       $22.00 女

10 rows selected.

++define variable_name="value"
＋＋定义一个字符串：
++以下为定义和查看内容
SQL> define tmp_value="this is tmp value"
SQL> define tmp_value
DEFINE TMP_VALUE       = "this is tmp value" (CHAR)

++编辑器设定：
++查看编辑器变量设置
SQL> define _editor   
DEFINE _EDITOR         = "ed" (CHAR)
SQL> define _editor=/usr/bin/vim
SQL> edit
++以下为在vim中编辑的内容
select * from student
/
++修改为：
select sno from student
＋＋:w保存退出
++用vim的模行模式结束编辑，退出编辑
Wrote file afiedt.buf

  1* select sno from student
＋＋执行缓冲区的命令如下：
SQL> r
  1* select sno from student

SNO
------------------------------
s001
s002
s003
s004
s005
s006
s007
s008
s009
s010

10 rows selected.

++get获得文件的内容到缓存区：
++nolist不显示加载的内容，list显示加载的内容
SQL> get tmp nolist
SQL> get tmp list
  1  select * from (
  2  select a.*, rownum as rn from dba_segments a
  3  where rownum < 100
  4* ) b where b.rn < 50
++设置字段的列标题
++column heading
SQL> column sno heading 学号
SQL> select * from student;

学号                 SNAME                        SAGE SSEX
-------------------- -------------------- ------------ --------------------
s001                 张三                       $23.00 男
s002                 李四                       $23.00 男
s003                 吴鹏                       $25.00 男
s004                 琴沁                       $20.00 女
s005                 王丽                       $20.00 女
s006                 李波                       $21.00 男
s007                 刘玉                       $21.00 男
s008                 萧蓉                       $21.00 女
s009                 陈萧晓                     $23.00 女
s010                 陈美                       $22.00 女

10 rows selected.

++查看列的信息，包括列标题
SQL> column sno
COLUMN   sno ON
HEADING  '学号'
FORMAT   a20

++空行值显示设置：
++column column_name null '显示内容'
SQL> column score null '空'
SQL> select * from sc where score is null;

SNO                  CNO                       SCORE
-------------------- -------------------- ----------
tmp001               tmp001               空

++列属性的显示与关闭：
SQL> column score on
SQL> select * from sc where score is null;

SNO                  CNO                        成绩
-------------------- -------------------- ----------
tmp001               tmp001               空

++关闭属性显示，查看表，已经不存在属性显示
++查看属性，还是在的
SQL> column score off 
SQL> select * from sc where score is null;

SNO                  CNO                       SCORE
-------------------- -------------------- ----------
tmp001               tmp001

SQL> column score
COLUMN   score OFF
HEADING  '成绩'
NULL     '空'

++设置字段文字折行：
++默认的折行规则和wrapped是一致的
SQL> select * from sc;

SNO  CNO                       SCORE
---- -------------------- ----------
aaaa
a bb

s003 c001                       81.9
s004 c001                       60.9
s001 c002                       82.9
s002 c002                       72.9
s003 c002                       81.9
s001 c003                         59
s001 c004                         58
s005 c001                       81.9

9 rows selected.

SQL> column sno  
COLUMN   sno ON
FORMAT   a4
SQL> column sno wrapped
SQL> column sno
COLUMN   sno ON
FORMAT   a4
wrap 
SQL> select * from sc;

SNO  CNO                       SCORE
---- -------------------- ----------
aaaa
a bb

s003 c001                       81.9
s004 c001                       60.9
s001 c002                       82.9
s002 c002                       72.9
s003 c002                       81.9
s001 c003                         59
s001 c004                         58
s005 c001                       81.9

9 rows selected.

++设置字段按单词文字折行
++折行规则是先满足一行能放下最多的字符的前提
＋＋当一行放不下一个整个单词，就只好强行折行

SQL> column sno word_wrapped
SQL> column sno
COLUMN   sno ON
FORMAT   a4
word_wrap 
SQL> select * from sc;

SNO  CNO                       SCORE
---- -------------------- ----------
aaaa
a bb

s003 c001                       81.9
s004 c001                       60.9
s001 c002                       82.9
s002 c002                       72.9
s003 c002                       81.9
s001 c003                         59
s001 c004                         58
s005 c001                       81.9

9 rows selected.

++而如果一行有放一个而放不下两行时，此时单词按单词折行就发挥条件了，此时单词被分别放在两行
SQL> column sno format a7
SQL> select * from sc;

SNO     CNO                       SCORE
------- -------------------- ----------
aaaaa
bb

s003    c001                       81.9
s004    c001                       60.9
s001    c002                       82.9
s002    c002                       72.9
s003    c002                       81.9
s001    c003                         59
s001    c004                         58
s005    c001                       81.9

9 rows selected.

＋＋分页效果：
SQL> select * from student;

学生表
SNO        SNAME                      SAGE SSEX
---------- -------------------- ---------- ----------
s001       张三                         23 男
s002       李四                         23 男
s003       吴鹏                         25 男
s004       琴沁                         20 女
s005       王丽                         20 女
s006       李波                         21 男
s007       刘玉                         21 男
s008       萧蓉                         21 女
s009       陈萧晓                       23 女
打印日期：2017.2.27 打印人：张赢

学生表
SNO        SNAME                      SAGE SSEX
---------- -------------------- ---------- ----------
s010       陈美                         22 女








打印日期：2017.2.27 打印人：张赢

10 rows selected.

＋＋表头和表弟命令对所有表都起一样的作用

++使用变量设置表头和表底
SQL> define varT='学生表'
SQL> define varB='打印日期：2017.2.27 打印人：张赢'
SQL> ttitle left varT
SQL> btitle left varB
SQL> select * from sc;

学生表
SNO        CNO                       SCORE
---------- -------------------- ----------
s003       c001                       81.9
s004       c001                       60.9
s001       c002                       82.9
s002       c002                       72.9
s003       c002                       81.9
s001       c003                         59
s001       c004                         58
s005       c001                       81.9

打印日期：2017.2.27 打印人：张赢

8 rows selected.

++关闭表头和表底：
SQL> ttitle off
SQL> btitle off
SQL> select * from sc;

SNO        CNO                       SCORE
---------- -------------------- ----------
s003       c001                       81.9
s004       c001                       60.9
s001       c002                       82.9
s002       c002                       72.9
s003       c002                       81.9
s001       c003                         59
s001       c004                         58
s005       c001                       81.9

8 rows selected.

++ascii函数以及chr函数，分别是将字符转成ascii码和ascii码转字符：
SQL> select ascii('z'), chr(ascii('z') - 1) from dual;

ASCII('Z') CHR
---------- ---
       122 y
++连接字符串函数：哪个不为空返回哪个，都为空则返回空：
SQL> select concat('Hello ', 'World!') information
  2  from dual;

INFORMATION
------------------------------------
Hello World!

++将所有单词首字母大写函数：
SQL> select initcap('oh my god!') information
  2  from dual;

INFORMATION
------------------------------
Oh My God!

++搜索字串所在位置函数：
++搜索'1'这个字串，在'oracle 11g'的第3个位置开始，第2次出现的位置：
SQL> select instr('oracle 11g', '1', 3, 2) position
  2  from dual;

  POSITION
----------
         9
++求字符串长度函数：
++找到emp表中，ename列长度超过5的记录：
SQL> select ename from emp where length(ename) > 5;

ENAME
----------
MARTIN
TURNER
MILLER

++去除字符函数：
++第二个参数要传入，则去掉指定字符，不指定就默认去处空格
SQL> r 
  1  select ltrim('##east##', '#'), rtrim('##east##', '#'), trim(' east '), '
east '
  2* from dual

LTRIM('##EAST##',' RTRIM('##EAST##',' TRIM('EAST') 'EAST'
------------------ ------------------ ------------ ------------------
east##             ##east             east          east

++替换函数：
++如果地三个参数不填，则默认将查找第二个字符替换为空：
SQL> select replace('bad luck bad girl', 'bad', 'good')
  2  from dual;

REPLACE('BADLUCKBADGIRL','BAD','GOOD')
---------------------------------------------------------
good luck good girl

++字符串截取函数：
＋＋如果第三个参数省略，则默认取到字符串的结尾：
SQL> select substr('12345678', 2, 3) from dual;

SUBSTR('1
---------
234

++返回大于或等于n的最小整数：
SQL> select ceil(7.3), ceil(-7.3), ceil(7) from dual
  2  ;

 CEIL(7.3) CEIL(-7.3)    CEIL(7)
---------- ---------- ----------
         8         -7          7

++四舍五入函数：
SQL> select round(3.1415926,2) from dual;

ROUND(3.1415926,2)
------------------
              3.14

++乘方（幂）函数：
SQL> select power(2, -3) from dual;

POWER(2,-3)
-----------
       .125

++日期函数：
++返回系统日期函数：
SQL> select sysdate from dual;

SYSDATE
---------------
05-MAR-17

++月份计算：
＋＋将日期加上几个月之后得到的日期：
SQL> select sysdate, add_months(sysdate, 6) from dual;

SYSDATE         ADD_MONTHS(SYSD
--------------- ---------------
05-MAR-17       05-SEP-17

++支持负数，表示减去几个月的意思：
SQL> select sysdate, add_months(sysdate, -1) from dual;

SYSDATE         ADD_MONTHS(SYSD
--------------- ---------------
05-MAR-17       05-FEB-17


++按表达式转成字符串：
SQL> select sysdate as 默认格式日期,
  2  to_char(sysdate, 'YYYY-MM-DD')
  3  from dual;

A格式日期       TO_CHAR(SYSDATE,'YYYY-MM-DD')
--------------- ------------------------------
09-MAR-17       2017-03-09

++数字转换函数
＋＋将ff的按两位16进制转成10进制数：
SQL> select to_number('ff', 'xx') from dual;

TO_NUMBER('FF','XX')
--------------------
                 255

++关联子查询，内层查询依赖外层查询提供的变量等：
SQL> select empno, ename, sal
  2  from emp f
  3  where sal > (select avg(sal) from emp where job = f.job)
  4  order by job;

     EMPNO ENAME             SAL
---------- ---------- ----------
      7876 ADAMS            1100
      7934 MILLER           1300
      7566 JONES            2975
      7698 BLAKE            2850
      7499 ALLEN            1600
      7844 TURNER           1500

6 rows selected.


++保存点用法：
++插入一条数据并设置保存点sp1
SQL> insert into t1 (id, name, score)
  2  values ('01', 't01', 99);

1 row created.

SQL> savepoint sp1;

Savepoint created.

＋＋查看本连接数据库状态，已经变化
SQL> select * from t1;

ID         NAME            SCORE
---------- ---------- ----------
01         t01                99
           好
++打开个新的数据库会话连接，并查询结果，数据库没有变化：
SQL> select * from t1;

ID         NAME            SCORE
---------- ---------- ----------
           好

++说明事物未被提交，保存点只影响当前会话

++再插入一条数据，并设置保存点
SQL> insert into t1 (id, name, score)
  2  values ('02', 't02', 98);

1 row created.

SQL> savepoint sp2;

Savepoint created.

SQL> select * from t1;

ID         NAME            SCORE
---------- ---------- ----------
01         t01                99
02         t02                98
           好

++会滚到前一个保存点sp1
SQL> rollback to savepoint sp1;

Rollback complete.

＋＋查看回滚后的结果可以看出，内容变成了前一个保存点的内容：
SQL> select * from t1;

ID         NAME            SCORE
---------- ---------- ----------
01         t01                99
           好

++在另外一个回话中查询数据库结果，回滚到保存点不影响提交
SQL> select * from t1;

ID         NAME            SCORE
---------- ---------- ----------
           好

++执行提交
SQL> commit;

Commit complete.

++在当前连接中查询结果：
SQL> select * from t1;

ID         NAME            SCORE
---------- ---------- ----------
01         t01                99
           好

++在另外的回话中查询结果：
SQL> select * from t1;

ID         NAME            SCORE
---------- ---------- ----------
01         t01                99
           好

＋＋最终保存点的内容被最终提交到数据库了。

++查看控制文件参数值：
SQL> show parameter control_files;

NAME                                 TYPE
------------------------------------ ---------------------------------
VALUE
------------------------------
control_files                        string
/home/oracle/app/oradata/orcl/
control01.ctl, /home/oracle/ap
p/recovery_area/orcl/control02
.ctl

++修改控制文件参数：
SQL> l  
  1  alter system set control_files=
  2  '/home/oracle/app/oradata/orcl/control01.ctl',
  3  '/home/oracle/app/recovery_area/orcl/control02.ctl',
  4  '/home/oracle/tmp/oraclefiles/controlfiles/control03.ctl'
  5* scope=spfile
SQL> /

System altered.

SQL> show  parameter control_files;

NAME                                 TYPE
------------------------------------ ---------------------------------
VALUE
------------------------------
control_files                        string
/home/oracle/app/oradata/orcl/
control01.ctl, /home/oracle/ap
p/recovery_area/orcl/control02
.ctl

++并没有发生什么改变，现在停止数据库复制文件再重启：

++停止数据库
SQL> shutdown immediate
Database closed.
Database dismounted.
ORACLE instance shut down.

++复制文件
[oracle@ctos oracle]$ cp /home/oracle/app/oradata/orcl/control01.ctl /home/oracle/tmp/oraclefiles/controlfiles/control03.ctl


SQL> startup 
ORACLE instance started.

Total System Global Area  839282688 bytes
Fixed Size                  2217992 bytes
Variable Size             650119160 bytes
Database Buffers          180355072 bytes
Redo Buffers                6590464 bytes
Database mounted.
Database opened.

++查询结果:
SQL> select name from v$controlfile; 

NAME
--------------------------------------------------------------------------------
/home/oracle/app/oradata/orcl/control01.ctl
/home/oracle/app/recovery_area/orcl/control02.ctl
/home/oracle/tmp/oraclefiles/controlfiles/control03.ctl

++参数也相应的变过来了：
SQL> show  parameter control_files;

NAME                                 TYPE
------------------------------------ ---------------------------------
VALUE
------------------------------
control_files                        string
/home/oracle/app/oradata/orcl/
control01.ctl, /home/oracle/ap
p/recovery_area/orcl/control02
.ctl, /home/oracle/tmp/oraclef
iles/controlfiles/control03.ct
l

++直接创建数据库日志文件：
++查看日志文件列表视图：

SQL> select member from v$logfile;

MEMBER
--------------------------------------------------------------------------------
/home/oracle/app/oradata/orcl/redo03.log
/home/oracle/app/oradata/orcl/redo02.log
/home/oracle/app/oradata/orcl/redo01.log

++查看数据文件：

SQL> select name from v$datafile;

NAME
--------------------------------------------------------------------------------
/home/oracle/app/oradata/orcl/system01.dbf
/home/oracle/app/oradata/orcl/sysaux01.dbf
/home/oracle/app/oradata/orcl/undotbs01.dbf
/home/oracle/app/oradata/orcl/users01.dbf


++查看数据库文件字段信息：

SQL> select * from v$controlfile_record_section;

TYPE
--------------------------------------------------------------------------------
RECORD_SIZE RECORDS_TOTAL RECORDS_USED FIRST_INDEX LAST_INDEX LAST_RECID
----------- ------------- ------------ ----------- ---------- ----------
DATABASE
        316             1            1           0          0          0

CKPT PROGRESS
       8180            11            0           0          0          0

REDO THREAD
        256             8            1           0          0          0


TYPE
--------------------------------------------------------------------------------
RECORD_SIZE RECORDS_TOTAL RECORDS_USED FIRST_INDEX LAST_INDEX LAST_RECID
----------- ------------- ------------ ----------- ---------- ----------
REDO LOG
         72            16            3           0          0          3

DATAFILE
        520           100            4           0          0         39

FILENAME
        524          2298            8           0          0          0


TYPE
--------------------------------------------------------------------------------
RECORD_SIZE RECORDS_TOTAL RECORDS_USED FIRST_INDEX LAST_INDEX LAST_RECID
----------- ------------- ------------ ----------- ---------- ----------
TABLESPACE
         68           100            5           0          0          1

TEMPORARY FILENAME
         56           100            1           0          0          1

RMAN CONFIGURATION
       1108            50            0           0          0          0


TYPE
--------------------------------------------------------------------------------
RECORD_SIZE RECORDS_TOTAL RECORDS_USED FIRST_INDEX LAST_INDEX LAST_RECID
----------- ------------- ------------ ----------- ---------- ----------
LOG HISTORY
         56           292           51           1         51         51

OFFLINE RANGE
        200           163            0           0          0          0

ARCHIVED LOG
        584            28            0           0          0          0


TYPE
--------------------------------------------------------------------------------
RECORD_SIZE RECORDS_TOTAL RECORDS_USED FIRST_INDEX LAST_INDEX LAST_RECID
----------- ------------- ------------ ----------- ---------- ----------
BACKUP SET
         40           409           31           1         31         31

BACKUP PIECE
        736           200           31           1         31         31

BACKUP DATAFILE
        200           245           76           1         76         76


TYPE
--------------------------------------------------------------------------------
RECORD_SIZE RECORDS_TOTAL RECORDS_USED FIRST_INDEX LAST_INDEX LAST_RECID
----------- ------------- ------------ ----------- ---------- ----------
BACKUP REDOLOG
         76           215            0           0          0          0

DATAFILE COPY
        736           200           60           1         60         60

BACKUP CORRUPTION
         44           371            0           0          0          0


TYPE
--------------------------------------------------------------------------------
RECORD_SIZE RECORDS_TOTAL RECORDS_USED FIRST_INDEX LAST_INDEX LAST_RECID
----------- ------------- ------------ ----------- ---------- ----------
COPY CORRUPTION
         40           409            0           0          0          0

DELETED OBJECT
         20           818           56           1         56         56

PROXY COPY
        928           246            0           0          0          0


TYPE
--------------------------------------------------------------------------------
RECORD_SIZE RECORDS_TOTAL RECORDS_USED FIRST_INDEX LAST_INDEX LAST_RECID
----------- ------------- ------------ ----------- ---------- ----------
BACKUP SPFILE
        124           131           16           1         16         16

DATABASE INCARNATION
         56           292            2           1          2          2

FLASHBACK LOG
         84          2048            0           0          0          0


TYPE
--------------------------------------------------------------------------------
RECORD_SIZE RECORDS_TOTAL RECORDS_USED FIRST_INDEX LAST_INDEX LAST_RECID
----------- ------------- ------------ ----------- ---------- ----------
RECOVERY DESTINATION
        180             1            1           0          0          0

INSTANCE SPACE RESERVATION
         28          1055            1           0          0          0

REMOVABLE RECOVERY FILES
         32          1000           29           0          0          0


TYPE
--------------------------------------------------------------------------------
RECORD_SIZE RECORDS_TOTAL RECORDS_USED FIRST_INDEX LAST_INDEX LAST_RECID
----------- ------------- ------------ ----------- ---------- ----------
RMAN STATUS
        116           141           76           1         76         76

THREAD INSTANCE NAME MAPPING
         80             8            8           0          0          0

MTTR
        100             8            0           0          0          0


TYPE
--------------------------------------------------------------------------------
RECORD_SIZE RECORDS_TOTAL RECORDS_USED FIRST_INDEX LAST_INDEX LAST_RECID
----------- ------------- ------------ ----------- ---------- ----------
DATAFILE HISTORY
        568            57            0           0          0          0

STANDBY DATABASE MATRIX
        400            31           31           0          0          0

GUARANTEED RESTORE POINT
        212          2048            0           0          0          0


TYPE
--------------------------------------------------------------------------------
RECORD_SIZE RECORDS_TOTAL RECORDS_USED FIRST_INDEX LAST_INDEX LAST_RECID
----------- ------------- ------------ ----------- ---------- ----------
RESTORE POINT
        212          2083            0           0          0          0

DATABASE BLOCK CORRUPTION
         80          8384            0           0          0          0

ACM OPERATION
        104            64            6           0          0          0


TYPE
--------------------------------------------------------------------------------
RECORD_SIZE RECORDS_TOTAL RECORDS_USED FIRST_INDEX LAST_INDEX LAST_RECID
----------- ------------- ------------ ----------- ---------- ----------
FOREIGN ARCHIVED LOG
        604          1002            0           0          0          0


37 rows selected.



++查看控制文件数据字典视图：

SQL> select name from v$controlfile;

NAME
--------------------------------------------------------------------------------
/home/oracle/app/oradata/orcl/control01.ctl
/home/oracle/app/recovery_area/orcl/control02.ctl
/home/oracle/tmp/oraclefiles/controlfiles/control03.ctl

++关闭数据库：
SQL> shutdown immediate
Database closed.
Database dismounted.
ORACLE instance shut down.

++启动实例不启动数据库：启动数据库，数据库就会操作日志文件，所有不启动数据库：

SQL> startup nomount
ORACLE instance started.

Total System Global Area  839282688 bytes
Fixed Size                  2217992 bytes
Variable Size             650119160 bytes
Database Buffers          180355072 bytes
Redo Buffers                6590464 bytes

++重建控制文件，使用原有文件:
SQL> r 
  1  create controlfile
  2  reuse database "orcl"
  3  logfile
  4  group 1 '/home/oracle/app/oradata/orcl/redo01.log',
  5  group 2 '/home/oracle/app/oradata/orcl/redo02.log',
  6  group 3 '/home/oracle/app/oradata/orcl/redo03.log'
  7  datafile
  8  '/home/oracle/app/oradata/orcl/system01.dbf',
  9  '/home/oracle/app/oradata/orcl/sysaux01.dbf',
 10  '/home/oracle/app/oradata/orcl/undotbs01.dbf',
 11  '/home/oracle/app/oradata/orcl/users01.dbf'
 12  maxlogfiles 50
 13  maxlogmembers 3
 14  maxinstances 6
 15  maxdatafiles 200
 16  noresetlogs
 17* noarchivelog

Control file created.

--以上代码，database关键字后面的数据库名字要求于spfile文件中的db_name参数值一致，noresetlogs选项表示仍然使用原有重做日志文件，如果不希望使用原有日志文件与控制文件一起丢失，则可指定resetlogs，logfile选项用于指定数据库原有重做日志的组号、大小以及对应的日志成员，dataffile用于指定数据库原有的数据文件。

++通过编辑spfile文件这个哦你的初始化参数control_files，使其指向新的控制文件：
SQL> alter system set control_files=
  2  '/home/oracle/app/oradata/orcl/control01.ctl',
  3  '/home/oracle/app/recovery_area/orcl/control02.ctl',
  4  '/home/oracle/tmp/oraclefiles/controlfiles/control03.ctl'
  5  scope=spfile;

System altered.

++打开数据库：
SQL> alter database open;

Database altered.

++备份数据库：
＋＋(1)备份数据库成为二进制文件备份：
SQL> alter database backup controlfile
  2  to '/home/oracle/tmp/oraclefiles/controlfiles/control.ctl.backup';

Database altered.

＋＋原控制文件和备份的二进制控制文件的对比：
++文件大小一样大：
[oracle@ctos oracle]$ ls
/home/oracle/tmp/oraclefiles/controlfiles/control03.ctl
/home/oracle/tmp/oraclefiles/controlfiles/control.ctl.backup -l
-rw-r----- 1 oracle oracle 12075008 05-28 09:36
/home/oracle/tmp/oraclefiles/controlfiles/control03.ctl
-rw-rw---- 1 oracle oracle 12075008 05-28 09:33
/home/oracle/tmp/oraclefiles/controlfiles/control.ctl.backup

++md5sum校验和不同
[oracle@ctos oracle]$ md5sum
/home/oracle/tmp/oraclefiles/controlfiles/control03.ctl
/home/oracle/tmp/oraclefiles/controlfiles/control.ctl.backup
6591569419150de635a5e2a088cb265b
/home/oracle/tmp/oraclefiles/controlfiles/control03.ctl
f97ba2de20e85a004e5145aa7482daf2
/home/oracle/tmp/oraclefiles/controlfiles/control.ctl.backup
[oracle@ctos oracle]$ 


++(2) 备份成为控制脚本文件：

++创建备份脚本控制文件：
SQL> alter database backup controlfile to trace;

Database altered.

++查看备份控制脚本文件所在位置
SQL> show parameter user_dump_dest;  

NAME                                 TYPE
------------------------------------ ---------------------------------
VALUE
------------------------------
user_dump_dest                       string
/home/oracle/app/diag/rdbms/or
cl/orcl/trace
SQL>    

++事实上这是个拥有很多脚本的目录文件：
[oracle@ctos trace]$ pwd
/home/oracle/app/diag/rdbms/orcl/orcl/trace


++发生控制文件损坏的，进行文件恢复：

++现关闭数据库，修改下现有控制文件的文件名，模仿控制文件损坏：

++关闭数据库：
SQL> shutdown immediate
ORA-01109: database not open


Database dismounted.
ORACLE instance shut down.

++通过系统视图查看都有哪些控制文件：
SQL> select name from v$controlfile;

NAME
--------------------------------------------------------------------------------
/home/oracle/app/oradata/orcl/control01.ctl
/home/oracle/app/recovery_area/orcl/control02.ctl
/home/oracle/tmp/oraclefiles/controlfiles/control03.ctl

++修改数据库控制文件名称：
mv /home/oracle/tmp/oraclefiles/controlfiles/control03.ctl
/home/oracle/tmp/oraclefiles/controlfiles/control03.ctl.tmp

＋＋启动数据库， 会提示数据库控制文件有错误
SQL> startup
ORACLE instance started.

Total System Global Area  839282688 bytes
Fixed Size                  2217992 bytes
Variable Size             650119160 bytes
Database Buffers          180355072 bytes
Redo Buffers                6590464 bytes
ORA-00205: error in identifying control file, check alert log for more info


SQL> startup
 
++查看数据库状态：

++实例已经开启：
SQL> select status from v$instance;

STATUS
------------------------------------
STARTED

++但数据库并没有加载：
SQL> select open_mode from v$database;
select open_mode from v$database
                      *
ERROR at line 1:
ORA-01507: database not mounted

++将控制文件文件名恢复为原有的名字：
[oracle@ctos trace]$ mv
/home/oracle/tmp/oraclefiles/controlfiles/control03.ctl.tmp
/home/oracle/tmp/oraclefiles/controlfiles/control03.ctl

++可以正确打开了：
SQL> alter database mount;

Database altered.

SQL> alter database open;

Database altered.

＋＋验证查询状态：
SQL> select status from v$instance;

STATUS
------------------------------------
OPEN


SQL> select open_mode from v$database;

OPEN_MODE
------------------------------------------------------------
READ WRITE

++实例和数据库状态查看：

++由打开状态变为关闭状态：
SQL> select open_mode from v$database;

OPEN_MODE
------------------------------------------------------------
READ WRITE

SQL> alter database close;


Database altered.

SQL> select open_mode from v$database;

OPEN_MODE
------------------------------------------------------------
MOUNTED

SQL> select status from v$instance;

STATUS
------------------------------------
MOUNTED

＋＋删除控制文件：

＋＋先在只启动实例的情况修改control_files系统参数：

SQL> select status from v$instance;

STATUS
------------------------------------
STARTED


SQL> r
  1  alter system set control_files=
  2  '/home/oracle/app/oradata/orcl/control01.ctl',
  3  '/home/oracle/app/recovery_area/orcl/control02.ctl'
  4* scope=spfile

System altered.

＋＋重启数据库：

SQL> shutdown immediate;
ORA-01507: database not mounted


ORACLE instance shut down.
SQL> startup    
ORACLE instance started.

Total System Global Area  839282688 bytes
Fixed Size                  2217992 bytes
Variable Size             650119160 bytes
Database Buffers          180355072 bytes
Redo Buffers                6590464 bytes
Database mounted.
intDatabase opened.

++查看控制文件参数，已经被更改了，oracle已经从逻辑上删除了该控制文件
SQL> show parameter control_files;

NAME                                 TYPE
------------------------------------ ---------------------------------
VALUE
------------------------------
control_files                        string
/home/oracle/app/oradata/orcl/
control01.ctl, /home/oracle/ap
p/recovery_area/orcl/control02
.ctl

++控制文件常用数据字典：
++查看控制文件的名字和大小
SQL> select * from v$controlfile;

STATUS                NAME                 IS_RECOVE BLOCK_SIZE FILE_SIZE_BLKS
--------------------- -------------------- --------- ---------- --------------
                      /home/oracle/app/ora NO             16384            736
                      data/orcl/control01.
                      ctl

                      /home/oracle/app/rec NO             16384            736
                      overy_area/orcl/cont
                      rol02.ctl
++包含控制文件各个记录文档段的信息：
SQL> describe v$controlfile_record_section;
 Name                                      Null?    Type
 ----------------------------------------- --------
----------------------------
 TYPE                                               VARCHAR2(28)
 RECORD_SIZE                                        NUMBER
 RECORDS_TOTAL                                      NUMBER
 RECORDS_USED                                       NUMBER
 FIRST_INDEX                                        NUMBER
 LAST_INDEX                                         NUMBER
 LAST_RECID                                         NUMBER

SQL> select type, record_size, records_total  
  2  , records_used from v$controlfile_record_section;

TYPE
--------------------------------------------------------------------------------
RECORD_SIZE RECORDS_TOTAL RECORDS_USED
----------- ------------- ------------
DATABASE
        316             1            1
++以上为数据库总数1个，使用一个，大小为316

++v$parameter视图包含了控制文件参数名字和值
SQL> select name, value from v$parameter where name = 'control_files';

NAME
--------------------
VALUE
--------------------------------------------------------------------------------
control_files
/home/oracle/app/oradata/orcl/control01.ctl,
/home/oracle/app/recovery_area/orcl
/control02.ctl


++重做日志文件：

＋＋查看重做日志文件视图：
SQL> describe v$logfile;
 Name                                      Null?    Type
 ----------------------------------------- --------
----------------------------
 GROUP#                                             NUMBER
 STATUS                                             VARCHAR2(7)
 TYPE                                               VARCHAR2(7)
 MEMBER                                             VARCHAR2(513)
 IS_RECOVERY_DEST_FILE                              VARCHAR2(3)

SQL> select * from v$logfile;

    GROUP# STATUS                TYPE
---------- --------------------- ---------------------
MEMBER
--------------------------------------------------------------------------------
IS_RECOVE
---------
         1 STALE                 ONLINE
/home/oracle/app/oradata/orcl/redo01.log
NO

         3 STALE                 ONLINE
/home/oracle/app/oradata/orcl/redo03.log
NO

    GROUP# STATUS                TYPE
---------- --------------------- ---------------------
MEMBER
--------------------------------------------------------------------------------
IS_RECOVE
---------

         2                       ONLINE
/home/oracle/app/oradata/orcl/redo02.log
NO

＋＋添加重做日志文件组：
SQL> alter database add logfile
  2  ('/home/oracle/app/oradata/orcl/redo04_a.log',
  3  '/home/oracle/app/oradata/orcl/redo04_b.log')
  4  size 20m;

Database altered.

++查看重做日志成员所在的视图，结果已经被添加上：
SQL> select member from v$logfile;

MEMBER
--------------------------------------------------------------------------------
/home/oracle/app/oradata/orcl/redo01.log
/home/oracle/app/oradata/orcl/redo03.log
/home/oracle/app/oradata/orcl/redo02.log
/home/oracle/app/oradata/orcl/redo04_a.log
/home/oracle/app/oradata/orcl/redo04_b.log

++指定新的重做日志文件组，组编号指定为5，不指定系统自动递增
＋＋指定时一定要连续组编号，否则消耗控制文件空间

SQL> alter database add logfile group 5
  2  ('/home/oracle/app/oradata/orcl/redo05_a.log',
  3  '/home/oracle/app/oradata/orcl/redo05_b.log')
  4  size 20m;

Database altered.

++指定重做日志组及相应组号成功：
SQL> r
  1* select group#, member from v$logfile

    GROUP# MEMBER
---------- --------------------------------------------------
         1 /home/oracle/app/oradata/orcl/redo01.log
         3 /home/oracle/app/oradata/orcl/redo03.log
         2 /home/oracle/app/oradata/orcl/redo02.log
         4 /home/oracle/app/oradata/orcl/redo04_a.log
         4 /home/oracle/app/oradata/orcl/redo04_b.log
         5 /home/oracle/app/oradata/orcl/redo05_a.log
         5 /home/oracle/app/oradata/orcl/redo05_b.log

7 rows selected.

++添加重做日志文件：
SQL> alter database add logfile
  2  '/home/oracle/app/oradata/orcl/redo06.log'
  3  size 30m;

Database altered.

++删除重做日志文件：
SQL> alter database drop logfile    
  2  '/home/oracle/app/oradata/orcl/redo06.log';

Database altered.

++重用重做日志文件：
SQL> alter database add logfile
  2  '/home/oracle/app/oradata/orcl/redo06.log'
  3  reuse;

Database altered.

++向已有的重做日志文件组中添加新的重做日志文件：
SQL> alter database add logfile member   
  2  '/home/oracle/app/oradata/orcl/redo04_c.log'   
  3  to group 4;

Database altered.

SQL> select group#, member from v$logfile;

    GROUP# MEMBER
---------- --------------------------------------------------
         1 /home/oracle/app/oradata/orcl/redo01.log
         3 /home/oracle/app/oradata/orcl/redo03.log
         2 /home/oracle/app/oradata/orcl/redo02.log
         4 /home/oracle/app/oradata/orcl/redo04_a.log
         4 /home/oracle/app/oradata/orcl/redo04_b.log
         5 /home/oracle/app/oradata/orcl/redo05_a.log
         5 /home/oracle/app/oradata/orcl/redo05_b.log
         6 /home/oracle/app/oradata/orcl/redo06.log
         4 /home/oracle/app/oradata/orcl/redo04_c.log

9 rows selected.

++根据原有重做日志文件名字，向其所在的重做日志文件组增加成员：
SQL> alter database add logfile member
  2  '/home/oracle/app/oradata/orcl/redo02_new.log'
  3  to ('/home/oracle/app/oradata/orcl/redo02.log');

Database altered.

SQL> select status, member from v$logfile;

STATUS                MEMBER
--------------------- --------------------------------------------------
STALE                 /home/oracle/app/oradata/orcl/redo01.log
STALE                 /home/oracle/app/oradata/orcl/redo03.log
                      /home/oracle/app/oradata/orcl/redo02.log
                      /home/oracle/app/oradata/orcl/redo04_a.log
                      /home/oracle/app/oradata/orcl/redo04_b.log
                      /home/oracle/app/oradata/orcl/redo05_a.log
                      /home/oracle/app/oradata/orcl/redo05_b.log
                      /home/oracle/app/oradata/orcl/redo06.log
INVALID               /home/oracle/app/oradata/orcl/redo04_c.log
INVALID               /home/oracle/app/oradata/orcl/redo02_new.log

10 rows selected.

++删除重做日志文件：

SQL> alter database drop logfile member
  2  '/home/oracle/app/oradata/orcl/redo04_c.log';

Database altered.

SQL> select member from v$logfile;

MEMBER
--------------------------------------------------
/home/oracle/app/oradata/orcl/redo01.log
/home/oracle/app/oradata/orcl/redo03.log
/home/oracle/app/oradata/orcl/redo02.log
/home/oracle/app/oradata/orcl/redo04_a.log
/home/oracle/app/oradata/orcl/redo04_b.log
/home/oracle/app/oradata/orcl/redo05_a.log
/home/oracle/app/oradata/orcl/redo05_b.log
/home/oracle/app/oradata/orcl/redo06.log
/home/oracle/app/oradata/orcl/redo02_new.log

9 rows selected.

++删除重做文件组：

＋＋删除重做文件组的前后的对比：

SQL> select group#, member from v$logfile;

    GROUP# MEMBER
---------- --------------------------------------------------
         1 /home/oracle/app/oradata/orcl/redo01.log
         3 /home/oracle/app/oradata/orcl/redo03.log
         2 /home/oracle/app/oradata/orcl/redo02.log
         4 /home/oracle/app/oradata/orcl/redo04_a.log
         4 /home/oracle/app/oradata/orcl/redo04_b.log
         5 /home/oracle/app/oradata/orcl/redo05_a.log
         5 /home/oracle/app/oradata/orcl/redo05_b.log
         6 /home/oracle/app/oradata/orcl/redo06.log
         2 /home/oracle/app/oradata/orcl/redo02_new.log

9 rows selected.

SQL> alter database drop logfile group 6;

Database altered.

SQL> select group#, member from v$logfile;

    GROUP# MEMBER
---------- --------------------------------------------------
         1 /home/oracle/app/oradata/orcl/redo01.log
         3 /home/oracle/app/oradata/orcl/redo03.log
         2 /home/oracle/app/oradata/orcl/redo02.log
         4 /home/oracle/app/oradata/orcl/redo04_a.log
         4 /home/oracle/app/oradata/orcl/redo04_b.log
         5 /home/oracle/app/oradata/orcl/redo05_a.log
         5 /home/oracle/app/oradata/orcl/redo05_b.log
         2 /home/oracle/app/oradata/orcl/redo02_new.log

8 rows selected.

++清空归档日志：
SQL> alter database clear logfile group 4;

Database altered.

++清空没有归档的重做日志：

SQL> alter database clear unarchived logfile group 4;

Database altered.

++日志文件的修改：

++打开数据库：
SQL> startup mount;
ORACLE instance started.

Total System Global Area  839282688 bytes
Fixed Size                  2217992 bytes
Variable Size             650119160 bytes
Database Buffers          180355072 bytes
Redo Buffers                6590464 bytes
Database mounted.

++复制重做日志文件：
[oracle@ctos trace]$ cp /home/oracle/app/oradata/orcl/redo04_a.log
/home/oracle/app/oradata/orcl/redo04_c.log
[oracle@ctos trace]$ cp /home/oracle/app/oradata/orcl/redo04_b.log
/home/oracle/app/oradata/orcl/redo04_d.log

++修改重做日志文件：
SQL> alter database rename file
  2  '/home/oracle/app/oradata/orcl/redo04_a.log',
  3  '/home/oracle/app/oradata/orcl/redo04_b.log'
  4  to  
  5  '/home/oracle/app/oradata/orcl/redo04_c.log',
  6  '/home/oracle/app/oradata/orcl/redo04_d.log';

Database altered.

++查看修改结果：
SQL> select group#, member from v$logfile;

    GROUP# MEMBER
---------- --------------------------------------------------
         1 /home/oracle/app/oradata/orcl/redo01.log
         3 /home/oracle/app/oradata/orcl/redo03.log
         2 /home/oracle/app/oradata/orcl/redo02.log
         4 /home/oracle/app/oradata/orcl/redo04_c.log
         4 /home/oracle/app/oradata/orcl/redo04_d.log
         5 /home/oracle/app/oradata/orcl/redo05_a.log
         5 /home/oracle/app/oradata/orcl/redo05_b.log
         2 /home/oracle/app/oradata/orcl/redo02_new.log

8 rows selected.

++显示控制文件中的日志文件信息：
SQL> describe v$log;
 Name                                      Null?    Type
 ----------------------------------------- --------
----------------------------
 GROUP#                                             NUMBER
 THREAD#                                            NUMBER
 SEQUENCE#                                          NUMBER
 BYTES                                              NUMBER
 BLOCKSIZE                                          NUMBER
 MEMBERS                                            NUMBER
 ARCHIVED                                           VARCHAR2(3)
 STATUS                                             VARCHAR2(16)
 FIRST_CHANGE#                                      NUMBER
 FIRST_TIME                                         DATE
 NEXT_CHANGE#                                       NUMBER
 NEXT_TIME                                          DATE

group#:日志文件组编号
sequece#:日志序列号：
status:日志组的状态，包括current,inactive,active
first_change#重做日志组上一次写入时的变更码（scn）

++日志组和日志成员信息视图：
SQL> select member from v$logfile;

MEMBER
--------------------------------------------------
/home/oracle/app/oradata/orcl/redo01.log
/home/oracle/app/oradata/orcl/redo03.log
/home/oracle/app/oradata/orcl/redo02.log
/home/oracle/app/oradata/orcl/redo04_c.log
/home/oracle/app/oradata/orcl/redo04_d.log
/home/oracle/app/oradata/orcl/redo05_a.log
/home/oracle/app/oradata/orcl/redo05_b.log
/home/oracle/app/oradata/orcl/redo02_new.log

8 rows selected.

++日志历史信息：
SQL> select * from v$log_history;

     RECID      STAMP    THREAD#  SEQUENCE# FIRST_CHANGE# FIRST_TIME
---------- ---------- ---------- ---------- ------------- ---------------
NEXT_CHANGE# RESETLOGS_CHANGE# RESETLOGS_TIME
------------ ----------------- ---------------
         1  944604805          1         52       2382374 10-MAY-17
     2397107            945184 06-JAN-17


++管理归档日志文件：
++查询数据归档状态：
SQL> select log_mode from v$database;

LOG_MODE
------------------------------------
NOARCHIVELOG

++查询数据库状态，使其处于mount状态：
SQL> select status from v$instance;

STATUS
------------------------------------
MOUNTED

SQL> select open_mode from v$database;

OPEN_MODE
------------------------------------------------------------
MOUNTED

SQL> select open_mode from v$database;

OPEN_MODE
------------------------------------------------------------
MOUNTED

++注意，如果数据库是关闭重启之后mount状态的，在关闭时不能使用shutdown abort

++切换日志归档模式：
SQL> alter database archivelog;

Database altered.

++打开数据库：
SQL> alter database open;

Database altered.

++查看数据归档状态：
++处于归档状态：
SQL> archive log list;
Database log mode              Archive Mode
Automatic archival             Enabled
Archive destination            USE_DB_RECOVERY_FILE_DEST
Oldest online log sequence     51
Next log sequence to archive   53
Current log sequence           53

++处于非归档状态：
SQL> archive log list;      
Database log mode              No Archive Mode
Automatic archival             Disabled
Archive destination            USE_DB_RECOVERY_FILE_DEST
Oldest online log sequence     51
Current log sequence           53

++配置归档进程：
SQL> alter system set log_archive_max_processes=3;

System altered.
++不修改，缺省设置为两个。

++设置归档目标，即归档文件所在的位置：
SQL> alter system set log_archive_dest_1='location=/home/oracle/tmp/archive1';

System altered.

++optional:无论归档是否成功，都可以覆盖重做文件：
SQL> alter system set log_archive_dest_1='location=/home/oracle/tmp/archive1
optional';

System altered.

++mandatory:只有归档成功之后，重做日志才能够被覆盖：
SQL> alter system set log_archive_dest_1='location=/home/oracle/tmp/archive1
mandatory';

System altered.

++reopen 设置重新归档时间间隔为400秒，reopen要紧跟在mandatory之后。
SQL> alter system set log_archive_dest_1='location=/home/oracle/tmp/archive1
mandatory reopen=400';

System altered.

++设置本地成功归档文件的最小个数
SQL> alter system set log_archive_min_succeed_dest=3;

System altered.

++如果成功生成归档日志文件少于3个，重做日志将不被覆盖。

++设置归档目标是否可用：

SQL> alter system set log_archive_dest_2='location=/home/oracle/tmp/archive2
mandatory';

System altered.

SQL> alter system set log_archive_dest_state_2 = defer;

System altered.

++查看归档日志信息：
++查询数据库是否归档
SQL> describe v$database;
 Name                                      Null?    Type
 ----------------------------------------- --------
----------------------------
 DBID                                               NUMBER
 NAME                                               VARCHAR2(9)
 CREATED                                            DATE
 RESETLOGS_CHANGE#                                  NUMBER
 RESETLOGS_TIME                                     DATE
 PRIOR_RESETLOGS_CHANGE#                            NUMBER
 PRIOR_RESETLOGS_TIME                               DATE
 LOG_MODE                                           VARCHAR2(12)
 CHECKPOINT_CHANGE#                                 NUMBER
 ARCHIVE_CHANGE#                                    NUMBER
 CONTROLFILE_TYPE                                   VARCHAR2(7)
 CONTROLFILE_CREATED                                DATE
 CONTROLFILE_SEQUENCE#                              NUMBER
 CONTROLFILE_CHANGE#                                NUMBER
 CONTROLFILE_TIME                                   DATE
 OPEN_RESETLOGS                                     VARCHAR2(11)
 VERSION_TIME                                       DATE
 OPEN_MODE                                          VARCHAR2(20)
 PROTECTION_MODE                                    VARCHAR2(20)
 PROTECTION_LEVEL                                   VARCHAR2(20)
 REMOTE_ARCHIVE                                     VARCHAR2(8)
 ACTIVATION#                                        NUMBER
 SWITCHOVER#                                        NUMBER
 DATABASE_ROLE                                      VARCHAR2(16)
 ARCHIVELOG_CHANGE#                                 NUMBER
 ARCHIVELOG_COMPRESSION                             VARCHAR2(8)
 SWITCHOVER_STATUS                                  VARCHAR2(20)
 DATAGUARD_BROKER                                   VARCHAR2(8)
 GUARD_STATUS                                       VARCHAR2(7)
 SUPPLEMENTAL_LOG_DATA_MIN                          VARCHAR2(8)
 SUPPLEMENTAL_LOG_DATA_PK                           VARCHAR2(3)
 SUPPLEMENTAL_LOG_DATA_UI                           VARCHAR2(3)
 FORCE_LOGGING                                      VARCHAR2(3)
 PLATFORM_ID                                        NUMBER
 PLATFORM_NAME                                      VARCHAR2(101)
 RECOVERY_TARGET_INCARNATION#                       NUMBER
 LAST_OPEN_INCARNATION#                             NUMBER
 CURRENT_SCN                                        NUMBER
 FLASHBACK_ON                                       VARCHAR2(18)
 SUPPLEMENTAL_LOG_DATA_FK                           VARCHAR2(3)
 SUPPLEMENTAL_LOG_DATA_ALL                          VARCHAR2(3)
 DB_UNIQUE_NAME                                     VARCHAR2(30)
 STANDBY_BECAME_PRIMARY_SCN                         NUMBER
 FS_FAILOVER_STATUS                                 VARCHAR2(22)
 FS_FAILOVER_CURRENT_TARGET                         VARCHAR2(30)
 FS_FAILOVER_THRESHOLD                              NUMBER
 FS_FAILOVER_OBSERVER_PRESENT                       VARCHAR2(7)
 FS_FAILOVER_OBSERVER_HOST                          VARCHAR2(512)
 CONTROLFILE_CONVERTED                              VARCHAR2(3)
 PRIMARY_DB_UNIQUE_NAME                             VARCHAR2(30)
 SUPPLEMENTAL_LOG_DATA_PL                           VARCHAR2(3)
 MIN_REQUIRED_CAPTURE_CHANGE#                       NUMBER

++控制文件所有归档信息：

SQL> describe v$archived_log;
 Name                                      Null?    Type
 ----------------------------------------- --------
----------------------------
 RECID                                              NUMBER
 STAMP                                              NUMBER
 NAME                                               VARCHAR2(513)
 DEST_ID                                            NUMBER
 THREAD#                                            NUMBER
 SEQUENCE#                                          NUMBER
 RESETLOGS_CHANGE#                                  NUMBER
 RESETLOGS_TIME                                     DATE
 RESETLOGS_ID                                       NUMBER
 FIRST_CHANGE#                                      NUMBER
 FIRST_TIME                                         DATE
 NEXT_CHANGE#                                       NUMBER
 NEXT_TIME                                          DATE
 BLOCKS                                             NUMBER
 BLOCK_SIZE                                         NUMBER
 CREATOR                                            VARCHAR2(7)
 REGISTRAR                                          VARCHAR2(7)
 STANDBY_DEST                                       VARCHAR2(3)
 ARCHIVED                                           VARCHAR2(3)
 APPLIED                                            VARCHAR2(9)
 DELETED                                            VARCHAR2(3)
 STATUS                                             VARCHAR2(1)
 COMPLETION_TIME                                    DATE
 DICTIONARY_BEGIN                                   VARCHAR2(3)
 DICTIONARY_END                                     VARCHAR2(3)
 END_OF_REDO                                        VARCHAR2(3)
 BACKUP_COUNT                                       NUMBER
 ARCHIVAL_THREAD#                                   NUMBER
 ACTIVATION#                                        NUMBER
 IS_RECOVERY_DEST_FILE                              VARCHAR2(3)
 COMPRESSED                                         VARCHAR2(3)
 FAL                                                VARCHAR2(3)
 END_OF_REDO_TYPE                                   VARCHAR2(10)
 BACKED_BY_VSS                                      VARCHAR2(3)

++归档目标信息：

SQL> describe v$archive_dest;
 Name                                      Null?    Type
 ----------------------------------------- --------
----------------------------
 DEST_ID                                            NUMBER
 DEST_NAME                                          VARCHAR2(256)
 STATUS                                             VARCHAR2(9)
 BINDING                                            VARCHAR2(9)
 NAME_SPACE                                         VARCHAR2(7)
 TARGET                                             VARCHAR2(7)
 ARCHIVER                                           VARCHAR2(10)
 SCHEDULE                                           VARCHAR2(8)
 DESTINATION                                        VARCHAR2(256)
 LOG_SEQUENCE                                       NUMBER
 REOPEN_SECS                                        NUMBER
 DELAY_MINS                                         NUMBER
 MAX_CONNECTIONS                                    NUMBER
 NET_TIMEOUT                                        NUMBER
 PROCESS                                            VARCHAR2(10)
 REGISTER                                           VARCHAR2(3)
 FAIL_DATE                                          DATE
 FAIL_SEQUENCE                                      NUMBER
 FAIL_BLOCK                                         NUMBER
 FAILURE_COUNT                                      NUMBER
 MAX_FAILURE                                        NUMBER
 ERROR                                              VARCHAR2(256)
 ALTERNATE                                          VARCHAR2(256)
 DEPENDENCY                                         VARCHAR2(256)
 REMOTE_TEMPLATE                                    VARCHAR2(256)
 QUOTA_SIZE                                         NUMBER
 QUOTA_USED                                         NUMBER
 MOUNTID                                            NUMBER
 TRANSMIT_MODE                                      VARCHAR2(12)
 ASYNC_BLOCKS                                       NUMBER
 AFFIRM                                             VARCHAR2(3)
 TYPE                                               VARCHAR2(7)
 VALID_NOW                                          VARCHAR2(16)
 VALID_TYPE                                         VARCHAR2(15)
 VALID_ROLE                                         VARCHAR2(12)
 DB_UNIQUE_NAME                                     VARCHAR2(30)
 VERIFY                                             VARCHAR2(3)
 COMPRESSION                                        VARCHAR2(7)

++包含已启动的arcn进程信息：
SQL> describe v$archive_processes;
 Name                                      Null?    Type
 ----------------------------------------- --------
----------------------------
 PROCESS                                            NUMBER
 STATUS                                             VARCHAR2(10)
 LOG_SEQUENCE                                       NUMBER
 STATE                                              VARCHAR2(4)

++包含已经备份的归档日志信息：
SQL> describe v$archive_processes;
 Name                                      Null?    Type
 ----------------------------------------- --------
----------------------------
 PROCESS                                            NUMBER
 STATUS                                             VARCHAR2(10)
 LOG_SEQUENCE                                       NUMBER
 STATE                                              VARCHAR2(4)

++显示所有的归档目标参数名称：
SQL> select dest_name from v$archive_dest;

DEST_NAME
--------------------------------------------------------------------------------
LOG_ARCHIVE_DEST_1
LOG_ARCHIVE_DEST_2
LOG_ARCHIVE_DEST_3
LOG_ARCHIVE_DEST_4
LOG_ARCHIVE_DEST_5
LOG_ARCHIVE_DEST_6
LOG_ARCHIVE_DEST_7
LOG_ARCHIVE_DEST_8
LOG_ARCHIVE_DEST_9
LOG_ARCHIVE_DEST_10
LOG_ARCHIVE_DEST_11

DEST_NAME
--------------------------------------------------------------------------------
LOG_ARCHIVE_DEST_12
LOG_ARCHIVE_DEST_13
LOG_ARCHIVE_DEST_14
LOG_ARCHIVE_DEST_15
LOG_ARCHIVE_DEST_16
LOG_ARCHIVE_DEST_17
LOG_ARCHIVE_DEST_18
LOG_ARCHIVE_DEST_19
LOG_ARCHIVE_DEST_20
LOG_ARCHIVE_DEST_21
LOG_ARCHIVE_DEST_22

DEST_NAME
--------------------------------------------------------------------------------
LOG_ARCHIVE_DEST_23
LOG_ARCHIVE_DEST_24
LOG_ARCHIVE_DEST_25
LOG_ARCHIVE_DEST_26
LOG_ARCHIVE_DEST_27
LOG_ARCHIVE_DEST_28
LOG_ARCHIVE_DEST_29
LOG_ARCHIVE_DEST_30
LOG_ARCHIVE_DEST_31

31 rows selected.

＋＋显示数据库的归档信息：
SQL> archive log list;
Database log mode              No Archive Mode
Automatic archival             Disabled
Archive destination            /home/oracle/tmp/archive2
Oldest online log sequence     51
Current log sequence           53

++表空间对应数据文件关系：
SQL> column tablespace_name for a10
SQL> column file_name for a50
SQL> column bytes for 999,999,999
SQL> r
  1  select tablespace_name, file_name,
  2  bytes from dba_data_files
  3  order by tablespace_name
  4*

TABLESPACE FILE_NAME                                                 BYTES
---------- -------------------------------------------------- ------------
SYSAUX     /home/oracle/app/oradata/orcl/sysaux01.dbf          566,231,040
SYSTEM     /home/oracle/app/oradata/orcl/system01.dbf          713,031,680
UNDOTBS1   /home/oracle/app/oradata/orcl/undotbs01.dbf          99,614,720
USERS      /home/oracle/app/oradata/orcl/users01.dbf             5,242,880

++users表空间的内容，scott用户的索引和表：

++通过本地化管理方式local创建一个大小为10MB的表空间，其扩展大小为等同的256kb：

SQL>create tablespace tbs_test1 datafile
'/home/oracle/app/oradata/orcl/datafile1.dbf'
  2  size 10m           
  3  extent management local uniform size 256k;

Tablespace created.


SQL> select segment_type, segment_name,
  2  owner from dba_segments
  3  where tablespace_name = 'USERS';

SEGMENT_TYPE         SEGMENT_NAME                   OWNER
-------------------- ------------------------------ ----------
TABLE                DEPT                           SCOTT
TABLE                EMP                            SCOTT
TABLE                SALGRADE                       SCOTT
INDEX                PK_DEPT                        SCOTT
INDEX                PK_EMP                         SCOTT

＋＋sysaux表空间所存放的用户及这些用户拥有的对象数量

SQL> column 用户 format a30
SQL> r
  1  select owner as 用户, count(segment_name) as 对象数量 from dba_segments
  2* where tablespace_name = 'SYSAUX' group by owner

用户                           对象数量
------------------------------ --------
MDSYS                               262
CTXSYS                               53
OLAPSYS                              58
SYSTEM                              149
EXFSYS                               58
APEX_030200                         467
DBSNMP                               23
ORDSYS                                7
SYSMAN                              828
XDB                                 885
ORDDATA                             148

用户                           对象数量
------------------------------ --------
SYS                                 888
WMSYS                                49

13 rows selected.

++通过本地化管理方式local创建一个大小为10mb的表空间，其扩展大小为等同的256kb

SQL> create tablespace tbs_test1 datafile
'/home/oracle/app/oradata/orcl/datafile1.dbf'
  2  size 10m           
  3  extent management local uniform size 256k;

Tablespace created.

++查看文件，已经被创建
[oracle@ctos oracle]$ ls -lh /home/oracle/app/oradata/orcl/datafile1.dbf 
-rw-rw---- 1 oracle oracle 11M 06-03 22:42
/home/oracle/app/oradata/orcl/datafile1.dbf

++通过本地化管理方式local创建一个大小为10mb的表空间，其扩展大小为自动管理，扩展大小的方式与上条不同

SQL> create tablespace tbs_test2 datafile
'/home/oracle/app/oradata/orcl/datafile2.dbf'
  2  size 10m
  3  extent management local autoallocate;

Tablespace created.

++查看创建的表空间文件：
[oracle@ctos oracle]$ ls -lh /home/oracle/app/oradata/orcl/datafile2.dbf
-rw-rw---- 1 oracle oracle 11M 06-03 22:49
/home/oracle/app/oradata/orcl/datafile2.dbf

++通过本地化管理方式local创建一个表空间，其扩展大小为自动管理，其段空间管理方式为手动：
SQL> create tablespace tbs_test3 datafile
'/home/oracle/app/oradata/orcl/datafile3.dbf'
  2  size 20m
  3  extent management local autoallocate
  4  segment space management manual;

Tablespace created.

[oracle@ctos oracle]$ ls -lh /home/oracle/app/oradata/orcl/datafile3.dbf
-rw-rw---- 1 oracle oracle 21M 06-04 09:57
/home/oracle/app/oradata/orcl/datafile3.dbf

++通过本地化管理方式local创建一个大小为20mb的表空间，其扩展大小为自动管理，其段空间管理方式为自动：

SQL> create tablespace tbs_test_4 datafile
'/home/oracle/app/oradata/orcl/datafile4.dbf'
  2  size 20m
  3  extent management local autoallocate
  4  segment space management auto;

Tablespace created.

++创建非标准块表空间：

＋＋创建一个16k的块表空间：
＋＋设置共享内存为16m

SQL> alter system set db_16k_cache_size = 16m scope=both;

System altered.

++创建非标准块的表空间，块大小为16k，标准块的两倍
SQL> create tablespace tbs_test_5 datafile
'/home/oracle/app/oradata/orcl/datafile5.dbf'
  2  size 64m reuse
  3  autoextend on next 4m maxsize unlimited
  4  blocksize 16k
  5  extent management local autoallocate
  6  segment space management auto;

Tablespace created.

++创建大文件表空间：

SQL> create bigfile tablespace tbs_test_big datafile
'/home/oracle/app/oradata/orcl/bigfile.dbf'
  2  size 500m;

Tablespace created.

++查看表空间文件：

[oracle@ctos oracle]$ ls /home/oracle/app/oradata/orcl/bigfile.dbf -lh
-rw-rw---- 1 oracle oracle 501M 06-04 10:56
/home/oracle/app/oradata/orcl/bigfile.dbf

++删除大文件表空间及其所拥有的数据：
SQL> drop tablespace tbs_test_big including contents and datafiles;

Tablespace dropped.


++修改大文件表空间大小：

SQL> alter database datafile '/home/oracle/app/oradata/orcl/bigfile.dbf'
  2  resize 70m;

Database altered.

＋＋查看文件：
[oracle@ctos oracle]$ ls -lh /home/oracle/app/oradata/orcl/bigfile.dbf
-rw-rw---- 1 oracle oracle 71M 06-04 11:34
/home/oracle/app/oradata/orcl/bigfile.dbf

++表空间维护

＋＋查询当前数据库临时表空间的表空间名字以及表文件名对应的是哪一个：

SQL> select tablespace_name,file_name,bytes/1024/1024 file_size,autoextensible
from dba_temp_files;

TABLESPACE FILE_NAME                                           FILE_SIZE
---------- -------------------------------------------------- ----------
AUTOEXTEN
---------
TEMP       /home/oracle/app/oradata/orcl/temp01.dbf                   29
YES


++创建临时表空间temp_1，加上重用选项
SQL> create temporary tablespace temp_1
  2  tempfile '/home/oracle/app/oradata/orcl/temp_1.dbf'
  3  size 20m
  4  reuse
  5  autoextend on
  6  next 20m maxsize 20480m
  7  extent management local;

Tablespace created.

++将临时表空间temp_1设置为默认的临时表空间：

SQL> alter database default temporary tablespace temp_1;

Database altered.

＋＋查看系统用户默认的临时表空间：

SQL> r
  1  select username,default_tablespace,temporary_tablespace
  2* from dba_users

USERNAME             DEFAULT_TABLESPACE   TEMPORARY_TABLESPACE
-------------------- -------------------- --------------------
MGMT_VIEW            SYSTEM               TEMP_1
SYS                  SYSTEM               TEMP_1
SYSTEM               SYSTEM               TEMP_1
DBSNMP               SYSAUX               TEMP_1
SYSMAN               SYSAUX               TEMP_1
SCOTT                USERS                TEMP_1
OUTLN                SYSTEM               TEMP_1
FLOWS_FILES          SYSAUX               TEMP_1
MDSYS                SYSAUX               TEMP_1
ORDSYS               SYSAUX               TEMP_1
EXFSYS               SYSAUX               TEMP_1

USERNAME             DEFAULT_TABLESPACE   TEMPORARY_TABLESPACE
-------------------- -------------------- --------------------
WMSYS                SYSAUX               TEMP_1
APPQOSSYS            SYSAUX               TEMP_1
APEX_030200          SYSAUX               TEMP_1
OWBSYS_AUDIT         SYSAUX               TEMP_1
ORDDATA              SYSAUX               TEMP_1
CTXSYS               SYSAUX               TEMP_1
ANONYMOUS            SYSAUX               TEMP_1
XDB                  SYSAUX               TEMP_1
ORDPLUGINS           SYSAUX               TEMP_1
OWBSYS               SYSAUX               TEMP_1
SI_INFORMTN_SCHEMA   SYSAUX               TEMP_1

USERNAME             DEFAULT_TABLESPACE   TEMPORARY_TABLESPACE
-------------------- -------------------- --------------------
OLAPSYS              SYSAUX               TEMP_1
ORACLE_OCM           USERS                TEMP_1
XS$NULL              USERS                TEMP_1
MDDATA               USERS                TEMP_1
DIP                  USERS                TEMP_1
APEX_PUBLIC_USER     USERS                TEMP_1
SPATIAL_CSW_ADMIN_US USERS                TEMP_1
R

SPATIAL_WFS_ADMIN_US USERS                TEMP_1
R

USERNAME             DEFAULT_TABLESPACE   TEMPORARY_TABLESPACE
-------------------- -------------------- --------------------


30 rows selected.


++创建表空间tbs_example

SQL> create tablespace tbs_example   
  2  datafile '/home/oracle/app/oradata/orcl/tbs_example.dbf'
  3  size 20m
  4  extent management local autoallocate
  5  segment space management auto;

Tablespace created.

++将表空间tbs_example设置为默认的永久表空间：

SQL> alter database default tablespace tbs_example;

Database altered.


++查询变更的结果：

SQL> select username,default_tablespace,temporary_tablespace
  2  from dba_users;

USERNAME             DEFAULT_TABLESPACE   TEMPORARY_TABLESPACE
-------------------- -------------------- --------------------
SCOTT                TBS_EXAMPLE          TEMP_1
ORACLE_OCM           TBS_EXAMPLE          TEMP_1
XS$NULL              TBS_EXAMPLE          TEMP_1
MDDATA               TBS_EXAMPLE          TEMP_1
DIP                  TBS_EXAMPLE          TEMP_1
APEX_PUBLIC_USER     TBS_EXAMPLE          TEMP_1
SPATIAL_CSW_ADMIN_US TBS_EXAMPLE          TEMP_1
R

SPATIAL_WFS_ADMIN_US TBS_EXAMPLE          TEMP_1
R

USERNAME             DEFAULT_TABLESPACE   TEMPORARY_TABLESPACE
-------------------- -------------------- --------------------

DBSNMP               SYSAUX               TEMP_1
SYSMAN               SYSAUX               TEMP_1
FLOWS_FILES          SYSAUX               TEMP_1
MDSYS                SYSAUX               TEMP_1
ORDSYS               SYSAUX               TEMP_1
EXFSYS               SYSAUX               TEMP_1
WMSYS                SYSAUX               TEMP_1
APPQOSSYS            SYSAUX               TEMP_1
APEX_030200          SYSAUX               TEMP_1
OWBSYS_AUDIT         SYSAUX               TEMP_1

USERNAME             DEFAULT_TABLESPACE   TEMPORARY_TABLESPACE
-------------------- -------------------- --------------------
ORDDATA              SYSAUX               TEMP_1
CTXSYS               SYSAUX               TEMP_1
ANONYMOUS            SYSAUX               TEMP_1
XDB                  SYSAUX               TEMP_1
ORDPLUGINS           SYSAUX               TEMP_1
OWBSYS               SYSAUX               TEMP_1
SI_INFORMTN_SCHEMA   SYSAUX               TEMP_1
OLAPSYS              SYSAUX               TEMP_1
MGMT_VIEW            SYSTEM               TEMP_1
SYS                  SYSTEM               TEMP_1
SYSTEM               SYSTEM               TEMP_1

USERNAME             DEFAULT_TABLESPACE   TEMPORARY_TABLESPACE
-------------------- -------------------- --------------------
OUTLN                SYSTEM               TEMP_1

30 rows selected.


++设置表空的状态，读写

SQL> alter tablespace tbs_test1 read only;

Tablespace altered.

++查看设置好的状态：
SQL> select STATUS from dba_tablespaces where
  2  tablespace_name = 'TBS_TEST1';

STATUS
---------------------------
READ ONLY

＋＋设置成功，已为只读



++重命名表空间：

＋＋查看表空间名字及状态：
SQL> r
  1* select STATUS, tablespace_name from dba_tablespaces

STATUS                      TABLESPACE_NAME
--------------------------- --------------------
ONLINE                      SYSTEM
ONLINE                      SYSAUX
ONLINE                      UNDOTBS1
ONLINE                      TEMP
ONLINE                      USERS
READ ONLY                   TBS_TEST1
ONLINE                      TBS_TEST2
ONLINE                      TBS_TEST3
ONLINE                      TBS_TEST_4
ONLINE                      TBS_TEST_5
ONLINE                      TBS_TEST_BIG

STATUS                      TABLESPACE_NAME
--------------------------- --------------------
ONLINE                      TEMP_1
ONLINE                      TBS_EXAMPLE

13 rows selected.

++修改其中是在线状态的：

SQL> alter tablespace TBS_TEST2 rename to tbs_test2_new;

Tablespace altered.

++修改是只读状态的：
SQL> alter tablespace TBS_TEST1 rename to tbs_test1_new; 

Tablespace altered.

++修改后查询：
SQL> select STATUS, tablespace_name from dba_tablespaces
  2  ;

STATUS                      TABLESPACE_NAME
--------------------------- --------------------
ONLINE                      SYSTEM
ONLINE                      SYSAUX
ONLINE                      UNDOTBS1
ONLINE                      TEMP
ONLINE                      USERS
READ ONLY                   TBS_TEST1_NEW
ONLINE                      TBS_TEST2_NEW
ONLINE                      TBS_TEST3
ONLINE                      TBS_TEST_4
ONLINE                      TBS_TEST_5
ONLINE                      TBS_TEST_BIG

STATUS                      TABLESPACE_NAME
--------------------------- --------------------
ONLINE                      TEMP_1
ONLINE                      TBS_EXAMPLE

13 rows selected.

++删除表空间：

SQL> drop tablespace TBS_TEST_BIG
  2  including contents
  3  cascade constraints;

Tablespace dropped.

＋＋including contents删除表空间同时删除表中的数据，不指定而且表中有数据时
＋＋oralce会提示错误，并且不执行删除表空间

++cascade constraints删除表空间同时删除完整性限制，如果不指定，而且完整性存在
＋＋oracle提示错误，并且不执行删除表空间


++向表空间添加和删除数据文件：
++向表空间users添加数据文件

SQL> alter tablespace users    
  2  add datafile '/home/oracle/app/oradata/orcl/users02.dbf'   
  3  size 10m autoextend on next 5m maxsize unlimited;

Tablespace altered.


++以表空间名为USERS查询oracle系统文件信息:

SQL> r
  1  select file_name, tablespace_name
  2  from dba_data_files
  3* where tablespace_name = 'USERS'

FILE_NAME
--------------------------------------------------------------------------------
TABLESPACE_NAME
--------------------
/home/oracle/app/oradata/orcl/users01.dbf
USERS

/home/oracle/app/oradata/orcl/users02.dbf
USERS


++删除表空间中没有数据的文件，有数据的无法删除：

SQL> alter tablespace users drop datafile  
  2  '/home/oracle/app/oradata/orcl/users02.dbf';

Tablespace altered.


++查询oracle系统文件信息表，user02.dbf已经从表空间users中删掉

SQL> r
  1  select file_name, tablespace_name
  2  from dba_data_files
  3* where tablespace_name = 'USERS'

FILE_NAME
--------------------------------------------------------------------------------
TABLESPACE_NAME
--------------------
/home/oracle/app/oradata/orcl/users01.dbf
USERS

++查看表空间是否是自动扩展：

SQL> r
  1  select file_name, autoextensible
  2* from dba_data_files

FILE_NAME
--------------------------------------------------------------------------------
AUTOEXTEN
---------
/home/oracle/app/oradata/orcl/users01.dbf
YES

/home/oracle/app/oradata/orcl/undotbs01.dbf
YES

/home/oracle/app/oradata/orcl/sysaux01.dbf
YES


FILE_NAME
--------------------------------------------------------------------------------
AUTOEXTEN
---------
/home/oracle/app/oradata/orcl/system01.dbf
YES


++修改表的自动扩展属性：
SQL> alter database datafile    
  2  '/home/oracle/app/oradata/orcl/system01.dbf'
  3  autoextend on next 10m maxsize unlimited;

Database altered.

++undo表空间参数：

SQL> show parameter undo_tablespace;

NAME                                 TYPE
------------------------------------ ---------------------------------
VALUE
------------------------------
undo_tablespace                      string
UNDOTBS1
SQL> show parameter undo_management;

NAME                                 TYPE
------------------------------------ ---------------------------------
VALUE
------------------------------
undo_management                      string
AUTO
SQL> show parameter undo_retention;

NAME                                 TYPE
------------------------------------ ---------------------------------
VALUE
------------------------------
undo_retention                       integer
900

++撤销表空间基本操作：
＋＋创建undo表：

SQL> create undo tablespace undo_tbs_1
  2  datafile '/home/oracle/app/oradata/orcl/undotbs1.dbf'
  3  size 100m;

++给插销表空间增加表空间文件：

SQL> alter tablespace undo_tbs_1
  2  add datafile '/home/oracle/app/oradata/orcl/undotbs2.dbf'
  3  size 1g;

Tablespace altered.

++切换ysystem用户默认表空间为刚创建的撤销表空间：

SQL> alter system set undo_tablespace = undo_tbs_1;

System altered.

++查询撤销表空间参数：
SQL> show parameter undo_tablespace;

NAME                                 TYPE
------------------------------------ ---------------------------------
VALUE
------------------------------
undo_tablespace                      string
UNDO_TBS_1

++查询表空间当中的文件：
SQL> r
  1  select file_name, tablespace_name
  2  from dba_data_files
  3* where tablespace_name = 'UNDO_TBS_1'

FILE_NAME
--------------------------------------------------------------------------------
TABLESPACE_NAME
--------------------------------------------------------------------------------
/home/oracle/app/oradata/orcl/undotbs1.dbf
UNDO_TBS_1

/home/oracle/app/oradata/orcl/undotbs2.dbf
UNDO_TBS_1

++修改undo_tablespace默认表空间的为oracle系统默认的undotbs1
SQL> alter system set undo_tablespace=undotbs1
  2  ;

System altered.

++查看参数修改：
SQL> show parameter undo_tablespace;

NAME                                 TYPE
------------------------------------ ---------------------------------
VALUE
------------------------------
undo_tablespace                      string
UNDOTBS1

++查看当前实例拥有的所有undo表空间：
SQL> select tablespace_name from dba_tablespaces where contents = 'UNDO';

TABLESPACE_NAME
--------------------------------------------------------------------------------
UNDOTBS1
UNDO_TBS_1

++统计undo表空间中"回退块"的生成信息，通过查询v$undostat搜集undo统计信息：

SQL> r  
  1  select to_char(begin_time, 'hh24:mi:ss') as 开始时间,
  2  to_char(end_time, 'hh24:mi:ss') as 结束时间,
  3  undoblks as 回退块数
  4  from v$undostat
  5* order by begin_time

开始时间                 结束时间                   回退块数
------------------------ ------------------------ ----------
16:42:46                 10:22:46                          0
10:22:46                 10:32:46                         29
10:32:46                 10:42:46                        929
10:42:46                 10:52:46                         12
10:52:46                 11:02:46                         27
11:02:46                 11:12:46                         16
11:12:46                 11:22:46                          7
11:22:46                 11:32:46                          9
11:32:46                 11:42:46                          7
11:42:46                 11:52:46                          6
11:52:46                 12:02:46                         32

开始时间                 结束时间                   回退块数
------------------------ ------------------------ ----------
12:02:46                 12:12:46                          7
12:12:46                 12:22:46                          7
12:22:46                 12:32:46                          5
12:32:46                 12:42:46                          9
12:42:46                 12:52:46                         11
12:52:46                 13:02:46                         28
13:02:46                 13:12:46                          6
13:12:46                 13:22:46                          9
13:22:46                 13:32:46                          5
13:32:46                 13:42:46                         10
13:42:46                 13:52:46                          9

开始时间                 结束时间                   回退块数
------------------------ ------------------------ ----------
13:52:46                 14:02:46                         26
14:02:46                 14:12:46                          8
14:12:46                 14:22:46                         10
14:22:46                 14:32:46                          8
14:32:46                 14:42:46                          7
14:42:46                 14:52:46                          6
14:52:46                 15:02:46                         34
15:02:46                 15:12:46                          6
15:12:46                 15:22:46                          7
15:22:46                 15:32:46                          8
15:32:46                 15:42:46                          9

开始时间                 结束时间                   回退块数
------------------------ ------------------------ ----------
15:42:46                 15:52:46                          5
15:52:46                 16:02:46                         35
16:02:46                 16:12:46                          8
16:12:46                 16:22:46                         12
16:22:46                 16:32:46                         14
16:32:46                 16:36:27                          0

39 rows selected.
++通过以上信息，可以看出，oracle每隔10分钟生成一次统计信息。

++通过联合v$rollname和v$rollstat视图，查询undo段的统计信息
SQL> r
  1  select rn.name, rs.xacts, rs.writes, rs.extents
  2  from v$rollname rn, v$rollstat rs
  3* where rn.usn = rs.usn

NAME                                XACTS     WRITES    EXTENTS
------------------------------ ---------- ---------- ----------
SYSTEM                                  0      49368          6
_SYSSMU1_3780397527$                    0    3185600          6
_SYSSMU2_2232571081$                    0     623916          3
_SYSSMU3_2097677531$                    0    3745746          3
_SYSSMU4_1152005954$                    0     438438          3
_SYSSMU5_1527469038$                    0     601452          3
_SYSSMU6_2443381498$                    0     621024          3
_SYSSMU7_3286610060$                    0     497490          3
_SYSSMU8_2012382730$                    0     466834          3
_SYSSMU9_1424341975$                    0    1818786          3
_SYSSMU10_3550978943$                   0     634970          3

11 rows selected.

＋＋name标识undo动态段的名称
＋＋xacts标识undo段所包含的活动事物个数
＋＋writes标识undo段上写入的字节数
＋＋extents标识undo段的个数


＋＋动态事务查看：
＋＋先对t1表插入一条语句，并不提交，产生一个事务：
SQL> insert into t1 (id, name, score) values ('01', 'name01', 99);

1 row created.

++通过查询动态性能视图v$transaction来显示事务的名称和状态：
SQL> r  
  1* select name, status from v$transaction

NAME                 STATUS
-------------------- ------------------------------------------------
                     ACTIVE

++提交后查看动态事务状态：
＋＋提交：

SQL> commit;

Commit complete.

＋＋查看动态事务状态：

SQL> r        
  1* select name, status from v$transaction

no rows selected

++查看指定段的详细信息，从dba_undo_exetents
++从以上的查询undo段的统计信息联合表查询中的name中取得一个字段名:
SQL> column SEGMENT_NAME format a30
SQL> r
  1  select segment_name, extent_id, bytes, status
  2  from dba_undo_extents
  3* where segment_name = '_SYSSMU5_1527469038$'

SEGMENT_NAME                    EXTENT_ID      BYTES STATUS
------------------------------ ---------- ----------
---------------------------
_SYSSMU5_1527469038$                    0      65536 EXPIRED
_SYSSMU5_1527469038$                    1      65536 EXPIRED
_SYSSMU5_1527469038$                    2    1048576 UNEXPIRED

++segment_name标识指定段的名称
＋＋extent_id标识区编号
＋＋bytes标识区迟钝
＋＋status标识区状态：active表示处于活动，expired表示区未用

++临时表空间：

++创建临时表空间：
SQL> create temporary tablespace temp_01         
  2  tempfile '/home/oracle/app/oradata/orcl/temp_01.tpf'     
  3  size 300m;

Tablespace created.

++将新建的临时表空间，设置为默认的临时表空间：
SQL> alter database default temporary tablespace temp_01;

Database altered.

++查询临时表空间的信息：
SQL> r
  1* select file_name, bytes, tablespace_name from dba_temp_files

FILE_NAME                                               BYTES TABLESPACE
-------------------------------------------------- ---------- ----------
/home/oracle/app/oradata/orcl/temp_01.tpf           314572800 TEMP_01

++临时表空间组

＋＋创建临时表空间组：
SQL> create temporary tablespace tp1             
  2  tempfile '/home/oracle/app/oradata/orcl/tp1.tpf'    
  3  size 10m
  4  tablespace group group1;

Tablespace created.

SQL> r  
  1  create temporary tablespace tp2
  2  tempfile '/home/oracle/app/oradata/orcl/tp2.tpf'
  3  size 20m
  4* tablespace group group2

Tablespace created.

++转移临时表空间到另外一个组：
++为转移临时表空间到另外一个组，而创建一个临时表空间文件：
SQL> r  
  1  create temporary tablespace tp3
  2  tempfile '/home/oracle/app/oradata/orcl/tp3.tpf'
  3  size 10m
  4* tablespace group group3

Tablespace created.

++转移该文件，将group1中的临时表空间tp1转移到组group3中：
SQL> alter tablespace tp1 tablespace group group3;

Tablespace altered.

++在数据字典dba_tablespace_groups中查询组group3中所包含的临时表空间：
SQL> r  
  1  select * from dba_tablespace_groups
  2* where group_name = 'GROUP3'

GROUP_NAME           TABLESPACE
-------------------- ----------
GROUP3               TP1
GROUP3               TP3

++查询group1表空间，已经没有了内容：
SQL> r
  1  select * from dba_tablespace_groups
  2* where group_name = 'GROUP1'

no rows selected

++把表空间分配给指定的用户使用：
SQL> alter user sys temporary tablespace group3;

User altered.

++设置默认的临时表空间组：
SQL> alter database orcl default             
  2  temporary tablespace group3;

Database altered.

++切换系统默认临时表空间组group2

SQL> get tmp5
  1   alter database orcl default
  2*  temporary tablespace group2
  3  /  

Database altered.

++删除group3中的tp1临时表空间：
SQL> drop tablespace  tp1 including contents and datafiles;

Tablespace dropped.

++查询group3中的表空间的情况：

SQL> select * from dba_tablespace_groups where group_name = 'GROUP3';

GROUP_NAME           TABLESPACE
-------------------- ----------
GROUP3               TP3

++只剩下tp3临时表空间。

++将group3中的tp3临时表空间删除：
SQL> drop tablespace tp3 including contents and datafiles;

Tablespace dropped.

+查询数据字典dba_tablespace_groups中group3是否存在：
SQL> select * from dba_tablespace_groups  where group_name = 'GROUP3';

no rows selected

++第九章 数据表对象
＋＋创建数据表：
SQL> create table students(  
  2  stuno number(10) not null,
  3  stuname varchar2(8),
  4  sex int,
  5  departno varchar2(2) not null,
  6  classno varchar2(4) not null,
  7  regdate date default sysdate
  8  );

Table created.

++查看数据表结构：

SQL> describe students;
 Name                                      Null?    Type
 ----------------------------------------- --------
----------------------------
 STUNO                                     NOT NULL NUMBER(10)
 STUNAME                                            VARCHAR2(8)
 SEX                                                NUMBER(38)
 DEPARTNO                                  NOT NULL VARCHAR2(2)
 CLASSNO                                   NOT NULL VARCHAR2(4)
 REGDATE                                            DATE

++根据另外一张表的内容，创建一张表：
++查看t1的内容：
SQL> select  * from t1;

ID           NAME                                SCORE
------------ ------------------------------ ----------
             好
                                                   100
                                                   101
01           name01                                 99

SQL>   

++根据t1创建tt1表：
++创建以及查看内容：
SQL> create table tt1   
  2  as   
  3  select * from t1;

Table created.

SQL> select * from tt1;

ID           NAME                                SCORE
------------ ------------------------------ ----------
             好
                                                   100
                                                   101
01           name01                                 99

SQL> 

++创建students_3表，分配在users表空间中
SQL> create table students_3 (
  2  stuno number(10) not null,
  3  stuname varchar2(8),
  4  sex char(2),
  5  age int,
  6  departno varchar2(2) not null,
  7  classno varchar2(4) not null,
  8  regdate date default sysdate
  9  ) tablespace users
 10  storage (initial 256k);

Table created.

++查看users表空间：
SQL> r
  1  select tablespace_name, file_name
  2  from dba_data_files
  3* where tablespace_name = 'USERS'

TABLESPACE FILE_NAME
---------- --------------------------------------------------
USERS      /home/oracle/app/oradata/orcl/users01.dbf


＋＋查看students_3表分配初始化盘区的大小：
SQL> r  
  1  select initial_extent
  2  from user_tables
  3  where table_name = 'STUDENTS_3'
  4*

INITIAL_EXTENT
--------------
        262144

++设置pctfree和ptcused
＋＋update多，改变记录大小，尽量保证数据留在原数据块中，推荐pctfree设置20，pctused设置40
＋＋insert和delete多，update不改变记录大小，保障释放的存储空间尽快可用
＋＋推荐pctfree为5，pctused为60

++用pctfree和pctused创建表students_4
SQL> create table students_4 ( 
  2  stuno number(10) not null,
  3  stuname varchar2(8),
  4  sex char(2),
  5  age int,
  6  departno varchar2(2) not null,
  7  classno varchar2(4) not null,
  8  regdate date default sysdate
  9  ) tablespace users
 10  storage (initial 256k)
 11  pctfree 20
 12  pctused 40;

Table created.

++通过查询user_tables查询ptcfree和pctused参数的设置情况：

  1  select pct_free,  pct_used, table_name
  2* from user_tables where table_name = 'STUDENTS_4'

  PCT_FREE   PCT_USED TABLE_NAME
---------- ---------- --------------------
        20            STUDENTS_4

++创建数据块头部存放10个事物条目的表students_5:

SQL> create table students_5 ( 
  2  stuno number(10) not null,
  3  stuname varchar2(8),
  4  sex char(2),
  5  age int,
  6  departno varchar2(2) not null,
  7  classno varchar2(4) not null,
  8  regdate date default sysdate
  9  ) tablespace users
 10  storage (initial 256k)
 11  pctfree 20
 12  pctused 40
 13  initrans 10;

Table created.

++查看students_5表中的initrans和maxtrans参数的设置，通过user_tables表查看：
SQL> select ini_trans, max_trans    
  2  from user_tables
  3  where table_name = 'STUDENTS_5';

 INI_TRANS  MAX_TRANS
---------- ----------
        10        255

++创建ddl操作也被记录重做日志的表
SQL> r
  1  create table students_6 (
  2  stuno number(10) not null,
  3  stuname varchar2(8),
  4  sex char(2),
  5  age int,
  6  departno varchar2(2) not null,
  7  classno varchar2(4) not null,
  8  regdate date default sysdate
  9  ) tablespace users
 10  storage(initial 256k)
 11  pctfree 20
 12  pctused 40
 13  initrans 10
 14* nologging

Table created.

SQL>    

＋＋在user_tables数据字段字典中查询stundents_6表是否用了缓存功能
SQL> r
  1  select table_name, cache
  2  from user_tables
  3* where table_name = 'STUDENTS_6'

TABLE_NAME           CACHE
-------------------- --------------------
STUDENTS_6               N

++创建带缓存的表，让最近访问数据表进行lru算法缓存，使经常访问的数据表提升效率：

SQL> r  
  1  create table students_7 (
  2  stuno number(10) not null,
  3  stuname varchar2(8),
  4  sex char(2),
  5  age int,
  6  departno varchar2(2) not null,
  7  classno varchar2(4) not null,
  8  regdate date default sysdate
  9  ) tablespace users
 10  storage(initial 256k)
 11  pctfree 20
 12  pctused 40
 13  initrans 10
 14  nologging
 15* cache

Table created.

++查看students_7的缓存设置：
SQL> select table_name, cache               
  2  from user_tables
  3  where table_name = 'STUDENTS_7';

TABLE_NAME           CACHE
-------------------- --------------------
STUDENTS_7               Y


++查看students_7的缓存设置：
SQL> select table_name, cache               
  2  from user_tables
  3  where table_name = 'STUDENTS_7';

TABLE_NAME           CACHE
-------------------- --------------------
STUDENTS_7               Y

＋＋数据表维护：
＋＋增加列：
SQL> alter table students_6 add(province varchar2(10));

Table altered.

SQL> describe students_6;
 Name                                      Null?    Type
 ----------------------------------------- --------
----------------------------
 STUNO                                     NOT NULL NUMBER(10)
 STUNAME                                            VARCHAR2(8)
 SEX                                                CHAR(2)
 AGE                                                NUMBER(38)
 DEPARTNO                                  NOT NULL VARCHAR2(2)
 CLASSNO                                   NOT NULL VARCHAR2(4)
 REGDATE                                            DATE
 PROVINCE                                           VARCHAR2(10)

++删除表列：
++新连接用户：
SQL> connect scott   
Enter password: 
Connected.

＋＋创建新表：
SQL> create table t1(  
  2  id number(2),
  3  name varchar2(10)
  4  );   

Table created.

++查看表结构
SQL> describe t1;
 Name                                      Null?    Type
 ----------------------------------------- --------
----------------------------
 ID                                                 NUMBER(2)
 NAME                                               VARCHAR2(10)

++增加列：

SQL> alter table t1 add (province varchar2(10));

Table altered.

++查看增加列后表结构：
SQL> describe t1;
 Name                                      Null?    Type
 ----------------------------------------- --------
----------------------------
 ID                                                 NUMBER(2)
 NAME                                               VARCHAR2(10)
 PROVINCE                                           VARCHAR2(10)

++删除单列：
SQL> alter table t1 drop column province;

Table altered.

++删除后查看表结构：
SQL> describe t1;
 Name                                      Null?    Type
 ----------------------------------------- --------
----------------------------
 ID                                                 NUMBER(2)
 NAME                                               VARCHAR2(10)

++增加多列：
SQL> alter table t1 add (c1 varchar2(1), c2 varchar2(1));

Table altered.

++增加后查看表结构，已经增加了两列：
SQL> describe t1;
 Name                                      Null?    Type
 ----------------------------------------- --------
----------------------------
 ID                                                 NUMBER(2)
 NAME                                               VARCHAR2(10)
 C1                                                 VARCHAR2(1)
 C2                                                 VARCHAR2(1)

++删除多列：
SQL> alter table t1 drop (c1, c2);

Table altered.

++删除后查看表结构：
SQL> describe t1;
 Name                                      Null?    Type
 ----------------------------------------- --------
----------------------------
 ID                                                 NUMBER(2)
 NAME                                               VARCHAR2(10)

++删除表所有列查看是否成功：
SQL> alter table t1 drop (id, name);
alter table t1 drop (id, name)
*
ERROR at line 1:
ORA-12983: cannot drop all columns in a table

++不能删除表的所有列。

＋＋增加列：
SQL> alter table t1 add prvince varchar2(10);

Table altered.

++修改列：
SQL> alter table t1 modify prvince varchar2(1);

Table altered.

++查看修改：

SQL> describe t1;
 Name                                      Null?    Type
 ----------------------------------------- --------
----------------------------
 ID                                                 NUMBER(2)
 NAME                                               VARCHAR2(10)
 PRVINCE                                            VARCHAR2(1)

++重命名列名：
SQL> select * from t1;

ID           NAME                                                  SCORE
------------ ------------------------------------------------ ----------
01           t01                                                      99
             好

SQL> alter table t1 rename column name to name1;

Table altered.

SQL> describe t1
 Name                                      Null?    Type
 ----------------------------------------- --------
----------------------------
 ID                                                 VARCHAR2(4)
 NAME1                                              VARCHAR2(16)
 SCORE                                              NUMBER(3)



++重命名表：
SQL> alter table t1 rename to t2;

Table altered.


++给表移动一个表空间的准备：

＋＋创建临时表空间：
SQL> create temporary tablespace temp_dog
  2  tempfile '/home/oracle/app/oradata/orcl/temp_dog1.dbf'
  3  size 20m;

Tablespace created.

++建错了没用，删除临时表空间：
SQL> drop tablespace temp_dog;

Tablespace dropped.

++创建数据表空间：
SQL> create tablespace file_data_dog
  2  logging 
  3  datafile '/home/oracle/app/oradata/orcl/data_dog1.dbf'
  4  size 20m;

Tablespace created.

++在file_data_dog表空间上创建表：
SQL> create table t3 (id number(2), name varchar2(2)) tablespace
file_data_dog;

Table created.

++将创建在file_data_dog表空间上的表，移动到users表空间上，再移动回来：
SQL> alter table t3 move tablespace users;

Table altered.

SQL> alter table t3 move tablespace file_data_dog;

Table altered.

++查看表和对应表空间：
SQL> r
  1  select table_name, tablespace_name
  2  from user_tables
  3* where table_name = 'T3'

TABLE_NAME           TABLESPACE_NAME
-------------------- --------------------
T3                   FILE_DATA_DOG

++设置表的存储参数：
SQL> alter table t3 pctfree 25 pctused 45;

Table altered.

++查看存储参数设置：
SQL> r
  1  select pct_free, pct_used, table_name
  2  from user_tables
  3* where table_name = 'T3'

PCT_FREE PCT_USED TABLE_NAME
-------- -------- --------------------
      25          T3

++根据t3创建t4，再删除t4：
SQL> create table t4 
  2  as
  3  select * from t3;

Table created.

SQL> drop table t4;

Table dropped.

++查看数据库支持的选项：
SQL> column parameter format a30
SQL> column value format a20
SQL> r
  1* select parameter, value from v$option

PARAMETER                      VALUE
------------------------------ --------------------
Partitioning                   FALSE
Objects                        TRUE
Real Application Clusters      FALSE
Advanced replication           FALSE
Bit-mapped indexes             FALSE
Connection multiplexing        TRUE
Connection pooling             TRUE
Database queuing               TRUE
Incremental backup and recover TRUE
y


PARAMETER                      VALUE
------------------------------ --------------------
Instead-of triggers            TRUE
Parallel backup and recovery   FALSE
Parallel execution             FALSE
Parallel load                  TRUE
Point-in-time tablespace recov FALSE
ery

Fine-grained access control    FALSE
Proxy authentication/authoriza TRUE
tion


PARAMETER                      VALUE
------------------------------ --------------------
Change Data Capture            FALSE
Plan Stability                 TRUE
Online Index Build             FALSE
Coalesce Index                 TRUE
Managed Standby                FALSE
Materialized view rewrite      FALSE
Materialized view warehouse re FALSE
fresh

Database resource manager      FALSE
Spatial                        FALSE

PARAMETER                      VALUE
------------------------------ --------------------
Automatic Storage Management   FALSE
Export transportable tablespac FALSE
es

Transparent Application Failov TRUE
er

Fast-Start Fault Recovery      FALSE
Sample Scan                    TRUE
Duplexed backups               FALSE
Java                           TRUE

PARAMETER                      VALUE
------------------------------ --------------------
OLAP Window Functions          TRUE
Block Media Recovery           FALSE
Fine-grained Auditing          FALSE
Application Role               FALSE
Enterprise User Security       FALSE
Oracle Data Guard              FALSE
Oracle Label Security          FALSE
OLAP                           FALSE
Basic Compression              FALSE
Join index                     FALSE
Trial Recovery                 FALSE

PARAMETER                      VALUE
------------------------------ --------------------
Data Mining                    FALSE
Online Redefinition            FALSE
Streams Capture                FALSE
File Mapping                   FALSE
Block Change Tracking          FALSE
Flashback Table                FALSE
Flashback Database             FALSE
Transparent Data Encryption    FALSE
Backup Encryption              FALSE
Unused Block Compression       FALSE
Oracle Database Vault          FALSE

PARAMETER                      VALUE
------------------------------ --------------------
Result Cache                   FALSE
SQL Plan Management            FALSE
SecureFiles Encryption         FALSE
Real Application Testing       FALSE
Flashback Data Archive         FALSE
DICOM                          TRUE
Active Data Guard              FALSE
Server Flash Cache             FALSE
Advanced Compression           FALSE
XStream                        FALSE
Deferred Segment Creation      FALSE

65 rows selected.

++查看数据库的版本，标准版是不支持闪回技术的：
SQL> select * from v$version;

BANNER
--------------------------------------------------------------------------------
Oracle Database 11g Release 11.2.0.1.0 - 64bit Production
PL/SQL Release 11.2.0.1.0 - Production
CORE    11.2.0.1.0      Production
TNS for Linux: Version 11.2.0.1.0 - Production
NLSRTL Version 11.2.0.1.0 - Production

＋＋设置表为只读状态：
++创建表并构建数据
SQL> create table t3 
  2  (id number(2), name varchar2(10));

Table created.

SQL> insert into t3    
  2  (id, name)
  3  values (1, 'name1');

1 row created.

＋＋修改表为只读状态
SQL> alter table t3 read only;

Table altered.

++插入数据失败，提示表为只读
SQL> insert into t3
  2  (id, name)
  3  values(2, 'name2');
insert into t3
            *
ERROR at line 1:
ORA-12081: update operation not allowed on table "SYS"."T3"


++查看表的状态：

SQL> select table_name, read_only   
  2  from user_tables
  3  where table_name = 'T3';

TABLE_NAME           READ_ONLY
-------------------- ---------
T3                   YES

++重新设置表的属性为可读可写
SQL> alter table t3 read write;

Table altered.

++查询状态变只读标志变成了失效：
SQL> select table_name, read_only
  2  from user_tables
  3  where table_name = 'T3';

TABLE_NAME           READ_ONLY
-------------------- ---------
T3                   NO

++非空约束：
++创建带非空约束的表：

SQL> create table t4  
  2  (id number(2) not null,   
  3  name varchar2(10) not null);

Table created.

SQL> select * from t4;

no rows selected

SQL> insert into t4 (name) values('name1');
insert into t4 (name) values('name1')
*
ERROR at line 1:
ORA-01400: cannot insert NULL into ("SYS"."T4"."ID")


SQL> insert into t4 (id) values(1);
insert into t4 (id) values(1)
*
ERROR at line 1:
ORA-01400: cannot insert NULL into ("SYS"."T4"."NAME")

SQL> insert into t4
  2  (id, name)
  3  values(1, 'name1');

1 row created.

++改变表的非空约束：
SQL> alter table t4 modify id null;

Table altered.

＋＋向表中添加一条值为空的记录
SQL> insert into t4 (name) values ('name2');

1 row created.

++改变表的约束为非空，提示失败，因为该列的约束上有非空的值
SQL> alter table t4 modify id not null;
alter table t4 modify id not null
*
ERROR at line 1:
ORA-02296: cannot enable (SYS.) - null values found


SQL> select * from t4;

        ID NAME
---------- ------------------------------
         1 name1
           name2

＋＋删除该空记录：
SQL> delete t4 where name = 'name2';

1 row deleted.

++再次添加非空约束，则成功
SQL> alter table t4 modify id not null;

Table altered.

++创建表时建立主键：
SQL> create table t5 
  2  (id number(2),
  3  name varchar2(10),
  4  age number(2),
  5  constraint t5_id_pk primary key(id)
  6  );

Table created.

++查询主键：
SQL> get tmp2
  1  select owner, constraint_name, constraint_type, table_name
  2  from user_constraints
  3* where table_name = 'T5'
  4  /

OWNER                CONSTRAINT_NAME      CON TABLE_NAME
-------------------- -------------------- --- --------------------
SYS                  T5_ID_PK             P   T5

++忽略主键名字在字段上直接建立主键：
SQL> create table t6
  2  (id number(2) primary key,  
  3  name varchar2(10),
  4  age number(2));

Table created.

++查询主键：
SQL> r
  1  select owner, constraint_name, constraint_type, table_name
  2  from user_constraints
  3* where table_name = 'T6'

OWNER                CONSTRAINT_NAME      CON TABLE_NAME
-------------------- -------------------- --- --------------------
SYS                  SYS_C0010921         P   T6

++查询主键所在的列名及主键的信息：
SQL> get tmp2
  1  select a.column_name, b.owner, b.constraint_name, b.constraint_type,
b.table_name
  2  from user_cons_columns a, user_constraints b
  3* where b.table_name = 'T5' and a.constraint_name = b.constraint_name
SQL> /

COLUMN_NAME          OWNER                CONSTRAINT_NAME      CON
-------------------- -------------------- -------------------- ---
TABLE_NAME
--------------------
ID                   SYS                  T5_ID_PK             P
T5

++删除t5表的有名主键：
SQL> alter table t5   
  2  drop constraint t5_id_pk;

Table altered.

++删除之后查询主键，已经不存在了
SQL> get tmp2
  1  select a.column_name, b.owner, b.constraint_name, b.constraint_type,
b.table_name
  2  from user_cons_columns a, user_constraints b
  3* where b.table_name = 'T5' and a.constraint_name = b.constraint_name
SQL> /

no rows selected

++用修改表的方法再次增加主键：
SQL> alter table t5  
  2  add constraint t5_id_pk primary key(id);

++再次查询主键，主键又有了：
SQL> r
  1  select a.column_name, b.owner, b.constraint_name, b.constraint_type,
b.table_name
  2  from user_cons_columns a, user_constraints b
  3* where b.table_name = 'T5' and a.constraint_name = b.constraint_name

COLUMN_NAME          OWNER                CONSTRAINT_NAME      CON
-------------------- -------------------- -------------------- ---
TABLE_NAME
--------------------
ID                   SYS                  T5_ID_PK             P
T5

++查询t6表的主键：
SQL> r
  1  select a.column_name, b.owner, b.constraint_name, b.constraint_type,
b.table_name
  2  from user_cons_columns a, user_constraints b
  3* where b.table_name = 'T6' and a.constraint_name = b.constraint_name

COLUMN_NAME          OWNER                CONSTRAINT_NAME      CON
-------------------- -------------------- -------------------- ---
TABLE_NAME
--------------------
ID                   SYS                  SYS_C0010921         P
T6

＋＋用修改表方法删除t6表的系统默认名字的主键：
SQL> alter table t6 
  2  drop constraint SYS_C0010921;

Table altered.

++查看t6表的主键，已经不存在：
SQL> r
  1  select a.column_name, b.owner, b.constraint_name, b.constraint_type,
b.table_name
  2  from user_cons_columns a, user_constraints b
  3* where b.table_name = 'T6' and a.constraint_name = b.constraint_name

no rows selected

++用修改表的方法，增加t6表的主键：
SQL> alter table t6
  2  add primary key(id)
  3  ;

Table altered.

++查询表t6的主键：
SQL> r
  1  select a.column_name, b.owner, b.constraint_name, b.constraint_type,
b.table_name
  2  from user_cons_columns a, user_constraints b
  3* where b.table_name = 'T6' and a.constraint_name = b.constraint_name

COLUMN_NAME          OWNER                CONSTRAINT_NAME      CON
-------------------- -------------------- -------------------- ---
TABLE_NAME
--------------------
ID                   SYS                  SYS_C0010929         P
T6

++联合主键：
++创建数据表:
SQL> create table t7 
  2  (id number(2),   
  3  name varchar2(2),
  4  age number(2)
  5  );

Table created.

＋＋增加新创建表的id和name列为联合主键：
SQL> alter table t7 
  2  add primary key(id, name);

Table altered.

++查看t7表的主键，两个列共用了同一个主键名
SQL> get tmp2
  1  select a.column_name, b.owner, b.constraint_name, b.constraint_type,
b.table_name
  2  from user_cons_columns a, user_constraints b
  3* where b.table_name = 'T7' and a.constraint_name = b.constraint_name
SQL> r
  1  select a.column_name, b.owner, b.constraint_name, b.constraint_type,
b.table_name
  2  from user_cons_columns a, user_constraints b
  3* where b.table_name = 'T7' and a.constraint_name = b.constraint_name

COLUMN_NAME          OWNER                CONSTRAINT_NAME      CON
-------------------- -------------------- -------------------- ---
TABLE_NAME
--------------------
ID                   SYS                  SYS_C0010936         P
T7

NAME                 SYS                  SYS_C0010936         P
T7

++插入记录：
SQL> insert into t7
  2  (id, name) 
  3  values (1, 'name01');

1 row created.

++插入联合主键两列当中一列重复，但主键不重复的记录，可以插入
SQL> insert into t7
  2  (id, name)
  3  values (1, 'name02');

1 row created.

++插入联合主键重复的记录，不允许插入
SQL> insert into t7   
  2  (id, name)
  3  values (1, 'name01');
insert into t7
*
ERROR at line 1:
ORA-00001: unique constraint (SYS.SYS_C0010830) violated


++删除t7表的主键：
SQL> alter table t7
  2  drop constraint SYS_C0010936;

Table altered.

++查询表t7的主键已经不存在了：
SQL> r
  1  select a.column_name, b.owner, b.constraint_name, b.constraint_type,
b.table_name
  2  from user_cons_columns a, user_constraints b
  3* where b.table_name = 'T7' and a.constraint_name = b.constraint_name

no rows selected

++唯一约束：
SQL> create table members
  2  (memno number(4) not null,
  3  memname varchar2(20) not null,
  4  email varchar2(30),
  5  qq varchar2(20) constraint qq_uk unique);

Table created.

SQL> insert into members(memno, memname, email, qq)
  2  values (1, 'leo', 'dear531@21cn.com', '83513251');

1 row created.

++重复插入第二条数据，显示违反唯一约束：
SQL> r  
  1  insert into members(memno, memname, email, qq)
  2* values (1, 'leo', 'dear531@21cn.com', '83513251')
insert into members(memno, memname, email, qq)
*
ERROR at line 1:
ORA-00001: unique constraint (SYS.QQ_UK) violated

++插入qq列是空的记录，成功插入，允许为空：
SQL> r
  1  insert into members(memno, memname)
  2* values(2, 'leo2')

1 row created.

++添加通过修改表结构的方式添加唯一约束：
SQL> alter table members add constraint email_uk unique(email);

Table altered.

++查看表的唯一约束：
SQL> r  
  1  select a.column_name, b.owner, b.constraint_name, b.constraint_type,
b.table_name
  2  from user_cons_columns a, user_constraints b
  3* where b.table_name = 'MEMBERS' and a.constraint_name = b.constraint_name

COLUMN_NAM OWNER      CONSTRAINT CON TABLE_NAME
---------- ---------- ---------- --- ----------
MEMNO      SYS        SYS_C00108 C   MEMBERS
                      33

MEMNAME    SYS        SYS_C00108 C   MEMBERS
                      34

QQ         SYS        QQ_UK      U   MEMBERS
EMAIL      SYS        EMAIL_UK   U   MEMBERS

++通过修改表的方式删除唯一约束：
SQL> alter table members drop constraint email_uk;

Table altered.

++查看表的唯一约束，已经被删掉：
SQL> r
  1  select a.column_name, b.owner, b.constraint_name, b.constraint_type,
b.table_name
  2  from user_cons_columns a, user_constraints b
  3* where b.table_name = 'MEMBERS' and a.constraint_name = b.constraint_name

COLUMN_NAM OWNER      CONSTRAINT CON TABLE_NAME
---------- ---------- ---------- --- ----------
MEMNO      SYS        SYS_C00108 C   MEMBERS
                      33

MEMNAME    SYS        SYS_C00108 C   MEMBERS
                      34

QQ         SYS        QQ_UK      U   MEMBERS

++外键：
＋＋创建t7并给t7表的id列设置为主键：
SQL> create table t7  
  2  (id number(2),
  3  name varchar2(10),
  4  age number(2));

Table created.

SQL> alter table t7
  2  add constraint t7_id_pk primary key(id);

Table altered.

++查看t7表的约束情况：
SQL> r  
  1  select a.column_name, b.owner, b.constraint_name, b.constraint_type,
b.table_name
  2  from user_cons_columns a, user_constraints b
  3* where b.table_name = 'T7' and a.constraint_name = b.constraint_name

COLUMN_NAM OWNER      CONSTRAINT CON TABLE_NAME
---------- ---------- ---------- --- ----------
ID         SYS        T7_ID_PK   P   T7

++创建t8表，并设置t8表的id的外键为t7表的id列：
SQL> create table t8
  2  (id number(2),   
  3  address varchar2(10));

Table created.

SQL> alter talbe t8    
  2  add constraint t8_fk_t7 
  3  foreign key (id)
  4  references departments(t7.id);

COLUMN_NAM OWNER      CONSTRAINT CON TABLE_NAME
---------- ---------- ---------- --- ----------
ID         SYS        T8_FK_T7   R   T8

++插入两条t7列id列有的值，均能插入，插入一条没有的则违反约束：
SQL> insert into t8
  2  (id, address)  
  3  values(1, 'beijing');

1 row created.

SQL> insert into t8
  2  (id, address)
  3  values(1, 'shanghai');

1 row created.

SQL> insert into t8
  2  (id, address)
  3  values (2, 'beijing');
insert into t8
*
ERROR at line 1:
ORA-02291: integrity constraint (SYS.T8_FK_T7) violated - parent key not found

++当插入外键列为空值时，允许插入：
SQL> insert into t8
  2  (address)
  3  values ('shanghai');

1 row created.


++外键属性的类型：
++默认not action类型
SQL> l  
  1  create table t8
  2  (id number(2),
  3  address varchar2(10),
  4  constraint t8_fk_t7
  5  foreign key(id)
  6  references t7(id)
  7* )

++t7和t8表数据：
SQL> select * from t7;

        ID NAME                                  AGE
---------- ------------------------------ ----------
         1 name02                                 20

SQL> select * from t8;

        ID ADDRESS
---------- ------------------------------
         1 beijing

SQL> delete t7 where id = 1;
delete t7 where id = 1
*
ERROR at line 1:
ORA-02292: integrity constraint (SYS.T8_FK_T7) violated - child record found

++修改外键只能删除再重新建：
SQL> alter table t8
  2  drop constraint t8_fk_t7;

Table altered.

SQL> r
  1  alter table t8
  2  add constraint t8_fk_t7
  3  foreign key(id)
  4  references t7(id)
  5* on delete cascade

Table altered.

++设置为级联删除之后，删除t7表中的逐渐，引用了t7表的t8表的级联数据也被删除：
SQL> select * from t7;

        ID NAME                                  AGE
---------- ------------------------------ ----------
         1 name02                                 20

SQL> select * from t8;

        ID ADDRESS
---------- ------------------------------
         1 beijing

SQL> delete t7 where id = 1;

1 row deleted.

SQL> select * from t7;

no rows selected

SQL> select * from t8;

no rows selected

++用删除重新建的方法，修改t8外键级联属性：
SQL> alter table t8
  2  drop constraint t8_fk_t7;

Table altered.
SQL> r
  1  alter table t8
  2  add constraint t8_fk_t7
  3  foreign key(id)
  4  references t7(id)
  5* on delete set null

Table altered.

++准备t7，t8表数据如下：
SQL> select * from t7;

        ID NAME                                  AGE
---------- ------------------------------ ----------
         1 name1                                  10

SQL> select * from t8;

        ID ADDRESS
---------- ------------------------------
         1 beijing

++删除t7表的数据，t8表的数据相关联数据的列被置空：
SQL> delete t7 where id = 1;

1 row deleted.

SQL> select * from t7;

no rows selected

SQL> select * from t8;

        ID ADDRESS
---------- ------------------------------
           beijing

++约束的开启及禁止：
++创建时设置关闭：
SQL> r  
  1  create table t9
  2  (id number(2),
  3  name varchar2(10),
  4  age int constraint age_check check(age > 0 and age < 120) disable
  5* )

Table created.

＋＋通过alter修关闭已生效的约束：
++开启再关闭：
SQL> alter table t9
  2  enable constraint age_check;

Table altered.

SQL> alter table t9
  2  disable constraint age_check;

Table altered.

++禁用主键的及其级联：
SQL> r
  1  alter table t7
  2  disable constraint T7_ID_PK
  3* cascade

Table altered.

++查看主键及外键状态：
SQL> r
  1  select a.column_name, b.STATUS, b.owner, b.constraint_name,
b.constraint_type, b.table_name
  2  from user_cons_columns a, user_constraints b
  3* where b.table_name in ('T7', 'T8') and a.constraint_name =
b.constraint_name

COLUMN_NAM STATUS                   OWNER      CONSTRAINT CON TABLE_NAME
---------- ------------------------ ---------- ---------- --- ----------
ID         DISABLED                 SYS        T7_ID_PK   P   T7
ID         DISABLED                 SYS        T8_FK_T7   R   T8

++分别开启主键和外键约束：
SQL> r
  1  alter table t7
  2* enable constraint T7_ID_PK

Table altered.

SQL> alter table t8
  2  enable constraint T8_FK_T7;

Table altered.

++查看主键和外键状态：
SQL> r
  1  select a.column_name, b.STATUS, b.owner, b.constraint_name,
b.constraint_type, b.table_name
  2  from user_cons_columns a, user_constraints b
  3* where b.table_name in ('T7', 'T8') and a.constraint_name =
b.constraint_name

COLUMN_NAM STATUS                   OWNER      CONSTRAINT CON TABLE_NAME
---------- ------------------------ ---------- ---------- --- ----------
ID         ENABLED                  SYS        T7_ID_PK   P   T7
ID         ENABLED                  SYS        T8_FK_T7   R   T8

++用scott模式给emp的deptno列添加索引：
++指定空闲表空间比例为25％，指定表空间为users
SQL> r
  1  create index emp_deptno_index on emp(deptno)
  2  pctfree 25
  3* tablespace users

Index created.

++建立反向键索引：
SQL> connect scott/tiger
Connected.
SQL> create index emp_job_reverse
  2  on emp(job) reverse
  3  tablespace users;

Index created.

++重新生成索引为反向键索引：
SQL> alter index emp_deptno_index
  2  rebuild reverse;

Index altered.

++将字段值进行函数转化后建立索引，在进行搜索时也要加函数才有效：
SQL> create index emp_job_fun
  2  on emp(lower(job));

Index created.

++整理索引，合并空闲索引碎片：
SQL> alter index emp_deptno_index
  2  coalesce deallocate unused;

Index altered.

++按原有结构重新建立索引：
SQL> alter index emp_deptno_index rebuild;

Index altered.

++将索引重新建立，放置在users表空间中：
SQL> alter index emp_deptno_index rebuild
  2  tablespace users;

Index altered.

++重新建立索引的过程，是建立新索引之后，删除了原有索引。

++删除索引：
SQL> drop index emp_job_fun;

Index dropped.

++查询索引：
SQL> r
  1  select index_name, index_type
  2  from dba_indexes
  3* where owner = 'SCOTT'

INDEX_NAME           INDEX_TYPE
-------------------- ------------------------------
PK_DEPT              NORMAL
PK_EMP               NORMAL
EMP_JOB_REVERSE      NORMAL/REV
EMP_DEPTNO_INDEX     NORMAL/REV

++显示索引列：
++其中有三个表：dba_ind_columns, user_ind_columns,all_ind_columns
++都能进行索引列查询：
SQL> r
  1  select column_name, column_length
  2  from dba_ind_columns
  3* where index_name = 'EMP_DEPTNO_INDEX'

COLUMN_NAME                    COLUMN_LENGTH
------------------------------ -------------
DEPTNO                                    22

++查询索引的索引段：
SQL> connect scott
Enter password: 
Connected.

SQL> r
  1  select tablespace_name, segment_type, bytes
  2  from user_segments
  3* where segment_name = upper('emp_deptno_index')

TABLESPACE_NAME
--------------------------------------------------------------------------------
SEGMENT_TYPE                                                BYTES
------------------------------------------------------ ----------
USERS
INDEX                                                       65536


++查询函数索引：
SQL> create index emp_job_fun
  2  on emp(lower(job));

Index created.

SQL> select column_expression
  2  from user_ind_expressions
  3  where index_name = 'EMP_JOB_FUN';

COLUMN_EXPRESSION
--------------------------------------------------------------------------------
LOWER("JOB")

++视图：
＋＋建立简单视图：
++用sys或是system用户给scott用户授权建立视图权限
SQL> connect / as sysdba
Connected.
SQL> grant create view to scott;

Grant succeeded.

SQL> connect scott
Enter password: 
Connected.
SQL> create or replace view emp_view as
  2  select empno, ename, job, deptno
  3  from emp
  4  where deptno = 20;

View created.

SQL> select * from emp_view;

     EMPNO ENAME                          JOB
DEPTNO
---------- ------------------------------ ---------------------------
----------
      7369 SMITH                          CLERK
20
      7566 JONES                          MANAGER
20
      7788 SCOTT                          ANALYST
20
      7876 ADAMS                          CLERK
20
      7902 FORD                           ANALYST
20

++对视图进行数据操作：
SQL> insert into emp_view
  2  values(9527, '东方', 'manager', 20);

1 row created.

SQL> update emp_view
  2  set ename = '西方'
  3  where empno = 9527;

1 row updated.

SQL> select * from emp_view;

     EMPNO ENAME                          JOB
DEPTNO
---------- ------------------------------ ---------------------------
----------
      7369 SMITH                          CLERK
20
      7566 JONES                          MANAGER
20
      7788 SCOTT                          ANALYST
20
      7876 ADAMS                          CLERK
20
      7902 FORD                           ANALYST
20
      9527 西方                           manager
20

6 rows selected.

SQL> delete emp_view where empno = 9527;

1 row deleted.

SQL> commit;

Commit complete.

++只读视图：
SQL> create or replace view emp_view_readonly as
  2  select * from dept
  3  where deptno != 88
  4  with read only;

View created.

++试图修改只读视图上的数据，会提示是只读的，失败：
SQL> update emp_view_readonly set LOC = '1';   
update emp_view_readonly set LOC = '1'
                             *
ERROR at line 1:
ORA-42399: cannot perform a DML operation on a read-only view

++复杂视图：
SQL> r
  1  create or replace view emp_view_complex as
  2  select deptno 部门编号, max(sal) 最高工资, min(sal) 工资, avg(sal)
平均工资
  3  from emp
  4* group by deptno

View created.

SQL> select * from emp_view_complex;

  部门编号   最高工资       工资   平均工资
---------- ---------- ---------- ----------
        30       2850        950 1566.66667
        20       3000        800       2175
        10       5000       1300 2916.66667

++连接视图：
SQL> create or replace view emp_view_union as
  2  select d.dname, d.loc, e.empno, e.ename
  3  from emp e, dept d
  4  where e.deptno = d.deptno and d.deptno = 20;

View created.

SQL> r
  1* select * from emp_view_union

DNAME                LOC                       EMPNO ENAME
-------------------- -------------------- ---------- --------------------
RESEARCH             DALLAS                     7369 SMITH
RESEARCH             DALLAS                     7566 JONES
RESEARCH             DALLAS                     7788 SCOTT
RESEARCH             DALLAS                     7876 ADAMS
RESEARCH             DALLAS                     7902 FORD

++视图的定义：
SQL> select text from user_views 
  2  where view_name = upper('emp_view_union');

TEXT
--------------------------------------------------------------------------------
select d.dname, d.loc, e.empno, e.ename
from emp e, dept d
where e.deptno = d.de

++重新编译视图，当视图引用的表结构发生变化时，需要视图重新编译：
SQL> alter view emp_view_union compile;

View altered.

++同义词：
++创建公有同义词：
SQL> connect / as sysdba
Connected.

SQL> create public synonym public_dept for scott.dept;

Synonym created.

++通过定义的同义词，查询对应定义的表：
SQL> r
  1* select * from public_dept

    DEPTNO DNAME                LOC
---------- -------------------- --------------------
        10 ACCOUNTING           NEW YORK
        20 RESEARCH             DALLAS
        30 SALES                CHICAGO
        40 OPERATIONS           BOSTON
        77 拓展部               JILN
        78 1                    2
        79 79                   79
        15 采购部               程度
        81 81name               81loc
        17                      北京
        57                      北京

    DEPTNO DNAME                LOC
---------- -------------------- --------------------
        58 12                   北京
        59 12                   北京
        60 12                   北京

14 rows selected.

++建立私有同义词：
++连接scott用户创建私有同义词：
SQL> connect scott     
Enter password: 
ERROR:
ORA-28002: the password will expire within 7 days


Connected.
＋＋因没有权限失败
SQL> create synonym private_dept for dept;
create synonym private_dept for dept
*
ERROR at line 1:
ORA-01031: insufficient privileges

++连接系统用户，为其授权建立私有同义词权限
SQL> connect / as sysdba
Connected.
SQL> grant create synonym to scott;

Grant succeeded.

++重新连接scott用户，创建成功
SQL> connect scott
Enter password: 
ERROR:
ORA-28002: the password will expire within 7 days


Connected.
SQL> create synonym private_dept for dept;

Synonym created.

++通过私有同义词定义的表，查询该表的数据：
SQL> select * from private_dept;

    DEPTNO DNAME                LOC
---------- -------------------- --------------------
        10 ACCOUNTING           NEW YORK
        20 RESEARCH             DALLAS
        30 SALES                CHICAGO
        40 OPERATIONS           BOSTON
        77 拓展部               JILN
        78 1                    2
        79 79                   79
        15 采购部               程度
        81 81name               81loc
        17                      北京
        57                      北京

    DEPTNO DNAME                LOC
---------- -------------------- --------------------
        58 12                   北京
        59 12                   北京
        60 12                   北京

14 rows selected.

++删除私有同义词，要有drop synonym权限：
SQL> drop synonym private_dept;

Synonym dropped.

++删除公有同义词，要有删除公有同义词权限：
SQL> connect / as sysdba
Connected.
SQL> drop public synonym public_dept;

Synonym dropped.

++序列对象：
++创建序列对象：
SQL> connect scott  
Enter password: 
Connected.
SQL> create sequence empno_seq
  2  maxvalue 99999 
  3  start with 9000
  4  increment by 100
  5  cache 50;

Sequence created.

++使用序列号对emp表进行插入操作：
SQL> insert into emp(empno, ename, deptno)
  2  values(empno_seq.nextval, '东方', 20);

1 row created.

SQL> select * from emp where ename = '东方' and deptno = 20;

     EMPNO ENAME                JOB                                MGR
---------- -------------------- --------------------------- ----------
HIREDATE               SAL       COMM     DEPTNO
--------------- ---------- ---------- ----------
      9000 东方
                                              20


SQL>    

++连续生成序列号的下一个值，得到的结果：
SQL> select empno_seq.nextval from dual;

   NEXTVAL
----------
      9100

SQL> r
  1* select empno_seq.nextval from dual

   NEXTVAL
----------
      9200

SQL> r
  1* select empno_seq.nextval from dual

   NEXTVAL
----------
      9300

SQL>    

++管理序列：
++修改序列，修改成从最大值10000，每次增加200，可以看见生成下一个从9300增加到9500
SQL> alter sequence empno_seq
  2  maxvalue 10000
  3  increment by 200
  4  cache 100;

Sequence altered.

SQL> select empno_seq.nextval from dual;

   NEXTVAL
----------
      9500

++查看序列的定义：
SQL> describe user_sequences;
 Name                                      Null?    Type
 ----------------------------------------- --------
----------------------------
 SEQUENCE_NAME                             NOT NULL VARCHAR2(30)
 MIN_VALUE                                          NUMBER
 MAX_VALUE                                          NUMBER
 INCREMENT_BY                              NOT NULL NUMBER
 CYCLE_FLAG                                         VARCHAR2(1)
 ORDER_FLAG                                         VARCHAR2(1)
 CACHE_SIZE                                NOT NULL NUMBER
 LAST_NUMBER                               NOT NULL NUMBER

++删除序列：
SQL> drop sequence empno_seq;

Sequence dropped.


++分区：
++创建分区：
SQL> create tablespace tbsp_1    
  2  datafile '/home/oracle/app/oracle/oradata/orcl/tbsp_1.dbf'
  3  size 200m    
  4  autoextend on next 200m maxsize 1g;

Tablespace created.

SQL> r  
  1  create tablespace tbsp_2
  2  datafile '/home/oracle/app/oracle/oradata/orcl/tbsp_2.dbf'
  3  size 200m
  4* autoextend on next 200m maxsize 1g

Tablespace created.

SQL> r  
  1   create table ware_retail_part
  2   (id integer primary key,
  3   retail_date date,
  4   ware_name varchar2(50)
  5   )
  6   partition by range(retail_date)
  7   (
  8   partition par_01 values less than(to_date('2011-04-01','yyyy-mm-dd')) tablespace tbsp_1,
  9   partition par_02 values less than(to_date('2011-07-01','yyyy-mm-dd')) tablespace tbsp_1,
 10   partition par_03 values less than(to_date('2011-10-01','yyyy-mm-dd')) tablespace tbsp_2,
 11   partition par_04 values less than(to_date('2012-01-01','yyyy-mm-dd')) tablespace tbsp_2
 12*  )

Table created.

++插入三条数据:
SQL> insert into ware_retail_part values(1, to_date('2011-01-20', 'yyyy-mm-dd'), '平板电脑');

1 row created.

SQL> insert into ware_retail_part values(2, to_date('2011-04-15', 'yyyy-mm-dd'),'智能手机');

1 row created.

SQL> insert into ware_retail_part values(3, to_date('2011-07-25', 'yyyy-mm-dd'), 'mp5');

1 row created.

++在ware_retail_part表的第二个分区中，查询数据：
SQL> insert into ware_retail_part values(3, to_date('2011-07-25', 'yyyy-mm-dd'), 'mp5');

1 row created.

SQL> select * from ware_retail_part partition(par_02);

	ID RETAIL_DATE	      WARE_NAME
---------- ------------------ --------------------------------------------------
         2 15-APR-11          智能手机

++按多列分区：
SQL> r
  1  create table ware_retail_part2
  2  (id integer primary key,
  3  retail_date date,
  4  ware_name varchar2(50)
  5  )
  6  partition by range(id, retail_date)
  7  (partition par_01 values less than(10000, to_date('2011-12-01', 'yyyy-mm-dd')) tablespace tbsp_1,
  8  partition par_02 values less than(20000, to_date('2012-12-01', 'yyyy-mm-dd')) tablespace tbsp_1,
  9* partition par_03 values less than(maxvalue, maxvalue) tablespace tbsp_2 )

Table created.

++哈希分区表：
++创建哈希分区表：
SQL> create table ware_retail_part3
  2  (id integer primary key,
  3  retail_date date,
  4  wara_name varchar2(50)
  5  )
  6  partition by hash(id)
  7  (partition par_01 tablespace tbsp_1,
  8  partition par_02 tablespace tbsp_2
  9  );

Table created.
++插入数据：
SQL> insert into ware_retail_part3 values(99, to_date('2011-11-11', 'yyyy-mm-dd'),'电脑');

1 row created.

SQL> select * from ware_retail_part3 where id = 99;

	ID RETAIL_DATE	      WARA_NAME
---------- ------------------ --------------------------------------------------
        99 11-NOV-11          电脑

++为哈希分区自动分配分区名：
SQL> r
  1  create table person
  2  (id number primary key,
  3  name varchar2(20),
  4  sex varchar2(2))
  5  partition by hash(id)
  6  partitions 2
  7* store in(tbsp_1, tbsp_2)

Table created.

++创建分区初始化分区大小：
SQL> create table goods
  2  (
  3  id number,
  4  goodname varchar2(50)
  5  )
  6  storage(initial 2048k)
  7  partition by hash(id)
  8  (
  9  partition par1 tablespace tbsp_1,
 10  partition par2 tablespace tbsp_2
 11  );

Table created.

++列表分区，一列的值固定是可以枚举的类型
SQL> create table clients
  2  (id integer primary key,
  3  name varchar2(50)
  4  ,province varchar2(20) 
  5  )
  6  partition by list(province)
  7  (partition shandong values('山东省'),
  8  partition guangdong values('广东省'),
  9  partition yunnan values('云南')
 10  );

Table created.

++插入分区：
SQL> insert into clients values(19, '东方', '云南');

1 row created.

++查询云南分区：
SQL> column name format a20
SQL> r
  1* select * from clients partition(yunnan)

	ID NAME 		PROVINCE
---------- -------------------- --------------------
        19 东方                 云南

++组合分区，即分区之后再分区：
++创建表person2，以id为范围分区分三个分区，再以名字做哈希创建两个子分区，名字自动分配：
SQL> r
  1  create table person2
  2  (
  3  id number primary key,
  4  name varchar2(20),
  5  sex varchar2(2)
  6  )
  7  partition by range(id)
  8  subpartition by hash(name)
  9  subpartitions 2 store in (tbsp_1, tbsp_2)
 10  (
 11  partition par1 values less than(5000),
 12  partition par2 values less than(10000),
 13  partition par3 values less than(maxvalue)
 14* )

Table created.

++interval分区：
++将表saleRecord的分区按saledate列转成年之后进行内部分区：
SQL> r
  1  create table saleRecord
  2  (id number primary key,
  3  goodsname varchar2(50),
  4  saledate date,
  5  quantity number
  6  )
  7  partition by range(saledate)
  8  interval(numtoyminterval(1, 'year'))
  9  (partition par_fist values less than (to_date('2012-01-01', 'yyyy-mm-dd'))
 10* )

Table created.

++分区管理：
++添加分区：
SQL> r
  1  create table clients
  2  (id integer primary key,
  3  name varchar2(50),
  4  province varchar2(30)
  5  )
  6  partition by list(province)
  7  (partition shandong values('山东省'),
  8  partition guangdong values('广东省'),
  9  partition yunnan values('云南省')
 10* )

Table created.

++增加分区：
SQL> r
  1  alter table clients
  2  add partition hebei values('河北省')
  3  storage(initial 10k next 20k) tablespace tbsp_1
  4  nologging
  5*

Table altered.

++合并分区：
++准备工作：
++创建两个表空间：
SQL> get tmp7
  1  create tablespace tbsp_1
  2  datafile '/home/oracle/app/oradata/orcl/tbsp_1.dbf'
  3  size 200m reuse
  4* autoextend on next 200m maxsize 1g
  5  /

Tablespace created.

SQL> r  
  1  create tablespace tbsp_2
  2  datafile '/home/oracle/app/oradata/orcl/tbsp_2.dbf'
  3  size 200m reuse
  4* autoextend on next 200m maxsize 1g

Tablespace created.

++创建带哈希分区的表，以id为哈希分区，将分区分别存在两个表空间中：
SQL> get tmp7
  1  create table person
  2  (id number primary key,
  3  name varchar2(20),
  4  sex varchar2(2))
  5  partition by hash(id)
  6  partitions 2
  7* store in(tbsp_1, tbsp_2)
  8  /

Table created.
++合并person表的两个哈希分区：
SQL> alter table person coalesce partition;

Table altered.

++合并复合分区：
SQL> get tmp7
  1  create table person2
  2  (
  3  id number primary key,
  4  name varchar2(20),
  5  sex varchar2(2)
  6  )
  7  partition by range(id)
  8  subpartition by hash(name)
  9  subpartitions 2 store in (tbsp_1, tbsp_2)
 10  (
 11  partition par1 values less than(5000),
 12  partition par2 values less than(10000),
 13  partition par3 values less than(maxvalue)
 14* )
 15  /

Table created.

SQL> alter table person2 modify partition   
  2  par3 coalesce subpartition;

Table altered.

++删除分区：
SQL> get tmp7
  1  create table ware_retail_part
  2  (id integer primary key,
  3  retail_date date,
  4  ware_name varchar2(50)
  5  )
  6  partition by range(retail_date)
  7  (
  8  partition par_01 values less than(to_date('2011-04-01','yyyy-mm-dd')) tablespace tbsp_1,
  9  partition par_02 values less than(to_date('2011-07-01','yyyy-mm-dd')) tablespace tbsp_1,
 10  partition par_03 values less than(to_date('2011-10-01','yyyy-mm-dd')) tablespace tbsp_2,
 11  partition par_04 values less than(to_date('2012-01-01','yyyy-mm-dd')) tablespace tbsp_2
 12* )
 13  /

Table created.

SQL> alter table ware_retail_part drop partition par_04;

Table altered.

++删除分区后重新分区列所在的索引：
SQL> drop table ware_retail_part;

Table dropped.

SQL> get tmp7
  1  create table ware_retail_part
  2  (id integer primary key,
  3  retail_date date,
  4  ware_name varchar2(50)
  5  )
  6  partition by range(retail_date)
  7  (
  8  partition par_01 values less than(to_date('2011-04-01','yyyy-mm-dd')) tablespace tbsp_1,
  9  partition par_02 values less than(to_date('2011-07-01','yyyy-mm-dd')) tablespace tbsp_1,
 10  partition par_03 values less than(to_date('2011-10-01','yyyy-mm-dd')) tablespace tbsp_2,
 11  partition par_04 values less than(to_date('2012-01-01','yyyy-mm-dd')) tablespace tbsp_2
 12* )
 13  /

Table created.

SQL> create index ware_index on ware_retail_part(retail_date);

Index created.

SQL> alter table ware_retail_part drop partition par_04;

Table altered.

SQL> alter index ware_index rebuild;

Index altered.

++创建全局分区索引：
SQL> get tmp8
  1  create index index_ware_retail_part
  2  on ware_retail_part(retail_date)
  3  global partition by range(retail_date)
  4  (
  5  partition par_01 values less than(to_date('2011-04-01','yyyy-mm-dd')) tablespace tbsp_1,
  6  partition par_02 values less than(to_date('2011-07-01','yyyy-mm-dd')) tablespace tbsp_1,
  7  partition par_03 values less than(to_date('2011-10-01','yyyy-mm-dd')) tablespace tbsp_2,
  8  partition par_04 values less than(to_date('2012-01-01','yyyy-mm-dd')) tablespace tbsp_2,
  9  partition par_max values less than(maxvalue) tablespace tbsp_2
 10* )
 11  /

Index created.

++删除分区，删除分区先要删掉数据及索引
++向第四分区中插入索引：

SQL> get tmp8
  1  insert into ware_retail_part
  2  (id, retail_date, ware_name)
  3  values
  4* (2, to_date('2011-10-02', 'yyyy-mm-dd'), '好2')
  5  /

1 row created.

++查看第四分区中的内容：
SQL> r  
  1* select * from ware_retail_part partition(par_04)

	ID RETAIL_DATE	      WARE_NAME
---------- ------------------ --------------------------------------------------
         2 02-OCT-11          好2

++删除分区中的数据：
SQL> delete from ware_retail_part where retail_date >= to_date('2011-10-01', 'yyyy-mm-dd');

1 row deleted.

++查看删除结果：
SQL> r  
  1* select * from ware_retail_part partition(par_04)

no rows selected

++删除分区：
SQL> alter table ware_retail_part drop partition par_04;

Table altered.

++查询表分区，已经删掉了分区：
SQL> r
  1  select partition_name from user_segments
  2* where segment_name = upper('ware_retail_part')

PARTITION_NAME
--------------------------------------------------------------------------------
PAR_01
PAR_02
PAR_03

++关闭约束再删除分区操作过程：
++查看ware_retail_part表主键：
SQL> r
  1  select cons.CONSTRAINT_NAME,
  2	    col.COLUMN_NAME,
  3  cons.table_name,
  4  cons.CONSTRAINT_TYPE
  5  from user_constraints cons,
  6	  user_cons_columns col
  7  where cons.table_name = upper('ware_retail_part')
  8* and cons.table_name = col.table_name

CONSTRAINT_NAME
--------------------------------------------------------------------------------
COLUMN_NAME
--------------------------------------------------------------------------------
TABLE_NAME
--------------------------------------------------------------------------------
C
-
SYS_C007465
ID
WARE_RETAIL_PART
P

++设置主键状态为disable
SQL> alter table WARE_RETAIL_PART
  2  disable constraints SYS_C007465;

Table altered.

++查看约束状态：
SQL> r  
  1  select cons.CONSTRAINT_NAME,
  2	    col.COLUMN_NAME,
  3  cons.table_name,
  4  cons.STATUS,
  5  cons.CONSTRAINT_TYPE
  6  from user_constraints cons,
  7	  user_cons_columns col
  8  where cons.table_name = upper('ware_retail_part')
  9* and cons.table_name = col.table_name

CONSTRAINT_NAME
--------------------------------------------------------------------------------
COLUMN_NAME
--------------------------------------------------------------------------------
TABLE_NAME
--------------------------------------------------------------------------------
STATUS	 C
-------- -
SYS_C007465
ID
WARE_RETAIL_PART
DISABLED P

SQL> alter table WARE_RETAIL_PART
  2  drop partition PAR_01;

Table altered.


SQL> alter table WARE_RETAIL_PART
  2  disable constraints SYS_C007465;

Table altered.

++并入分区：
++创建分区表：
SQL> r
  1  create table sales
  2  (
  3  id number primary key,
  4  goodsname varchar2(10),
  5  saledate date
  6  )
  7  partition by range(saledate)
  8  (
  9  partition part_sea1 values less than (to_date('2011-04-01','yyyy-mm-dd')) tablespace tbsp_1,
 10  partition part_sea2 values less than (to_date('2011-07-01','yyyy-mm-dd')) tablespace tbsp_2,
 11  partition part_sea3 values less than (to_date('2011-10-01','yyyy-mm-dd')) tablespace tbsp_1,
 12  partition part_sea4 values less than (to_date('2012-01-01','yyyy-mm-dd')) tablespace tbsp_2
 13* )

Table created.

++创建局部索引：
SQL> r
  1  create index index_3_4 on sales(saledate)
  2  local (
  3  partition part_sea1 tablespace tbsp_1,
  4  partition part_sea2 tablespace tbsp_2,
  5  partition part_sea3 tablespace tbsp_1,
  6  partition part_sea4 tablespace tbsp_2
  7* )

Index created.

++合并分区：
SQL> r
  1  alter table sales
  2  merge partitions part_sea3, part_sea4
  3* into partition part_sea4

Table altered.

++重新建立局部索引：
SQL> alter table sales          
  2  modify partition part_sea4 rebuild          
  3  unusable local indexes;

Table altered.

++创建索引分区：
++创建本地索引分区：
++先创建本地表空间：
SQL> r  
  1  create tablespace ts_1
  2  datafile '/home/oracle/app/oradata/orcl/ts1.dbf'
  3  size 10m
  4* extent management local autoallocate

Tablespace created.

SQL> r  
  1  create tablespace ts_2
  2  datafile '/home/oracle/app/oradata/orcl/ts2.dbf'
  3  size 10m
  4* extent management local autoallocate

Tablespace created.

SQL> r
  1  create tablespace ts_3
  2  datafile '/home/oracle/app/oradata/orcl/ts3.dbf'
  3  size 10m
  4* extent management local autoallocate

Tablespace created.

++创建分区表，有三个分区，分别位于刚创建的三个表空间上：
SQL> r
  1  create table studentgrade
  2  (
  3  id number primary key,
  4  name varchar2(10),
  5  subject varchar2(10),
  6  grade number
  7  )
  8  partition by range(grade)
  9  (
 10  partition par_nopass values less than(60) tablespace ts_1,
 11  partition par_pass values less than(70) tablespace ts_2,
 12  partition par_good values less than(maxvalue) tablespace ts_3
 13* )

Table created.

++根据表分区创建本地索引分区，与表分区一致
SQL> create index grade_index on studentgrade(grade)
  2  local
  3  (
  4  partition p1 tablespace ts_1,
  5  partition p2 tablespace ts_2,
  6  partition p3 tablespace ts_3
  7  );

Index created.

++查询索引分区信息
SQL> r
  1  select partition_name,tablespace_name from dba_ind_partitions
  2* where index_name = 'GRADE_INDEX'

PARTITION_NAME	     TABLESPACE_NAME
-------------------- --------------------
P1		     TS_1
P2		     TS_2
P3		     TS_3

++全局分区索引：
SQL> r
  1  create table books
  2* (saleprice integer)

Table created.

++为分区创建全局索引：
SQL> create index index_saleprice on books(saleprice)
  2  global partition by range(saleprice)
  3  (partition p1 values less than(30),
  4  partition p2 values less than(50),
  5  partition p3 values less than(maxvalue)
  6  );

Index created.

++添加列：
SQL> alter table books
  2  add (isbn integer);

++添加的列上创建全局哈希分区和索引列：
SQL> create index index_isbn on books(isbn)
  2  global partition by hash(isbn);

Index created.

++删除索引分区：
SQL> alter index index_saleprice drop partition p2;

Index altered.

++重建索引分区：
++将分区1也删掉，只留分区三
SQL> alter index index_saleprice drop partition p1;

Index altered.

++重建唯一索引分区：
SQL> alter index index_saleprice rebuild partition p3;

Index altered.

++重命名索引分区：
SQL> alter index index_saleprice rename partition p3 to p_new;

Index altered.

++当创建用户提示规则错误时，切换容器方法：
++查看当前容器：
SQL> select sys_context ('USERENV', 'CON_NAME') from dual; 

SYS_CONTEXT('USERENV','CON_NAME')
--------------------------------------------------------------------------------
CDB$ROOT


++查看当前容器权限：
SQL> r
  1* select con_id,dbid,NAME,OPEN_MODE from v$pdbs

    CON_ID	 DBID NAME		   OPEN_MODE
---------- ---------- -------------------- ----------
	 2 2812538733 PDB$SEED		   READ ONLY
	 3 1142406014 ORCLPDB		   MOUNTED

++打开数据库：
SQL> alter pluggable database ORCLPDB open;

Pluggable database altered.

++查看数据库状态：
SQL> select con_id,dbid,NAME,OPEN_MODE from v$pdbs;

    CON_ID	 DBID NAME		   OPEN_MODE
---------- ---------- -------------------- ----------
	 2 2812538733 PDB$SEED		   READ ONLY
	 3 1142406014 ORCLPDB		   READ WRITE

++切换容器：
SQL> alter session set container=ORCLPDB
  2  ;

Session altered.

++查看当前容器
SQL> select sys_context ('USERENV', 'CON_NAME') from dual; 

SYS_CONTEXT('USERENV','CON_NAME')
--------------------------------------------------------------------------------
ORCLPDB

++创建用户名
SQL> create user informix identified by gmgl;

User created.

++创建用户，默认表空间为users，临时表空间为temp
SQL> create user mr identified by mrsoft
  2  default tablespace users
  3  temporary tablespace temp;

User created.


++创建用户名，user默认表空间，temp临时表空间
++允许在tbsp_1上的最大空间为10m
++禁止使用某表空间，直接设置为0m
SQL> r
  1  create user east identified by mrsoft
  2  default tablespace users
  3  temporary tablespace temp
  4* quota 10 on tbsp_1

User created.

++创建用户df，在默认表空间tbsp_1上的使用没有限制：
SQL> create user df identified by mrsoft
  2  default tablespace tbsp_1
  3  temporary tablespace temp
  4  quota unlimited on tbsp_1;

User created.

++修改用户：
++修改east在表空间tbsp_1表空间大小为20m
SQL> alter user east quota 20m on tbsp_1;

User altered.

++修改用户口令：
SQL> alter user east identified by 123456;

User altered.

++查看系统表用户状态：
SQL> r
  1* select username, account_status from dba_users

USERNAME	     ACCOUNT_STATUS
-------------------- --------------------------------
SYS		     OPEN
SYSTEM		     OPEN
XS$NULL 	     EXPIRED & LOCKED
LBACSYS 	     EXPIRED & LOCKED
OUTLN		     EXPIRED & LOCKED
DBSNMP		     EXPIRED & LOCKED
APPQOSSYS	     EXPIRED & LOCKED
DBSFWUSER	     EXPIRED & LOCKED
GGSYS		     EXPIRED & LOCKED
ANONYMOUS	     EXPIRED & LOCKED
HR		     EXPIRED & LOCKED

USERNAME	     ACCOUNT_STATUS
-------------------- --------------------------------
CTXSYS		     EXPIRED & LOCKED
SI_INFORMTN_SCHEMA   EXPIRED & LOCKED
DVSYS		     EXPIRED & LOCKED
DVF		     EXPIRED & LOCKED
GSMADMIN_INTERNAL    EXPIRED & LOCKED
ORDPLUGINS	     EXPIRED & LOCKED
MDSYS		     EXPIRED & LOCKED
OLAPSYS 	     EXPIRED & LOCKED
ORDDATA 	     EXPIRED & LOCKED
XDB		     EXPIRED & LOCKED
WMSYS		     EXPIRED & LOCKED

USERNAME	     ACCOUNT_STATUS
-------------------- --------------------------------
ORDSYS		     EXPIRED & LOCKED
GSMCATUSER	     EXPIRED & LOCKED
MDDATA		     EXPIRED & LOCKED
SYSBACKUP	     EXPIRED & LOCKED
REMOTE_SCHEDULER_AGE EXPIRED & LOCKED
NT

PDBADMIN	     OPEN
EAST		     OPEN
GSMUSER 	     EXPIRED & LOCKED
SYSRAC		     EXPIRED & LOCKED

USERNAME	     ACCOUNT_STATUS
-------------------- --------------------------------
OJVMSYS 	     EXPIRED & LOCKED
AUDSYS		     EXPIRED & LOCKED
DIP		     EXPIRED & LOCKED
SYSKM		     EXPIRED & LOCKED
ORACLE_OCM	     EXPIRED & LOCKED
SYS$UMF 	     EXPIRED & LOCKED
MR		     OPEN
SYSDG		     EXPIRED & LOCKED
SPATIAL_CSW_ADMIN_US EXPIRED & LOCKED
R


USERNAME	     ACCOUNT_STATUS
-------------------- --------------------------------
DF		     OPEN

41 rows selected.

++解锁hr用户
SQL> alter user hr account unlock;

User altered.

++查看hr用户状态：
SQL> r
  1  select username, account_status from dba_users
  2* where username = upper('hr')

USERNAME	     ACCOUNT_STATUS
-------------------- --------------------------------
HR		     EXPIRED

++级联删除用户
SQL> drop user df cascade;

User dropped.

++授权：
SQL> connect system
Enter password: 
Connected.
SQL> create user c##east identified by 123456;

User created.

SQL> alter user c##east account unlock;

User altered.

SQL> grant create session, connect, resource to c##east;

Grant succeeded.

SQL> connect c##east  
Enter password: 
Connected.

++允许授权权限的用户继续授权选项用法：

++创建dongfang、xifang两个用户
SQL> create user c##dongfang identified by mrsoft
  2  default tablespace users
  3  quota 10m on users;

User created.

SQL> create user c##xifang identified by mrsoft
  2  default tablespace users
  3  quota 10m on users;

User created.

++授权给东方用户权限，并且允许东方继续授权该权限
SQL> grant create session, create table to c##dongfang with admin option;

Grant succeeded.

链接dongfang用户，并且dongfang将权限授权给了xifang用户
SQL> connect c##dongfang/mrsoft;
Connected.
SQL> grant create session,create table to c##xifang;

Grant succeeded.

++链接xifang用户，用得到的创建表格权限，创建了个表
SQL> connect c##xifang/mrsoft;
Connected.
SQL> create table tb_xifang 
  2  (id number,
  3  name varchar2(10));

Table created.

SQL>    

++回收权限：
SQL> connect system
Enter password: 
Connected.
SQL> revoke resource from c##east;

Revoke succeeded.

++查看回收有with admin option的选项被回收时，被间接授权的用户会怎么样：
SQL> revoke create table from c##dongfang;

Revoke succeeded.

++链接创建表，还是能创建，间接授权的权限没有被回收
SQL> connect c##xifang/mrsoft;
Connected.

SQL> create table xifang2
  2  (id number,
  3  name varchar2(10));

Table created.

++对象授权：
SQL> create user c##nanfang identified by mrsoft;

User created.

SQL> 3 quota 10m on users;
SQL> r
  1  alter user c##nanfang
  2  default tablespace users
  3* quota 10m on users

User altered.

SQL> grant create table to c##nanfang;

Grant succeeded.


++授权建立链接
SQL> grant create session to c##nanfang;

Grant succeeded.

SQL> connect c##nanfang;
Enter password: 
Connected.

SQL> create table nanfangt1 
  2  (id number,
  3  name varchar2(10));

Table created.

SQL> insert into nanfangt1 
  2  (id, name)
  3  values
  4  (1, 'name1');

1 row created.

SQL> connect system
Enter password: 
Connected.

SQL> grant select, insert, update, delete
  2  on c##nanfang.nanfangt1
  3  to c##dongfang
  4  with grant option;

Grant succeeded.

SQL> connect c##dongfang/mrsoft;
Connected.

SQL> grant select on c##nanfang.nanfangt1
  2  to c##xifang;

Grant succeeded.

SQL> connect c##xifang/mrsoft;
Connected.
SQL> select * from c##nanfang.nanfangt1;

	ID NAME
---------- ----------
	 1 name1

QL> revoke select on c##nanfang.nanfangt1    
  2  from c##dongfang;

Revoke succeeded.

++当授权的上级用户被回收对象权限时，被间接授予对象权限的用户
++也失去了对象权限，对原查询没有了权限
SQL> select * from c##nanfang.nanfangt1;
select * from c##nanfang.nanfangt1
                         *
ERROR at line 1:
ORA-00942: table or view does not exist

++角色
++查看系统角色定义：
SQL> r
  1* select * from dba_roles

ROLE				  ROLE_ID PASSWORD AUTHENTICAT COM O INH IMP
------------------------------ ---------- -------- ----------- --- - --- ---
CONNECT 				2 NO	   NONE        YES Y NO  NO
RESOURCE				3 NO	   NONE        YES Y NO  NO
DBA					4 NO	   NONE        YES Y NO  NO
PDB_DBA 				5 NO	   NONE        YES Y NO  NO
AUDIT_ADMIN				6 NO	   NONE        YES Y NO  NO
AUDIT_VIEWER				7 NO	   NONE        YES Y NO  NO
SELECT_CATALOG_ROLE		       10 NO	   NONE        YES Y NO  NO
EXECUTE_CATALOG_ROLE		       11 NO	   NONE        YES Y NO  NO
CAPTURE_ADMIN			       12 NO	   NONE        YES Y NO  NO
EXP_FULL_DATABASE		       14 NO	   NONE        YES Y NO  NO
IMP_FULL_DATABASE		       15 NO	   NONE        YES Y NO  NO
CDB_DBA 			       16 NO	   NONE        YES Y NO  NO
APPLICATION_TRACE_VIEWER	       17 NO	   NONE        YES Y NO  NO
LOGSTDBY_ADMINISTRATOR		       18 NO	   NONE        YES Y NO  NO
DBFS_ROLE			       19 NO	   NONE        YES Y NO  NO
GSMUSER_ROLE			       20 NO	   NONE        YES Y NO  NO
AQ_ADMINISTRATOR_ROLE		       24 NO	   NONE        YES Y NO  NO
AQ_USER_ROLE			       25 NO	   NONE        YES Y NO  NO
DATAPUMP_EXP_FULL_DATABASE	       26 NO	   NONE        YES Y NO  NO
DATAPUMP_IMP_FULL_DATABASE	       27 NO	   NONE        YES Y NO  NO
ADM_PARALLEL_EXECUTE_TASK	       28 NO	   NONE        YES Y NO  NO
PROVISIONER			       29 NO	   NONE        YES Y NO  NO
XS_SESSION_ADMIN		       30 NO	   NONE        YES Y NO  NO
XS_NAMESPACE_ADMIN		       31 NO	   NONE        YES Y NO  NO
XS_CACHE_ADMIN			       32 NO	   NONE        YES Y NO  NO
XS_CONNECT			       33 NO	   NONE        YES Y NO  NO
GATHER_SYSTEM_STATISTICS	       36 NO	   NONE        YES Y NO  NO
GSM_POOLADMIN_ROLE		       57 NO	   NONE        YES Y NO  NO
OPTIMIZER_PROCESSING_RATE	       37 NO	   NONE        YES Y NO  NO
DBMS_MDX_INTERNAL		       38 NO	   NONE        YES Y NO  NO
RECOVERY_CATALOG_OWNER		       40 NO	   NONE        YES Y NO  NO
RECOVERY_CATALOG_OWNER_VPD	       41 NO	   NONE        YES Y NO  NO
RECOVERY_CATALOG_USER		       42 NO	   NONE        YES Y NO  NO
EM_EXPRESS_BASIC		       43 NO	   NONE        YES Y NO  NO
EM_EXPRESS_ALL			       44 NO	   NONE        YES Y NO  NO
SYSUMF_ROLE			       45 NO	   NONE        YES Y NO  NO
SCHEDULER_ADMIN 		       47 NO	   NONE        YES Y NO  NO
HS_ADMIN_SELECT_ROLE		       48 NO	   NONE        YES Y NO  NO
HS_ADMIN_EXECUTE_ROLE		       49 NO	   NONE        YES Y NO  NO
HS_ADMIN_ROLE			       50 NO	   NONE        YES Y NO  NO
GLOBAL_AQ_USER_ROLE		       51 GLOBAL   GLOBAL      YES Y NO  NO
OEM_ADVISOR			       52 NO	   NONE        YES Y NO  NO
OEM_MONITOR			       53 NO	   NONE        YES Y NO  NO
GSMADMIN_ROLE			       56 NO	   NONE        YES Y NO  NO
EJBCLIENT			       78 NO	   NONE        YES Y NO  NO
GDS_CATALOG_SELECT		       58 NO	   NONE        YES Y NO  NO
GGSYS_ROLE			       61 NO	   NONE        YES Y NO  NO

ROLE				  ROLE_ID PASSWORD AUTHENTICAT COM O INH IMP
------------------------------ ---------- -------- ----------- --- - --- ---
XDBADMIN			       64 NO	   NONE        YES Y NO  NO
XDB_SET_INVOKER 		       65 NO	   NONE        YES Y NO  NO
AUTHENTICATEDUSER		       66 NO	   NONE        YES Y NO  NO
XDB_WEBSERVICES 		       67 NO	   NONE        YES Y NO  NO
XDB_WEBSERVICES_WITH_PUBLIC	       68 NO	   NONE        YES Y NO  NO
XDB_WEBSERVICES_OVER_HTTP	       69 NO	   NONE        YES Y NO  NO
SODA_APP			       70 NO	   NONE        YES Y NO  NO
DATAPATCH_ROLE			       71 NO	   NONE        YES Y NO  NO
WM_ADMIN_ROLE			       73 NO	   NONE        YES Y NO  NO
JAVAUSERPRIV			       74 NO	   NONE        YES Y NO  NO
JAVAIDPRIV			       75 NO	   NONE        YES Y NO  NO
JAVASYSPRIV			       76 NO	   NONE        YES Y NO  NO
JAVADEBUGPRIV			       77 NO	   NONE        YES Y NO  NO
CSW_USR_ROLE			       99 NO	   NONE        YES Y NO  NO
JMXSERVER			       79 NO	   NONE        YES Y NO  NO
DBJAVASCRIPT			       80 NO	   NONE        YES Y NO  NO
JAVA_ADMIN			       82 NO	   NONE        YES Y NO  NO
JAVA_DEPLOY			       83 NO	   NONE        YES Y NO  NO
CTXAPP				       85 NO	   NONE        YES Y NO  NO
ORDADMIN			       91 NO	   NONE        YES Y NO  NO
OLAP_XS_ADMIN			       92 NO	   NONE        YES Y NO  NO
OLAP_DBA			       94 NO	   NONE        YES Y NO  NO
OLAP_USER			       95 NO	   NONE        YES Y NO  NO
SPATIAL_CSW_ADMIN		       97 NO	   NONE        YES Y NO  NO
DV_SECANALYST			  1279994 NO	   NONE        YES Y NO  NO
RDFCTX_ADMIN			      100 NO	   NONE        YES Y NO  NO
LBAC_DBA			      102 NO	   NONE        YES Y NO  NO
DV_REALM_OWNER			      105 NO	   NONE        YES Y NO  NO
DV_MONITOR		       2147483628 NO	   NONE        YES Y NO  NO
DV_ADMIN			  1279993 NO	   NONE        YES Y NO  NO
DV_OWNER			  1279992 NO	   NONE        YES Y NO  NO
DV_ACCTMGR			  1279991 NO	   NONE        YES Y NO  NO
DV_PUBLIC			  1279995 NO	   NONE        YES Y NO  NO
DV_PATCH_ADMIN		       2147483627 NO	   NONE        YES Y NO  NO
DV_STREAMS_ADMIN	       2147483629 NO	   NONE        YES Y NO  NO
DV_GOLDENGATE_ADMIN	       2147483630 NO	   NONE        YES Y NO  NO
DV_XSTREAM_ADMIN	       2147483631 NO	   NONE        YES Y NO  NO
DV_GOLDENGATE_REDO_ACCESS      2147483632 NO	   NONE        YES Y NO  NO
DV_AUDIT_CLEANUP	       2147483633 NO	   NONE        YES Y NO  NO
DV_DATAPUMP_NETWORK_LINK       2147483634 NO	   NONE        YES Y NO  NO
DV_POLICY_OWNER 	       2147483635 NO	   NONE        YES Y NO  NO
DV_REALM_RESOURCE		      104 NO	   NONE        YES Y NO  NO

89 rows selected.

++创建规则：
SQL> create role c##designer identified by 123456;

Role created.

++授权给角色：
SQL> grant create view, create table to c##designer;

Grant succeeded.

++将角色授权给东方用户
SQL> grant c##designer to c##dongfang;

Grant succeeded.

++查询角色权限：
SQL> select * from role_sys_privs where role = upper('c##designer');

ROLE			       PRIVILEGE				ADM COM
------------------------------ ---------------------------------------- --- ---
INH
---
C##DESIGNER		       CREATE VIEW				NO  NO
NO

C##DESIGNER		       CREATE TABLE				NO  NO
NO


++修改角色密码：
SQL> alter role c##designer not identified;

Role altered.

SQL> alter role c##designer identified by mrsoft;

Role altered.

++设置角色生效：
SQL> create role c##quereyer;

Role created.

++设置角色生效
SQL> set role c##quereyer;

Role set.
++设置密码生效
SQL> set role c##designer identified by mrsoft;

Role set.

++删除角色：
SQL> drop role c##quereyer;

Role dropped.

++产寻当前用户的角色：
SQL> select * from session_roles;

ROLE
------------------------------
C##DESIGNER

++创建profile
SQL> create profile c##lock_account      
  2  limit
  3  failed_login_attempts 5 
  4  password_lock_time 7;

Profile created.

++将新创建的名为c##lock_account的profile给用户c##dongfang
SQL> alter user c##dongfang 
  2  profile c##lock_account;

User altered.

++之后故意输入五次错误，用户再登录之后将提示被锁定：
SQL> connect c##dongfang 
Enter password: 
ERROR:
ORA-01017: invalid username/password; logon denied


Warning: You are no longer connected to ORACLE.
SQL> connect c##dongfang
Enter password: 
ERROR:
ORA-01017: invalid username/password; logon denied


SQL> connect c##dongfang;
Enter password: 
ERROR:
ORA-01017: invalid username/password; logon denied


SQL> connect c##dongfang;
Enter password: 
ERROR:
ORA-01017: invalid username/password; logon denied


SQL> connect c##dongfang;
Enter password: 
ERROR:
ORA-01017: invalid username/password; logon denied


SQL> connect c##dongfang;
Enter password: 
ERROR:
ORA-28000: the account is locked


++登录system用户查看c##dongfang的状态：
SQL> connect system
Enter password: 
Connected.

++是被锁定的
SQL> select username, account_status from dba_users
  2  where username = upper('c##dongfang');

USERNAME
--------------------------------------------------------------------------------
ACCOUNT_STATUS
--------------------------------
C##DONGFANG
LOCKED(TIMED)

++对用户解锁：
SQL> alter user c##dongfang   
  2  account unlock;

User altered.

++再用正确密码登录c##dongfang
SQL> connect c##dongfang/mrsoft;
Connected.
++登录成功

++设置一个密码过期时间为30天，宽期时间为3天的profile
SQL> r
  1  create profile c##password_life_time limit
  2  password_life_time 30
  3* password_grace_time 3

Profile created.

++将profile分配给c##dongfang用户
SQL> alter user c##dongfang profile c##password_life_time;

User altered.

++30天密码过期，国期之后在三天内修改
++三天之内不改能登录，三天之后不改登录不了，要求强行修改

++设置历史密码：

++设置重用历史密码最长使用时间
SQL> create profile c##password_reuse_time   
  2  limit password_reuse_time 90;

Profile created.

++设置重用历史密码中间改变的次数
SQL> create profile c##password_reuse_max
  2  limit password_reuse_max 5;

Profile created.

++将配置分配给c##dongfang用户
SQL> alter user c##dongfang profile c##password_reuse_time;

User altered.

SQL> alter user c##dongfang profile c##password_reuse_max;

User altered.

++修改profile的资源参数，下次使用该配置文件的用户链接时才生效，已链接的不生效
SQL> r
  1  alter profile c##password_life_time limit
  2  cpu_per_session 20000
  3  sessions_per_user 10
  4  cpu_per_call 500
  5  password_life_time 180
  6* failed_login_attempts 10

Profile altered.

++删除profile文件：
SQL> drop profile c##password_life_time cascade;

Profile dropped.

++删除后没有profile配置的文件了，系统就采用默认配置

++查看用户的profile配置：
SQL> select profile from dba_users 
  2  where username = upper('c##dongfang');

PROFILE
--------------------------------------------------------------------------------
C##PASSWORD_REUSE_MAX

++这是最后一次配置的文件信息，想要想要用户所有的信息都有效，要将配置都配置到一个文件里

++查看profile文件的信息，通过dba_profiles字典，建立profile文件时，oracle会将profile的参数存在字典里
SQL> r
  1  select resource_name, resource_type, limit
  2  from dba_profiles
  3* where profile = upper('c##password_reuse_time')

RESOURCE_NAME			 RESOURCE LIMIT
-------------------------------- -------- --------------------
COMPOSITE_LIMIT 		 KERNEL   DEFAULT
SESSIONS_PER_USER		 KERNEL   DEFAULT
CPU_PER_SESSION 		 KERNEL   DEFAULT
CPU_PER_CALL			 KERNEL   DEFAULT
LOGICAL_READS_PER_SESSION	 KERNEL   DEFAULT
LOGICAL_READS_PER_CALL		 KERNEL   DEFAULT
IDLE_TIME			 KERNEL   DEFAULT
CONNECT_TIME			 KERNEL   DEFAULT
PRIVATE_SGA			 KERNEL   DEFAULT
FAILED_LOGIN_ATTEMPTS		 PASSWORD DEFAULT
PASSWORD_LIFE_TIME		 PASSWORD DEFAULT

RESOURCE_NAME			 RESOURCE LIMIT
-------------------------------- -------- --------------------
PASSWORD_REUSE_TIME		 PASSWORD 90
PASSWORD_REUSE_MAX		 PASSWORD DEFAULT
PASSWORD_VERIFY_FUNCTION	 PASSWORD DEFAULT
PASSWORD_LOCK_TIME		 PASSWORD DEFAULT
PASSWORD_GRACE_TIME		 PASSWORD DEFAULT
INACTIVE_ACCOUNT_TIME		 PASSWORD DEFAULT

17 rows selected.


