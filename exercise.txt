SQL> select * from t22;

G2_ID      G2_NAME    MEMBER          SCORE     SCORE2 TMP
---------- ---------- ---------- ---------- ---------- -----
00         A          0001               60
00         A          0002               59
00         A          0003               61
01         B          0101               80
01         B          0102               90
02         C          0201              100
01         B          0103               61
03         D

8 rows selected.


1.＋＋列出至少有一个员工的所有部门：
SQL> select g2_name
  2  from t22
  3  group by g2_name
  4  having count(member) > 0
  5* order by g2_name

G2_NAME
----------
A
B
C

++order by中排序的列，必须是group by分组的关键词或之一。
++而且必须是分组之后再排序

++另外一种方案：
++将所有员工不空的部门显示出来，并且去重，理解起来比较简单：
SQL> select distinct g2_name
  2  from t22
  3  where member is not null;

G2_NAME
----------
A
B
C

2.++列出成绩比0001高的所有记录：
++利用查询子句完成
SQL> r
  1  select * from t22
  2  where score > (
  3     select score from t22 where member = '0001'
  4* )

G2_ID      G2_NAME    MEMBER          SCORE     SCORE2 TMP
---------- ---------- ---------- ---------- ---------- -----
00         A          0003               61
01         B          0101               80
01         B          0102               90
02         C          0201              100
01         B          0103               61

++可以将0001的score等于60，换成0003的成绩等于61
SQL> 3  
  3*    select score from t22 where member = '0001'
SQL> c /0001/0003
  3*    select score from t22 where member = '0003'
SQL> r
  1  select * from t22
  2  where score > (
  3     select score from t22 where member = '0003'
  4* )

G2_ID      G2_NAME    MEMBER          SCORE     SCORE2 TMP
---------- ---------- ---------- ---------- ---------- -----
01         B          0101               80
01         B          0102               90
02         C          0201              100

3.++显示成员所在的组的全部信息：
SQL> r
  1  select g1_id, g1_name, t2.g2_id, t2.g2_name, member, score, score2
  2  from t1, t2
  3* where t1.g2_id = t2.g2_id

G1_ID G1_NAME    G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
----- ---------- ---------- ---------- ---------- ---------- ----------
0     a          00         A          0001               60
0     a          00         A          0002               59
0     a          00         A          0003               61
1+    b+         01         B          0101               80
1     b          01         B          0101               80
1+    b+         01         B          0102               90
1     b          01         B          0102               90
1+    b+         01         B          0103               61
1     b          01         B          0103               61

9 rows selected.

SQL> r
  1  select g1_id, g1_name, g2_id, t2.g2_name, member, score, score2
  2  from t1
  3  join t2
  4* using(g2_id)

G1_ID G1_NAME    G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
----- ---------- ---------- ---------- ---------- ---------- ----------
0     a          00         A          0001               60
0     a          00         A          0002               59
0     a          00         A          0003               61
1+    b+         01         B          0101               80
1     b          01         B          0101               80
1+    b+         01         B          0102               90
1     b          01         B          0102               90
1+    b+         01         B          0103               61
1     b          01         B          0103               61

9 rows selected.

++注意用oracle的连接方法和sql标准语句的区别
＋＋标准sql中using中引用的列在select显示列中可以不标注表明，因为using就标志这两个表连接的这一列是相同的，彼此一样
＋＋而oracle的连接函数则不能省略表名，因为oracle连接用的where语句比较两列，两列的名称可以相同，也可以不同，显示的列无法辨别是相同的

=================================
++老师及学生成绩数据分析：
++执行sql脚本：exercise_sql_01.sql
++1、查询“c001”课程比“c002”课程成绩高的所有学生的学号；
++自己想到的做法：
SQL> r
  1  select a.sno, a.score c001_score,  b.score c002_score
  2  from sc a, sc b
  3* where a.sno = b.sno and a.cno = 'c001' and b.cno = 'c002' and a.score >
b.score

SNO                  C001_SCORE C002_SCORE
-------------------- ---------- ----------
s002                       80.9       72.9

++参考答案给的做法两种：
++第一种：
++先为两种成绩准备好两个表，然后再进行对比
SQL> r
  1  select a.sno, a.score c001_score,  b.score c002_score
  2  from (select * from sc where cno = 'c001') a
  3  , (select * from sc where cno = 'c002') b
  4* where a.sno = b.sno and a.score > b.score

SNO                  C001_SCORE C002_SCORE
-------------------- ---------- ----------
s002                       80.9       72.9
++第二种：
++按成绩1查找到出记录，再按成绩2查找该表，并配合是否是该人成绩和成绩2是否大于成绩1，如果存在则返回where条件的真值
＋＋则查询语句会输出
SQL> select * from sc a where a.cno = 'c001'
  2  and exists(select * from sc b where a.sno = b.sno and b.cno = 'c002' and a.score > b.score);

SNO                  CNO                                 SCORE
-------------------- ------------------------------ ----------
s002                 c001                                 80.9

++2、查询平均成绩大于60 分的同学的学号和平均成绩；
++没啥太多需要解释的，分组函数查平均成绩，并且对分组函数加条件，所以用having
SQL> select sno, avg(score) from sc       
  2  group by sno 
  3  having  avg(score) > 60;

SNO                  AVG(SCORE)
-------------------- ----------
s001                      70.95
s002                       76.9
s003                       81.9
s004                       60.9

++3、查询所有同学的学号、姓名、选课数、总成绩；
++自我实现方法：
SQL> r
  1  select a.sno, sname, count, sum
  2  from student a
  3  , (select sno, count(cno) count, sum(score) sum from sc group by sno) b
  4* where a.sno = b.sno

SNO                  SNAME                     COUNT        SUM
-------------------- -------------------- ---------- ----------
s001                 张三                          2      141.9
s002                 李四                          2      153.8
s003                 吴鹏                          2      163.8
s004                 琴沁                          1       60.9

＋＋参考答案实现方法：
SQL> select a.*,s.sname from (select sno,sum(score),count(cno) from sc group
by sno) a ,student s where a.sno=s.sno;

SNO                  SUM(SCORE) COUNT(CNO) SNAME
-------------------- ---------- ---------- --------------------
s001                      141.9          2 张三
s002                      153.8          2 李四
s003                      163.8          2 吴鹏
s004                       60.9          1 琴沁

++4、查询姓“刘”的老师的个数；
++自我实现方法：
SQL> select count(tname) from teacher where tname like '刘%';

COUNT(TNAME)
------------
           1

++5、查询没学过“谌燕”老师课的同学的学号、姓名；
++先查到学过'谌燕'课程的学生，再从学生的总表里去掉学过的列表
SQL> r
  1  select sno, sname from student where sno not in (
  2     select sno from sc where cno in (
  3             select cno from course where tno in (
  4                     select tno from teacher where tname = '谌燕'
  5             )
  6     )
  7* )

SNO             SNAME
--------------- --------------------
s008            萧蓉
s007            刘玉
s006            李波
s005            王丽
s009            陈萧晓
s004            琴沁
s010            陈美

7 rows selected.

++通过子句联合查询得到的结果：
SQL> r  
  1  select * from student where sno not in (
  2     select c.sno from sc c, (
  3             select a.cno from course a,(
  4                     select tno from teacher where tname = '谌燕'
  5             ) b where a.tno = b.tno
  6     ) d where c.cno = d.cno
  7* )

SNO             SNAME                      SAGE SSEX
--------------- -------------------- ---------- ---------------
s008            萧蓉                         21 女
s007            刘玉                         21 男
s006            李波                         21 男
s005            王丽                         20 女
s009            陈萧晓                       23 女
s004            琴沁                         20 女
s010            陈美                         22 女

7 rows selected.

++用多表联合语句查询到学习'谌燕'老师课的所有学生的单列记录
＋＋然后再学生表将查询到的记录去除，即得到结果
SQL> r
  1  select * from student where sno not in (
  2     select c.sno
  3     from teacher a, course b, sc c
  4     where a.tname = '谌燕' and b.tno = a.tno and c.cno = b.cno
  5* )

SNO             SNAME                      SAGE SSEX
--------------- -------------------- ---------- ---------------
s008            萧蓉                         21 女
s007            刘玉                         21 男
s006            李波                         21 男
s005            王丽                         20 女
s009            陈萧晓                       23 女
s004            琴沁                         20 女
s010            陈美                         22 女

7 rows selected.

++6、查询学过“c001”并且也学过编号“c002”课程的同学的学号、姓名；
++先将成绩表内联，找到本表中两个学科都有的学生记录的学号
＋＋再根据学号匹配学号记录表
SQL> r
  1  select * from student
  2  where sno in (select a.sno from (
  3     select sno from sc where cno = 'c001') a,
  4     (select sno from sc where cno = 'c002') b
  5* where a.sno = b.sno)

SNO        SNAME            SAGE SSEX
---------- ---------- ---------- ----------
s002       李四               23 男
s003       吴鹏               25 男

++直接联合语句实现：
SQL> select * from student 
  2  where sno in (select a.sno from sc a, sc b
  3     where a.sno = b.sno and a.cno = 'c001' and b.cno = 'c002'
  4     );

SNO        SNAME            SAGE SSEX
---------- ---------- ---------- ----------
s002       李四               23 男
s003       吴鹏               25 男

++7、查询学过“谌燕”老师所教的所有课的同学的学号、姓名；
SQL> r
  1  select a.sno, a.sname
  2  from student a, sc b, course c, teacher d
  3  where d.tname = '谌燕'
  4  and d.tno = c.tno
  5  and c.cno = b.cno
  6* and b.sno = a.sno

SNO        SNAME
---------- ----------
s001       张三
s002       李四
s003       吴鹏

++8、查询课程编号“c002”的成绩比课程编号“c001”课程低的所有同学的学号、姓名；
++多表直接联合，分表找c002和c001的记录，在成绩表中，找到再对比成绩，是c002小于c001的记录，再联合学生信息表，并匹配学号和姓名
SQL> r
  1  select distinct a.sno, a.sname
  2  from student a
  3  , sc b, sc c
  4* where b.cno = 'c002' and c.cno = 'c001' and b.score < c.score and b.sno =
a.sno

SNO        SNAME
---------- ----------
s002       李四


