SQL> select * from t22;

G2_ID      G2_NAME    MEMBER          SCORE     SCORE2 TMP
---------- ---------- ---------- ---------- ---------- -----
00         A          0001               60
00         A          0002               59
00         A          0003               61
01         B          0101               80
01         B          0102               90
02         C          0201              100
01         B          0103               61
03         D

8 rows selected.


1.＋＋列出至少有一个员工的所有部门：
SQL> select g2_name
  2  from t22
  3  group by g2_name
  4  having count(member) > 0
  5* order by g2_name

G2_NAME
----------
A
B
C

++order by中排序的列，必须是group by分组的关键词或之一。
++而且必须是分组之后再排序

++另外一种方案：
++将所有员工不空的部门显示出来，并且去重，理解起来比较简单：
SQL> select distinct g2_name
  2  from t22
  3  where member is not null;

G2_NAME
----------
A
B
C

2.++列出成绩比0001高的所有记录：
++利用查询子句完成
SQL> r
  1  select * from t22
  2  where score > (
  3     select score from t22 where member = '0001'
  4* )

G2_ID      G2_NAME    MEMBER          SCORE     SCORE2 TMP
---------- ---------- ---------- ---------- ---------- -----
00         A          0003               61
01         B          0101               80
01         B          0102               90
02         C          0201              100
01         B          0103               61

++可以将0001的score等于60，换成0003的成绩等于61
SQL> 3  
  3*    select score from t22 where member = '0001'
SQL> c /0001/0003
  3*    select score from t22 where member = '0003'
SQL> r
  1  select * from t22
  2  where score > (
  3     select score from t22 where member = '0003'
  4* )

G2_ID      G2_NAME    MEMBER          SCORE     SCORE2 TMP
---------- ---------- ---------- ---------- ---------- -----
01         B          0101               80
01         B          0102               90
02         C          0201              100

3.++显示成员所在的组的全部信息：
SQL> r
  1  select g1_id, g1_name, t2.g2_id, t2.g2_name, member, score, score2
  2  from t1, t2
  3* where t1.g2_id = t2.g2_id

G1_ID G1_NAME    G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
----- ---------- ---------- ---------- ---------- ---------- ----------
0     a          00         A          0001               60
0     a          00         A          0002               59
0     a          00         A          0003               61
1+    b+         01         B          0101               80
1     b          01         B          0101               80
1+    b+         01         B          0102               90
1     b          01         B          0102               90
1+    b+         01         B          0103               61
1     b          01         B          0103               61

9 rows selected.

SQL> r
  1  select g1_id, g1_name, g2_id, t2.g2_name, member, score, score2
  2  from t1
  3  join t2
  4* using(g2_id)

G1_ID G1_NAME    G2_ID      G2_NAME    MEMBER          SCORE     SCORE2
----- ---------- ---------- ---------- ---------- ---------- ----------
0     a          00         A          0001               60
0     a          00         A          0002               59
0     a          00         A          0003               61
1+    b+         01         B          0101               80
1     b          01         B          0101               80
1+    b+         01         B          0102               90
1     b          01         B          0102               90
1+    b+         01         B          0103               61
1     b          01         B          0103               61

9 rows selected.

++注意用oracle的连接方法和sql标准语句的区别
＋＋标准sql中using中引用的列在select显示列中可以不标注表明，因为using就标志这两个表连接的这一列是相同的，彼此一样
＋＋而oracle的连接函数则不能省略表名，因为oracle连接用的where语句比较两列，两列的名称可以相同，也可以不同，显示的列无法辨别是相同的

=================================
++老师及学生成绩数据分析：
++执行sql脚本：exercise_sql_01.sql
++1、查询“c001”课程比“c002”课程成绩高的所有学生的学号；
++自己想到的做法：
SQL> r
  1  select a.sno, a.score c001_score,  b.score c002_score
  2  from sc a, sc b
  3* where a.sno = b.sno and a.cno = 'c001' and b.cno = 'c002' and a.score >
b.score

SNO                  C001_SCORE C002_SCORE
-------------------- ---------- ----------
s002                       80.9       72.9

++参考答案给的做法两种：
++第一种：
++先为两种成绩准备好两个表，然后再进行对比
SQL> r
  1  select a.sno, a.score c001_score,  b.score c002_score
  2  from (select * from sc where cno = 'c001') a
  3  , (select * from sc where cno = 'c002') b
  4* where a.sno = b.sno and a.score > b.score

SNO                  C001_SCORE C002_SCORE
-------------------- ---------- ----------
s002                       80.9       72.9
++第二种：
++按成绩1查找到出记录，再按成绩2查找该表，并配合是否是该人成绩和成绩2是否大于成绩1，如果存在则返回where条件的真值
＋＋则查询语句会输出
SQL> select * from sc a where a.cno = 'c001'
  2  and exists(select * from sc b where a.sno = b.sno and b.cno = 'c002' and a.score > b.score);

SNO                  CNO                                 SCORE
-------------------- ------------------------------ ----------
s002                 c001                                 80.9

++2、查询平均成绩大于60 分的同学的学号和平均成绩；
++没啥太多需要解释的，分组函数查平均成绩，并且对分组函数加条件，所以用having
SQL> select sno, avg(score) from sc       
  2  group by sno 
  3  having  avg(score) > 60;

SNO                  AVG(SCORE)
-------------------- ----------
s001                      70.95
s002                       76.9
s003                       81.9
s004                       60.9

++3、查询所有同学的学号、姓名、选课数、总成绩；
++自我实现方法：
SQL> r
  1  select a.sno, sname, count, sum
  2  from student a
  3  , (select sno, count(cno) count, sum(score) sum from sc group by sno) b
  4* where a.sno = b.sno

SNO                  SNAME                     COUNT        SUM
-------------------- -------------------- ---------- ----------
s001                 张三                          2      141.9
s002                 李四                          2      153.8
s003                 吴鹏                          2      163.8
s004                 琴沁                          1       60.9

＋＋参考答案实现方法：
SQL> select a.*,s.sname from (select sno,sum(score),count(cno) from sc group
by sno) a ,student s where a.sno=s.sno;

SNO                  SUM(SCORE) COUNT(CNO) SNAME
-------------------- ---------- ---------- --------------------
s001                      141.9          2 张三
s002                      153.8          2 李四
s003                      163.8          2 吴鹏
s004                       60.9          1 琴沁

++4、查询姓“刘”的老师的个数；
++自我实现方法：
SQL> select count(tname) from teacher where tname like '刘%';

COUNT(TNAME)
------------
           1

++5、查询没学过“谌燕”老师课的同学的学号、姓名；
++先查到学过'谌燕'课程的学生，再从学生的总表里去掉学过的列表
SQL> r
  1  select sno, sname from student where sno not in (
  2     select sno from sc where cno in (
  3             select cno from course where tno in (
  4                     select tno from teacher where tname = '谌燕'
  5             )
  6     )
  7* )

SNO             SNAME
--------------- --------------------
s008            萧蓉
s007            刘玉
s006            李波
s005            王丽
s009            陈萧晓
s004            琴沁
s010            陈美

7 rows selected.

++通过子句联合查询得到的结果：
SQL> r  
  1  select * from student where sno not in (
  2     select c.sno from sc c, (
  3             select a.cno from course a,(
  4                     select tno from teacher where tname = '谌燕'
  5             ) b where a.tno = b.tno
  6     ) d where c.cno = d.cno
  7* )

SNO             SNAME                      SAGE SSEX
--------------- -------------------- ---------- ---------------
s008            萧蓉                         21 女
s007            刘玉                         21 男
s006            李波                         21 男
s005            王丽                         20 女
s009            陈萧晓                       23 女
s004            琴沁                         20 女
s010            陈美                         22 女

7 rows selected.

++用多表联合语句查询到学习'谌燕'老师课的所有学生的单列记录
＋＋然后再学生表将查询到的记录去除，即得到结果
SQL> r
  1  select * from student where sno not in (
  2     select c.sno
  3     from teacher a, course b, sc c
  4     where a.tname = '谌燕' and b.tno = a.tno and c.cno = b.cno
  5* )

SNO             SNAME                      SAGE SSEX
--------------- -------------------- ---------- ---------------
s008            萧蓉                         21 女
s007            刘玉                         21 男
s006            李波                         21 男
s005            王丽                         20 女
s009            陈萧晓                       23 女
s004            琴沁                         20 女
s010            陈美                         22 女

7 rows selected.

++6、查询学过“c001”并且也学过编号“c002”课程的同学的学号、姓名；
++先将成绩表内联，找到本表中两个学科都有的学生记录的学号
＋＋再根据学号匹配学号记录表
SQL> r
  1  select * from student
  2  where sno in (select a.sno from (
  3     select sno from sc where cno = 'c001') a,
  4     (select sno from sc where cno = 'c002') b
  5* where a.sno = b.sno)

SNO        SNAME            SAGE SSEX
---------- ---------- ---------- ----------
s002       李四               23 男
s003       吴鹏               25 男

++直接联合语句实现：
SQL> select * from student 
  2  where sno in (select a.sno from sc a, sc b
  3     where a.sno = b.sno and a.cno = 'c001' and b.cno = 'c002'
  4     );

SNO        SNAME            SAGE SSEX
---------- ---------- ---------- ----------
s002       李四               23 男
s003       吴鹏               25 男

++7、查询学过“谌燕”老师所教的所有课的同学的学号、姓名；
SQL> r
  1  select a.sno, a.sname
  2  from student a, sc b, course c, teacher d
  3  where d.tname = '谌燕'
  4  and d.tno = c.tno
  5  and c.cno = b.cno
  6* and b.sno = a.sno

SNO        SNAME
---------- ----------
s001       张三
s002       李四
s003       吴鹏

++8、查询课程编号“c002”的成绩比课程编号“c001”课程低的所有同学的学号、姓名；
++多表直接联合，分表找c002和c001的记录，在成绩表中，找到再对比成绩，是c002小于c001的记录，再联合学生信息表，并匹配学号和姓名
SQL> r
  1  select distinct a.sno, a.sname
  2  from student a
  3  , sc b, sc c
  4* where b.cno = 'c002' and c.cno = 'c001' and b.score < c.score and b.sno =
a.sno

SNO        SNAME
---------- ----------
s002       李四

++9、查询所有课程成绩小于60 分的同学的学号、姓名；
++注意去重的结果是所有记录都相同才能去重，否则无法去重
SQL> r
  1  select distinct a.sno, a.sname, b.score
  2  from student a, sc b
  3* where b.score < 60 and b.sno = a.sno

SNO        SNAME           SCORE
---------- ---------- ----------
s001       张三               59
s001       张三               58

SQL> 1 select distinct a.sno, a.sname
SQL> r
  1  select distinct a.sno, a.sname
  2  from student a, sc b
  3* where b.score < 60 and b.sno = a.sno

SNO        SNAME
---------- ----------
s001       张三

++10、查询没有学全所有课的同学的学号、姓名；
++想得到所有学生成绩，必须对学生表做左联取得学生表代学科的总表，并按学号分组之后对学科做个数统计，统计之前去重；再将得到学科数量和教师授课表的去重的学科总数做比较，小于教师学科教课总数就输出学号和姓名：
SQL> r
  1  select a.sno, a.sname, count(distinct b.cno)
  2  from student a
  3  left join sc b
  4  on a.sno = b.sno
  5  group by a.sno, a.sname
  6  having count(distinct b.cno) < (
  7* select count(distinct cno) from course)

SNO        SNAME      COUNT(DISTINCTB.CNO)
---------- ---------- --------------------
s003       吴鹏                          2
s008       萧蓉                          0
s002       李四                          2
s007       刘玉                          0
s009       陈萧晓                        0
s001       张三                          3
s005       王丽                          0
s004       琴沁                          1
s010       陈美                          0
s006       李波                          0

10 rows selected.

++11、查询至少有一门课与学号为“s001”的同学所学相同的同学的学号和姓名；
++先将成绩表内联，找到与s001相同的其他成员，内联其他学生时，一定要将自己s001去掉，得到学生列表之后，再连接学生信息表，连接学号和姓名信息：
SQL> r  
  1  select distinct b.sno, c.sname
  2  from sc a, sc b, student c
  3* where a.sno = 's001' and b.sno != 's001' and a.cno = b.cno and b.sno = c.sno

SNO        SNAME
---------- ----------
s003       吴鹏
s002       李四

++13、把“SC”表中“谌燕”老师教的课的成绩都更改为此课程的平均成绩；

++心得结果：
++先得到通过老师查询学生成绩的平均值结果，再update 表格名 set 字段 ＝ (得到平均值的查询子句) where 条件进行更新：
++查询平均值结果：
SQL> r  
  1  select c.cno, avg(score)
  2  from teacher a, course b, sc c
  3  where a.tname = '谌燕' and a.tno = b.tno
  4     and b.cno = c.cno
  5* group by c.cno

CNO        AVG(SCORE)
---------- ----------
c002       79.2333333

++直接得到的结果去更新成绩表，会的到没有满足条件的列被更新为空的情况：
SQL> select * from sc;

SNO        CNO             SCORE
---------- ---------- ----------
s002       c001
s003       c001
s004       c001
s001       c002            79.23
s002       c002            79.23
s003       c002            79.23
s001       c003
s001       c004

8 rows selected.

++所以最直观的方法是，如果为空的结果，则用nvl函数更新成原来的值，结果这样做的过程可想而知，所有数据都更新了一遍，可以想象，耗时，还会引起字段被更新一遍而引起的字段被更新的数据库关联问题：
SQL> r  
  1  update sc set score = nvl((
  2     select avg(score) avg
  3     from teacher a, course b, sc c
  4     where a.tname = '谌燕' and a.tno = b.tno
  5             and b.cno = c.cno and sc.cno = c.cno
  6     group by c.cno
  7* ), sc.score)

8 rows updated.
++结果随正确，但却有问题
SQL> select * from sc;

SNO        CNO             SCORE
---------- ---------- ----------
s002       c001             80.9
s003       c001             81.9
s004       c001             60.9
s001       c002            79.23
s002       c002            79.23
s003       c002            79.23
s001       c003               59
s001       c004               58

8 rows selected.

++所以我们有必要找更合适的方法：
＋＋方法1：用where exists函数，检查查询子句是否有值，有值则更新：

SQL> r  
  1  update sc set score = (
  2     select avg(score) avg
  3     from teacher a, course b, sc c
  4     where a.tname = '谌燕' and a.tno = b.tno
  5             and b.cno = c.cno and sc.cno = c.cno
  6     group by c.cno
  7  ) where exists(
  8  select avg(score) avg
  9     from teacher a, course b, sc c
 10     where a.tname = '谌燕' and a.tno = b.tno
 11             and b.cno = c.cno and sc.cno = c.cno
 12     group by c.cno
 13* )

3 rows updated.

SQL> select * from sc;

SNO        CNO             SCORE
---------- ---------- ----------
s002       c001             80.9
s003       c001             81.9
s004       c001             60.9
s001       c002            79.23
s002       c002            79.23
s003       c002            79.23
s001       c003               59
s001       c004               58

8 rows selected.

++我们可以看到，c002的三行已经被全部更新了。

＋＋方法2：
++通过同样的方法统计出平均值，作为需要更记录的成绩新值
＋＋再通过查询老师对应的科目和学生学号，作为更新成绩表学号和学科两列的多列查询条件
＋＋更新sc成绩表时将上述两条子句按所说条件组合即可：
SQL> r  
  1  update sc set score = (
  2     select avg(score) avg
  3     from teacher a, course b, sc c
  4     where a.tname = '谌燕' and a.tno = b.tno
  5             and b.cno = c.cno and sc.cno = c.cno
  6     group by c.cno
  7  ) where (sc.sno, sc.cno) in (
  8     select c.sno, c.cno
  9     from teacher a, course b, sc c
 10     where a.tname = '谌燕' and a.tno = b.tno
 11             and b.cno = c.cno and sc.cno = c.cno
 12* )

3 rows updated.

SQL> select * from sc;

SNO        CNO             SCORE
---------- ---------- ----------
s002       c001             80.9
s003       c001             81.9
s004       c001             60.9
s001       c002            79.23
s002       c002            79.23
s003       c002            79.23
s001       c003               59
s001       c004               58

8 rows selected.


